<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Pro Order Flow - Golden Layout Edition</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸ“Š</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600;700&family=Fira+Code:wght@400;500;600;700&display=swap" rel="stylesheet">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        trade: {
                            bg: '#0a0e1a',
                            panel: '#0f1419',
                            border: '#1a1f2e',
                            accent: '#3b82f6',
                            up: '#608feb',
                            down: '#ff4242',
                            text: '#8b92a7',
                            textLight: '#e8eaed',
                            surface: '#12161f',
                            pocGold: '#f0b90b'
                        }
                    }
                }
            }
        }
    </script>
    <style>
        #layouts-dropdown.open { display: block !important; opacity: 1; transform: scaleY(1); }
        #layouts-dropdown { transform-origin: top; }

        body { 
            background-color: #0a0e1a; 
            overflow: hidden; 
            user-select: none;
            color: #8b92a7;
            margin: 0;
        }

        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #1a1f2e; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #2a2f3e; }

        /* â”€â”€ Golden Layout Container â”€â”€ */
        /* â”€â”€ Golden Layout Container (Absolute Screen Fill) â”€â”€ */
#charts-container { 
    position: absolute; 
    top: 48px; /* Fits perfectly right beneath your header */
    left: 0; 
    right: 0; 
    bottom: 0; 
    overflow: hidden; 
}
        
        /* â”€â”€ Component Wrappers â”€â”€ */
        .chart-panel-wrapper { position: relative; display: flex; flex-direction: column; width: 100%; height: 100%; overflow: hidden; }
        .chart-panel-wrapper.selected { box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.4); }

        .panel-tf-bar {
            position: absolute; top: 6px; left: 6px; z-index: 200;
            display: flex; gap: 3px; opacity: 0; pointer-events: none; transition: opacity 0.2s;
            background: rgba(10,14,26,0.88); border: 1px solid #1a1f2e;
            border-radius: 5px; padding: 3px 4px; backdrop-filter: blur(4px);
        }
        .chart-panel-wrapper:hover .panel-tf-bar { opacity: 1; pointer-events: all; }

        /* â”€â”€ Golden Layout Theme Tweaks for Dark Mode â”€â”€ */
        .lm_header { background: #0f1419 !important; border-bottom: 1px solid #1a1f2e; }
        .lm_tab { background: #12161f !important; color: #8b92a7 !important; border: 1px solid transparent; font-family: 'JetBrains Mono', monospace; font-size: 11px; }
        .lm_tab.lm_active { background: #0a0e1a !important; color: #e8eaed !important; border-top: 2px solid #3b82f6 !important; }
        .lm_splitter { background: #1a1f2e !important; }
        .lm_splitter:hover { background: rgba(59,130,246,0.2) !important; }
        .lm_content { background: #0a0e1a !important; }

        /* â”€â”€ Existing Custom Overlay & UI Styles â”€â”€ */
        .indicator-pane { 
            position: absolute; left: 0; right: 54px; background: rgba(10, 14, 26, 0.95);
            border-top: 1px solid #1a1f2e; z-index: 30; backdrop-filter: blur(4px);
            transition: bottom 0.2s ease; pointer-events: none;
        }
        .indicator-pane.dragging { z-index: 100; box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3); border: 1px solid #3b82f6; }
        .pane-canvas { display: block; width: 100%; height: 100%; pointer-events: none; }
        
        .pane-header {
            position: absolute; top: 0; left: 0; right: 0; height: 20px;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 8px; background: transparent; cursor: move;
            z-index: 100; pointer-events: auto;
        }
        .pane-header:hover { background: rgba(10, 14, 26, 0.8); backdrop-filter: blur(4px); }
        .pane-header:hover .pane-label { color: #a6afd3; }
        .pane-header:hover .pane-close { color: #8b92a7; }

        .pane-label { 
            font-size: 9px; text-transform: uppercase; letter-spacing: 0.05em;
            color: rgba(139, 146, 167, 0.5); font-family: 'JetBrains Mono', monospace; 
            font-weight: 600; transition: color 0.2s;
        }
        .pane-close {
            width: 14px; height: 14px; display: flex; align-items: center; justify-content: center;
            border-radius: 2px; font-size: 11px; color: rgba(139, 146, 167, 0.5);
            cursor: pointer; transition: all 0.2s;
        }
        .pane-close:hover { background: rgba(255, 66, 66, 0.2); color: #ff4242; }

        .resizer-handle {
            position: absolute; top: -5px; left: 0; right: 0; height: 10px;
            cursor: ns-resize; z-index: 50; display: flex; align-items: center;
            justify-content: center; pointer-events: auto;
        }
        .resizer-line { width: 0%; height: 0px; background: transparent; }
        .resizer-handle:hover .resizer-line { background: transparent; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #e8eaed; border: 2px solid #3b82f6; cursor: pointer; margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #1a1f2e; border-radius: 2px; }

        select, input[type="number"], input[type="text"] {
            appearance: none; background-color: #0f1419; border: 1px solid #1a1f2e;
            color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 12px;
            border-radius: 4px; transition: all 0.2s;
        }
        select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        
        .select-wrapper { position: relative; }
        .select-wrapper::after {
            content: 'â–¼'; font-size: 8px; color: #5a6178; position: absolute;
            right: 10px; top: 50%; transform: translateY(-50%); pointer-events: none;
        }
        
        .color-picker-wrapper {
            position: relative; height: 28px; width: 100%; border-radius: 4px;
            overflow: hidden; border: 1px solid #1a1f2e; cursor: pointer; transition: all 0.2s;
        }
        .color-picker-wrapper:hover { border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        input[type="color"] { border: none; width: 200%; height: 200%; transform: translate(-25%, -25%); cursor: pointer; background: none; }

        .timeframe-btn {
            padding: 4px 10px; background: transparent; border: 1px solid #1a1f2e;
            color: #8b92a7; font-size: 11px; font-family: 'JetBrains Mono', monospace;
            border-radius: 4px; cursor: pointer; transition: all 0.2s;
        }
        .timeframe-btn:hover { background: #1a1f2e; color: #e8eaed; }
        .timeframe-btn.active { background: #3b82f6; border-color: #3b82f6; color: white; font-weight: 600; }

        .timeframe-btn-plus {
            padding: 4px 8px; background: transparent; border: 1px solid #1a1f2e;
            color: #8b92a7; font-size: 14px; font-family: 'JetBrains Mono', monospace;
            border-radius: 4px; cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .timeframe-btn-plus:hover { background: #1a1f2e; color: #3b82f6; border-color: #3b82f6; transform: rotate(90deg); }

        #custom-price-label {
            position: absolute; right: 0; z-index: 40; pointer-events: none;
            display: flex; align-items: center; gap: 1px;
        }
        .price-label-box {
            border-radius: 4px; padding: 5px 10px; font-weight: 600; display: flex;
            flex-direction: column; align-items: flex-end; min-width: 68px; gap: 2px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        .price-label-box::before {
            content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            border-radius: 3px; pointer-events: none;
        }
        .price-label-arrow {display: none !important;}

        .indicator-toggle {
            display: flex; align-items: center; gap: 8px; padding: 6px 12px;
            background: transparent; border: 1px solid #1a1f2e; border-radius: 4px;
            cursor: pointer; transition: all 0.2s; font-size: 11px;
            font-family: 'JetBrains Mono', monospace; color: #8b92a7;
        }
        .indicator-toggle:hover { background: #1a1f2e; color: #e8eaed; }
        .indicator-toggle.active { background: rgba(59, 130, 246, 0.1); border-color: #3b82f6; color: #3b82f6; }

        .indicator-checkbox {
            width: 14px; height: 14px; border: 2px solid #1a1f2e; border-radius: 3px;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        .indicator-toggle.active .indicator-checkbox { background: #3b82f6; border-color: #3b82f6; }
        .indicator-checkbox svg { width: 10px; height: 10px; stroke: white; opacity: 0; transition: opacity 0.2s; }
        .indicator-toggle.active .indicator-checkbox svg { opacity: 1; }

        .drag-placeholder {
            position: absolute; left: 0; right: 77px; height: 2px;
            background: #3b82f6; z-index: 150; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(4px); z-index: 9999;
            display: flex; align-items: center; justify-content: center; opacity: 0;
            transition: opacity 0.3s ease; pointer-events: none;
        }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
        .modal-content {
            background: linear-gradient(135deg, #0d1117 0%, #0f1419 100%); border: 1px solid #1a1f2e;
            border-radius: 12px; padding: 32px; min-width: 400px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .modal-overlay.active .modal-content { transform: scale(1); }
        .modal-title { font-family: 'JetBrains Mono', monospace; font-size: 18px; font-weight: 600; color: #e8eaed; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-description { font-size: 13px; color: #8b92a7; margin-bottom: 24px; line-height: 1.5; }
        .modal-input { width: 100%; padding: 12px 16px; background: #0a0e1a; border: 2px solid #1a1f2e; border-radius: 8px; color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 16px; transition: all 0.2s; margin-bottom: 24px; }
        .modal-buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .modal-btn { padding: 10px 24px; border-radius: 6px; font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-btn-cancel { background: transparent; border: 1px solid #1a1f2e; color: #8b92a7; }
        .modal-btn-cancel:hover { background: #1a1f2e; color: #e8eaed; }
        .modal-btn-confirm { background: #3b82f6; border: 1px solid #3b82f6; color: white; }
        .modal-btn-confirm:hover { background: #2563eb; border-color: #2563eb; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }

        #settings-panel { background: linear-gradient(135deg, #0d1117 0%, #0f1419 100%); }
        .settings-section { border-bottom: 1px solid rgba(26, 31, 46, 0.5); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section:last-child { border-bottom: none; }
        .section-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 16px 20px; cursor: pointer; transition: all 0.2s ease;
            background: transparent; position: relative; overflow: hidden;
        }
        .section-header::before {
            content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
            background: #3b82f6; transform: scaleY(0); transition: transform 0.3s ease;
        }
        .section-header:hover { background: rgba(59, 130, 246, 0.05); }
        .section-header:hover::before { transform: scaleY(1); }
        .section-title-wrapper { display: flex; align-items: center; gap: 12px; }
        .section-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: #3b82f6; opacity: 0.8; transition: all 0.3s ease; }
        .section-header:hover .section-icon { opacity: 1; transform: scale(1.1); }
        .section-title { font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600; color: #e8eaed; text-transform: uppercase; letter-spacing: 0.05em; }
        .section-chevron { width: 16px; height: 16px; color: #5a6178; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section.expanded .section-chevron { transform: rotate(180deg); color: #3b82f6; }
        .section-content { max-height: 0; overflow: hidden; transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section.expanded .section-content { max-height: 2000px; }
        .section-body { padding: 0 20px 20px 20px; display: grid; gap: 16px; }
        .setting-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .setting-item { display: flex; flex-direction: column; gap: 6px; }
        .setting-item.full-width { grid-column: 1 / -1; }
        .setting-label { font-size: 11px; font-weight: 500; color: #a6afd3; text-transform: uppercase; letter-spacing: 0.05em; font-family: 'JetBrains Mono', monospace; }
        .setting-description { font-size: 10px; color: #5a6178; margin-top: -2px; font-family: 'Inter', sans-serif; }
        .slider-container { display: flex; flex-direction: column; gap: 8px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; }
        .slider-value { font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 600; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 2px 8px; border-radius: 3px; min-width: 50px; text-align: center; }
        .setting-divider { height: 1px; background: linear-gradient(90deg, transparent 0%, rgba(26, 31, 46, 0.5) 50%, transparent 100%); margin: 8px 0; }
        .font-preview { padding: 8px 12px; background: rgba(10, 14, 26, 0.5); border: 1px solid #1a1f2e; border-radius: 4px; font-size: 12px; color: #8b92a7; text-align: center; transition: all 0.2s; }
        .font-preview:hover { border-color: #3b82f6; color: #e8eaed; }
        .toggle-switch {
            position: relative; width: 44px; height: 24px;
            background: #1a1f2e; border-radius: 12px; cursor: pointer;
            transition: all 0.3s ease; border: 1px solid #1a1f2e;
        }
        .toggle-switch.active { background: #3b82f6; border-color: #3b82f6; }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 18px; height: 18px; background: white; border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .toggle-switch.active::after { transform: translateX(20px); }
        .reset-button {
            padding: 8px 16px; background: rgba(255, 66, 66, 0.1); border: 1px solid rgba(255, 66, 66, 0.3);
            color: #ff4242; border-radius: 4px; font-family: 'JetBrains Mono', monospace;
            font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.05em;
        }
        .reset-button:hover { background: rgba(255, 66, 66, 0.2); border-color: #ff4242; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(255, 66, 66, 0.2); }
        .tpo-legend { display: inline-flex; align-items: center; gap: 5px; font-family: 'JetBrains Mono', monospace; font-size: 10px; padding: 3px 8px; border-radius: 3px; border: 1px solid rgba(255,255,255,0.08); }
        .tpo-swatch { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }
    </style>
</head>
<body class="font-sans text-trade-text antialiased h-screen flex flex-col">
    <header class="h-[48px] bg-trade-panel/90 backdrop-blur-md border-b border-trade-border flex items-center justify-between px-4 shrink-0 z-50 relative">
        <div class="flex items-center gap-6 font-mono">
            <div class="flex items-center gap-2.5">
                <div class="relative flex h-2 w-2">
                  <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                  <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                </div>
                <div class="flex flex-col leading-none">
                    <span class="text-white font-bold tracking-wider text-sm">BTCUSD</span>
                    <span class="text-[10px] text-gray-500 font-sans">Perpetual</span>
                </div>
                <div class="flex gap-1 ml-2">
                    <button class="timeframe-btn" data-tf="1">1m</button>
                    <button class="timeframe-btn" data-tf="3">3m</button>
                    <button class="timeframe-btn active" data-tf="5">5m</button>
                    <button class="timeframe-btn" data-tf="15">15m</button>
                    <button class="timeframe-btn" data-tf="30">30m</button>
                    <button class="timeframe-btn" data-tf="60">1h</button>
                    <button class="timeframe-btn" data-tf="240">4h</button>
                    <button class="timeframe-btn" data-tf="D">1D</button>
                    <button class="timeframe-btn-plus" id="custom-tf-btn">+</button>
                </div>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-baseline gap-1.5">
                <span id="price" class="text-[#f0b90b] text-lg font-bold tracking-tight">0.00</span>
                <span class="text-[10px] text-gray-500">USD</span>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-center gap-4">
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Tick Size</span>
                    <span id="tick-display" class="text-xs font-medium text-gray-300">5</span>
                </div>
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Open Interest</span>
                    <span id="oi-display" class="text-xs text-blue-400 font-medium font-mono">Loading...</span>
                </div>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
                <span class="text-[10px] text-gray-500 uppercase tracking-wider">Indicators:</span>
                <button id="toggle-oi" class="indicator-toggle active">
                    <div class="indicator-checkbox"><svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg></div>
                    <span>OI</span>
                </button>
                <button id="toggle-cvd" class="indicator-toggle">
                    <div class="indicator-checkbox"><svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg></div>
                    <span>CVD</span>
                </button>
                <button id="toggle-barstats" class="indicator-toggle">
                    <div class="indicator-checkbox"><svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg></div>
                    <span>Bar Stats</span>
                </button>
                <button id="toggle-tpo" class="indicator-toggle">
                    <div class="indicator-checkbox"><svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg></div>
                    <span>TPO</span>
                </button>
                <button id="toggle-vwap" class="indicator-toggle">
                    <div class="indicator-checkbox"><svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg></div>
                    <span>VWAP</span>
                </button>
                <button id="toggle-dailylevels" class="indicator-toggle">
                    <div class="indicator-checkbox"><svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg></div>
                    <span>Levels</span>
                </button>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="relative" id="layouts-wrapper">
                <button id="layouts-btn" class="px-3 py-1.5 text-[11px] font-mono font-semibold bg-transparent border border-trade-border hover:border-blue-500 text-gray-400 hover:text-blue-400 rounded-md transition-all active:scale-95" title="Manage layouts">Layouts</button>
                <div id="layouts-dropdown" class="hidden absolute right-0 top-[calc(100%+6px)] w-56 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] backdrop-blur-sm origin-top scale-y-95 opacity-0 transition-all duration-200">
                    <div class="px-4 py-2 text-[11px] font-mono font-semibold text-gray-400 uppercase tracking-wider">Layouts</div>
                    <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex items-center gap-2 text-gray-300 transition-colors" id="save-layout-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                        <span class="font-medium text-[11px]">Save Current Layout</span>
                    </div>
                    <div class="h-px bg-trade-border mx-2 my-1"></div>
                    <div id="saved-layouts-list" class="max-h-48 overflow-y-auto custom-scroll">
                        <div class="px-4 py-2 text-[10px] text-gray-600 font-mono italic">No saved layouts yet</div>
                    </div>
                </div>
            </div>
            <button id="add-chart-btn" class="px-3 py-1.5 text-[11px] font-mono font-semibold bg-transparent border border-trade-border hover:border-blue-500 text-gray-400 hover:text-blue-400 rounded-md transition-all active:scale-95" title="Add chart panel">+ Chart</button>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <button id="header-settings-btn" class="p-2 hover:bg-[#1a1f2e] rounded-md text-gray-400 hover:text-white transition-all active:scale-95 group">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:rotate-45 transition-transform duration-300"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
            </button>
        </div>
    </header>

    <div id="charts-container"></div>
    <div id="indicator-ctx-menu"
         style="display:none;position:fixed;z-index:10000;width:252px;
                background:linear-gradient(135deg,#0d1117 0%,#0f1419 100%);
                border:1px solid #1a1f2e;border-radius:10px;
                box-shadow:0 12px 40px rgba(0,0,0,0.65);overflow:hidden;
                font-family:'JetBrains Mono',monospace;">
        <div style="display:flex;align-items:center;justify-content:space-between;
                    padding:9px 14px 9px 14px;border-bottom:1px solid #1a1f2e;
                    background:linear-gradient(90deg,rgba(59,130,246,0.09) 0%,transparent 100%);">
            <span id="ind-ctx-title"
                  style="font-size:11px;font-weight:600;color:#e8eaed;
                         text-transform:uppercase;letter-spacing:0.06em;"></span>
            <button id="ind-ctx-close"
                    style="background:none;border:none;color:#5a6178;cursor:pointer;
                           font-size:13px;padding:1px 4px;border-radius:3px;line-height:1;
                           transition:color 0.15s;"
                    onmouseover="this.style.color='#ff4242'"
                    onmouseout="this.style.color='#5a6178'">âœ•</button>
        </div>
        <div id="ind-ctx-body" style="padding:10px 14px;display:grid;gap:8px;"></div>
    </div>

    <div id="custom-tf-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title">Custom Timeframe</h2>
            <p class="modal-description">
                Enter a timeframe: Numbers for minutes (e.g., "15", "45")<br>
                Add suffix for periods: "d" = days, "w" = weeks, "M" = months
            </p>
            <input type="text" id="custom-tf-input" class="modal-input" placeholder="e.g., 15, 1h, 1d, 1w" autocomplete="off">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="custom-tf-cancel">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="custom-tf-confirm">Apply</button>
            </div>
        </div>
    </div>

    <div id="settings-panel" class="absolute top-[49px] left-0 bottom-0 w-96 backdrop-blur-xl border-r border-trade-border z-[1000] transform -translate-x-full transition-transform duration-300 ease-out shadow-2xl flex flex-col">
        <div class="flex items-center justify-between p-5 border-b border-trade-border/50 bg-gradient-to-r from-blue-600/10 to-transparent">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 rounded-lg bg-blue-600/20 flex items-center justify-content-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                </div>
                <h2 class="text-white font-semibold text-base">Chart Settings</h2>
            </div>
            <button id="close-settings" class="text-gray-500 hover:text-white transition p-2 rounded-lg hover:bg-white/10 active:scale-95">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto custom-scroll">
            
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg></div>
                        <span class="section-title">Chart Appearance</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Chart Type</label>
                                <div class="select-wrapper">
                                    <select id="series-type-select" class="w-full px-3 py-2">
                                        <option value="candle" selected>Candles</option>
                                        <option value="bar">Bars</option>
                                    </select>
                                </div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bar Spacing</label>
                                <input type="number" id="bar-spacing-input" value="50" min="10" max="200" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Candle Opacity</label>
                                    <span id="opacity-val" class="slider-value">100%</span>
                                </div>
                                <input type="range" id="candle-opacity" min="0" max="100" value="100" step="5">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Candle Width %</label>
                                <input type="number" id="candle-width-input" value="20" min="5" max="80" step="5" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Cluster Width %</label>
                                <input type="number" id="cluster-width-input" value="80" min="20" max="95" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Wick Thickness</label>
                                    <span id="wick-thickness-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="wick-thickness" min="1" max="5" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Border Thickness</label>
                                    <span id="border-thickness-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="border-thickness" min="0" max="5" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Price Scale Font</label>
                                <input type="number" id="price-scale-font-input" value="10" min="8" max="16" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r=".5"></circle><circle cx="17.5" cy="10.5" r=".5"></circle><circle cx="8.5" cy="7.5" r=".5"></circle><circle cx="6.5" cy="12.5" r=".5"></circle><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path></svg></div>
                        <span class="section-title">Colors & Theme</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Bullish Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="up-candle-color" value="#608feb"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bearish Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="down-candle-color" value="#ff4242"></div>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Grid Lines</label>
                            <div class="color-picker-wrapper"><input type="color" id="grid-color-input" value="#636363"></div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">POC Highlight</label>
                            <div class="color-picker-wrapper"><input type="color" id="poc-color-input" value="#f0b90b"></div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Background</label>
                                <div class="color-picker-wrapper"><input type="color" id="bg-color-input" value="#0a0e1a"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Panel Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="panel-color-input" value="#0f1419"></div>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Accent Color</label>
                            <div class="color-picker-wrapper"><input type="color" id="accent-color-input" value="#3b82f6"></div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Absorption Dot Color</label>
                            <div class="color-picker-wrapper"><input type="color" id="absorption-color-input" value="#FFD700"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg></div>
                        <span class="section-title">Typography</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Stats Font Family</label>
                            <div class="select-wrapper">
                                <select id="stats-font-family" class="w-full px-3 py-2">
                                    <option value="'JetBrains Mono', monospace" selected>JetBrains Mono</option>
                                    <option value="'IBM Plex Mono', monospace">IBM Plex Mono</option>
                                    <option value="'Fira Code', monospace">Fira Code</option>
                                    <option value="monospace">System Mono</option>
                                </select>
                            </div>
                            <div class="font-preview" id="stats-font-preview" style="font-family: 'JetBrains Mono', monospace;">V:1.2M D:+250K</div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Stats Font Size</label>
                                    <span id="stats-font-size-val" class="slider-value">Auto</span>
                                </div>
                                <input type="range" id="stats-font-size" min="7" max="16" value="9" step="1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Stats Font Weight</label>
                            <div class="select-wrapper">
                                <select id="stats-font-weight" class="w-full px-3 py-2">
                                    <option value="400" selected>Regular (400)</option>
                                    <option value="500">Medium (500)</option>
                                    <option value="600">Semi-Bold (600)</option>
                                    <option value="700">Bold (700)</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cell Font Size</label>
                                    <span id="cell-font-size-val" class="slider-value">11px</span>
                                </div>
                                <input type="range" id="cell-font-size" min="8" max="16" value="9" step="1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Cell Font Weight</label>
                            <div class="select-wrapper">
                                <select id="cell-font-weight" class="w-full px-3 py-2">
                                    <option value="400" selected>Regular (400)</option>
                                    <option value="500">Medium (500)</option>
                                    <option value="600">Semi-Bold (600)</option>
                                    <option value="700">Bold (700)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg></div>
                        <span class="section-title">Grid & Scale</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Grid Spacing ($)</label>
                            <input type="number" id="grid-spacing-input" value="1000" step="100" min="100" max="10000" class="w-full px-3 py-2">
                            <span class="setting-description">Price interval between horizontal grid lines</span>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Grid Opacity</label>
                                    <span id="grid-opacity-val" class="slider-value">100%</span>
                                </div>
                                <input type="range" id="grid-opacity" min="0" max="100" value="100" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Grid Line Width</label>
                                    <span id="grid-line-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="grid-line-width" min="0.5" max="3" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Base Tick Size</label>
                            <input type="number" id="base-tick-input" value="2.5" step="0.5" min="0.5" max="50" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum price level grouping</span>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Min Cell Height (px)</label>
                            <input type="number" id="min-cell-height-input" value="15" step="1" min="8" max="40" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum height before auto-scaling kicks in</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg></div>
                        <span class="section-title">Footprint Clusters</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Calculation Mode</label>
                            <div class="select-wrapper">
                                <select id="cumulative-mode-select" class="w-full px-3 py-2">
                                    <option value="all" selected>All Candles</option>
                                    <option value="visible">Visible Candles Only</option>
                                </select>
                            </div>
                            <span class="setting-description">Cumulative cluster aggregation range</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Low-Volume Cell Threshold (USD)</label>
                            <input type="number" id="cluster-volume-threshold" value="25000" min="0" step="10000" class="w-full px-3 py-2">
                            <span class="setting-description">Cells below this total volume are shown in muted gray. Set to 0 to disable.</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cluster BG Opacity</label>
                                    <span id="cluster-bg-opacity-val" class="slider-value">0%</span>
                                </div>
                                <input type="range" id="cluster-bg-opacity" min="0" max="100" value="0" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">POC Border Width</label>
                                    <span id="poc-border-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="poc-border-width" min="1" max="5" value="1.5" step="0.5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cell Border Width</label>
                                    <span id="cell-border-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="cell-border-width" min="0" max="3" value="1" step="0.5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg></div>
                        <span class="section-title">Volume Analysis</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Min Delta for Bubbles (USD)</label>
                            <input type="number" id="bubble-threshold-input" value="500000" step="100000" min="0" max="10000000" class="w-full px-3 py-2">
                            <span class="setting-description">Show pulsing indicator when delta exceeds this threshold</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Bubble Inner Size</label>
                                <input type="number" id="bubble-inner-size" value="5" min="2" max="15" step="1" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bubble Outer Size</label>
                                <input type="number" id="bubble-outer-size" value="10" min="5" max="25" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Bubble Pulse Speed</label>
                                    <span id="bubble-pulse-speed-val" class="slider-value">1.5s</span>
                                </div>
                                <input type="range" id="bubble-pulse-speed" min="500" max="3000" value="1500" step="100">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Absorption Dot Size</label>
                                <input type="number" id="absorption-dot-size" value="4" min="2" max="12" step="1" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Absorption Glow</label>
                                <input type="number" id="absorption-glow" value="10" min="0" max="30" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Absorption Threshold (USD)</label>
                            <input type="number" id="absorption-threshold" value="1000000" step="10000" min="0" max="10000000" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum delta for absorption detection</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m0 0"></path><circle cx="12" cy="12" r="10"></circle></svg></div>
                        <span class="section-title">UI Elements</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Price Line</label>
                                <div class="toggle-switch active" id="toggle-price-line-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Price Label</label>
                                <div class="toggle-switch active" id="toggle-price-label-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Countdown Timer</label>
                                <div class="toggle-switch active" id="toggle-countdown-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Crosshair</label>
                                <div class="toggle-switch active" id="toggle-crosshair-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Price Label Font Size</label>
                            <input type="number" id="price-label-font-size" value="9" min="5" max="20" step="1" class="w-full px-3 py-2">
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Timer Font Size</label>
                            <input type="number" id="timer-font-size" value="8" min="5" max="20" step="1" class="w-full px-3 py-2">
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Timer Opacity</label>
                                    <span id="timer-opacity-val" class="slider-value">90%</span>
                                </div>
                                <input type="range" id="timer-opacity" min="0" max="100" value="90" step="5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg></div>
                        <span class="section-title">Indicators</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Default Indicator Height</label>
                            <input type="number" id="default-indicator-height" value="150" min="50" max="500" step="10" class="w-full px-3 py-2">
                            <span class="setting-description">Initial height for new indicators (px)</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">OI Candle Width</label>
                                    <span id="oi-candle-width-val" class="slider-value">50%</span>
                                </div>
                                <input type="range" id="oi-candle-width" min="20" max="100" value="50" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">CVD Line Thickness</label>
                                    <span id="cvd-line-thickness-val" class="slider-value">2px</span>
                                </div>
                                <input type="range" id="cvd-line-thickness" min="1" max="5" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Indicator Padding</label>
                                <input type="number" id="indicator-padding" value="10" min="0" max="30" step="2" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Indicator BG Opacity</label>
                                <input type="number" id="indicator-bg-opacity" value="95" min="0" max="100" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg></div>
                        <span class="section-title">Advanced</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Draw Frame Delay</label>
                                    <span id="draw-delay-val" class="slider-value">50ms</span>
                                </div>
                                <input type="range" id="draw-delay" min="50" max="500" value="50" step="50">
                            </div>
                            <span class="setting-description">Lower = more responsive, higher = better performance</span>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Interaction Hold Time</label>
                                    <span id="interaction-hold-val" class="slider-value">180ms</span>
                                </div>
                                <input type="range" id="interaction-hold" min="50" max="500" value="180" step="10">
                            </div>
                            <span class="setting-description">Duration to keep drawing after user interaction</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item full-width">
                            <button class="reset-button w-full" onclick="resetToDefaults()">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 6px;"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
                                Reset All Settings to Defaults
                            </button>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="ctx-menu-main" class="hidden absolute w-52 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] text-sm backdrop-blur-sm">
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-reset">
            <span class="font-medium">Reset View</span><span class="text-gray-500 text-xs group-hover:text-blue-400">R</span>
        </div>
        <div class="h-px bg-trade-border mx-2 my-1"></div>
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-hide-footprints">
            <span class="font-medium">Hide Footprints</span>
            <span id="ctx-hide-footprints-indicator" class="text-[10px] text-gray-500 group-hover:text-blue-400">â—‹</span>
        </div>
        <div class="h-px bg-trade-border mx-2 my-1"></div>
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-settings-trigger">
            <span class="font-medium">Settings</span><span class="text-gray-500 text-[10px] group-hover:text-blue-400">â–¶</span>
        </div>
    </div>

<script>
    const HEADER_HEIGHT = 48;
    const TIME_AXIS_HEIGHT = 28;
    const MIN_PANE_HEIGHT = 50;
    const BASE_TIMEFRAME = 5;

    let config = {
        gridSpacing: 1000, gridColor: '#636363', gridOpacity: 1.0, gridLineWidth: 1,
        baseTickSize: 2.5, minCellHeight: 15, upColor: '#608feb', downColor: '#ff4242',
        candleOpacity: 1.0, seriesType: 'candle', minBubbleVolume: 500000,
        showPriceLine: true, showPriceLabel: true, showCountdown: true, showCrosshair: true,
        pocColor: '#f0b90b', currentTimeframe: 5, displayTimeframe: 5,
        candleWidthPercent: 0.20, clusterWidthPercent: 0.80, cumulativeMode: 'all',
        wickThickness: 1, borderThickness: 1, bgColor: '#0a0e1a', panelColor: '#0f1419',
        accentColor: '#3b82f6', absorptionColor: '#FFD700',
        statsFontFamily: "'JetBrains Mono', monospace", statsFontSize: 9,
        statsFontWeight: '400', cellFontSize: 9, cellFontWeight: '400', barSpacing: 50,
        clusterBgOpacity: 0, pocBorderWidth: 1.5, cellBorderWidth: 1,
        bubbleInnerSize: 5, bubbleOuterSize: 10, bubblePulseSpeed: 1500,
        absorptionDotSize: 4, absorptionGlow: 10, absorptionThreshold: 1000000,
        priceLabelFontSize: 9, timerFontSize: 8, timerOpacity: 0.9,
        defaultIndicatorHeight: 150, oiCandleWidth: 0.5, cvdLineThickness: 1,
        indicatorPadding: 10, indicatorBgOpacity: 0.95, drawDelay: 100, interactionHold: 180,
        clusterVolumeThreshold: 25000, showDailyLevels: false, hideFootprints: false ,priceScaleWidth: 44,
        priceScaleFontSize: 10,
        //vwap
        vwapVisible: false,
        // â”€â”€ TPO / Market Profile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        showTPO: false,
        tpoTickSize: 50,
        tpoBlockWidth: 8,
        tpoOpacityVA: 0.65,
        tpoOpacityNonVA: 0.70,
        tpoColorSingle: '#ff6ec7',
        tpoColorVA: '#3b82f6',
        tpoColorNonVA: '#ffffff',
        tpoColorPOC: '#ffffff',
        // OI
        oiUpColor: '#608feb',
        oiDownColor: '#ff4242',
        oiOpacity: 1.0,
        oiBorderColor: '#ffffff',
        // CVD
        cvdLineColor: 'auto',   
        // Bar Stats
        barStatsUpColor: '#608feb',
        barStatsDownColor: '#ff4242',
        // VWAP
        vwapColor: '#ffffff',
        vwapLineStyle: 'solid',  
        vwapShowLabel: false,
        vwapShowPrice: false,
        // Key Levels
        levelsColor: '#ff8c00',
        levelsLineStyle: 'dashed',  
        levelsEnabled: { dOpen: true, dHigh: true, dLow: true, dEQ: true, pdHigh: true, pdLow: true, pdEQ: true },
    };

    let base5mClusters = {};
    let base5mCandles = [];
    let displayCandles = [];
    let displayClusters = {};
    let lastBarTime = 0;
    let currentPrice = 0;
    let mainSeries;
    let ws = null;
    let measuredPriceScaleWidth = 54;

    // â”€â”€ TPO Cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let tpoProfilesCache = null;
    let tpoCacheKey = '';

    // â”€â”€ Active-panel context globals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let activePriceLabelEl = null;   
    let activeTimerBox     = null;   
    let activeWrapperEl    = null;   

    // â”€â”€ Golden Layout Globals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let myLayout = null;
    const extraPanels = [];
    let extraPanelCounter = 0;
    let selectedPanelId = 0; // 0 = main panel, >0 = extra panel ID
    // â”€â”€ Global Context Pointers (Fixed Duplicates) â”€â”€
    let chart = null, chartOverlayCanvas = null, ctxOverlay = null;
    let offscreenCanvas = null, offscreenCtx = null;
    let indicatorManager = null;
    // â”€â”€ Indicator Settings Keys (Must be defined before panels) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const IND_SETTING_KEYS = [
        'oiUpColor','oiDownColor','oiOpacity','oiBorderColor',
        'cvdLineColor','cvdLineThickness',
        'barStatsUpColor','barStatsDownColor',
        'tpoTickSize','tpoBlockWidth','tpoOpacityVA','tpoOpacityNonVA',
        'tpoColorSingle','tpoColorVA','tpoColorNonVA','tpoColorPOC',
        'vwapColor','vwapLineStyle','vwapShowLabel','vwapShowPrice',
        'levelsColor','levelsLineStyle',
    ];

    function makeDefaultIndSettings() {
        const s = {};
        IND_SETTING_KEYS.forEach(k => { s[k] = config[k]; });
        s.levelsEnabled = { ...config.levelsEnabled };
        return s;
    }

    // â”€â”€ Context Switching for Canvas Overlays â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function _saveP0() {
        const indSettings = {};
        IND_SETTING_KEYS.forEach(k => { indSettings[k] = config[k]; });
        indSettings.levelsEnabled = { ...config.levelsEnabled };
        return { chart, mainSeries, chartOverlayCanvas, ctxOverlay,
                 offscreenCanvas, offscreenCtx, displayCandles, displayClusters,
                 tpoProfilesCache, tpoCacheKey,
                 vwapData, vwapCacheKey,          // â† ADDED
                 indicatorManager: indicatorManager,
                 activePriceLabelEl, activeTimerBox, activeWrapperEl,
                 showTPO: config.showTPO, vwapVisible: config.vwapVisible,
                 showDailyLevels: config.showDailyLevels, hideFootprints: config.hideFootprints,
                 indSettings };
    }

    function _restoreP0(s) {
        chart = s.chart; mainSeries = s.mainSeries;
        chartOverlayCanvas = s.chartOverlayCanvas; ctxOverlay = s.ctxOverlay;
        offscreenCanvas = s.offscreenCanvas; offscreenCtx = s.offscreenCtx;
        displayCandles = s.displayCandles; displayClusters = s.displayClusters;
        tpoProfilesCache = s.tpoProfilesCache; tpoCacheKey = s.tpoCacheKey;
        vwapData = s.vwapData; vwapCacheKey = s.vwapCacheKey; // â† ADDED
        indicatorManager = s.indicatorManager;
        activePriceLabelEl = s.activePriceLabelEl;
        activeTimerBox = s.activeTimerBox;
        activeWrapperEl = s.activeWrapperEl;
        config.showTPO = s.showTPO;
        config.vwapVisible = s.vwapVisible;
        config.showDailyLevels = s.showDailyLevels;
        config.hideFootprints = s.hideFootprints;
        if (s.indSettings) {
            IND_SETTING_KEYS.forEach(k => { config[k] = s.indSettings[k]; });
            config.levelsEnabled = { ...s.indSettings.levelsEnabled };
        }
    }

    function _activatePanel(panel) {
        chart = panel.chart; mainSeries = panel.mainSeries;
        chartOverlayCanvas = panel.overlayCanvas; ctxOverlay = panel.ctxOverlay;
        offscreenCanvas = panel.offscreenCanvas; offscreenCtx = panel.offscreenCtx;
        displayCandles = panel.displayCandles; displayClusters = panel.displayClusters;
        tpoProfilesCache = panel.tpoProfilesCache; tpoCacheKey = panel.tpoCacheKey;
        indicatorManager = panel.indicatorManager;
        activePriceLabelEl = panel.priceLabelEl;
        activeTimerBox = panel.timerBoxEl;
        activeWrapperEl = panel.wrapperEl;
        config.showTPO = panel.showTPO;
        config.vwapVisible = panel.vwapVisible;
        config.showDailyLevels = panel.showDailyLevels;
        config.hideFootprints = panel.hideFootprints;
        IND_SETTING_KEYS.forEach(k => { if (panel[k] !== undefined) config[k] = panel[k]; });
        if (panel.levelsEnabled) config.levelsEnabled = { ...panel.levelsEnabled };
    }

    function _deactivatePanel(panel) {
        panel.tpoProfilesCache = tpoProfilesCache;
        panel.tpoCacheKey = tpoCacheKey;
        panel.showTPO = config.showTPO;
        panel.vwapVisible = config.vwapVisible;
        panel.showDailyLevels = config.showDailyLevels;
        panel.hideFootprints = config.hideFootprints;
        IND_SETTING_KEYS.forEach(k => { panel[k] = config[k]; });
        panel.levelsEnabled = { ...config.levelsEnabled };
    }

    // â”€â”€ Buffer & Animation Handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function schedulePanelDraw(panel) {
        panel.needsRedraw = true;
        panel.lastInteractionTime = Date.now();
        if (!panel.rafRunning) {
            panel.rafRunning = true;
            const loop = () => {
                const saved = _saveP0();
                _activatePanel(panel);
                const now = Date.now();
                if (now - panel.lastInteractionTime < config.interactionHold) {
                    drawFrames(); _deactivatePanel(panel);
                    _restoreP0(saved);
                    panel.rafId = requestAnimationFrame(loop);
                } else {
                    if (panel.needsRedraw) {
                        panel.needsRedraw = false;
                        drawFrames(); _deactivatePanel(panel);
                        _restoreP0(saved);
                        panel.rafId = requestAnimationFrame(loop);
                    } else {
                        _restoreP0(saved);
                        panel.rafRunning = false;
                        panel.rafId = null;
                    }
                }
            };
            panel.rafId = requestAnimationFrame(loop);
        }
    }

    function setupPanelBuffers(panel) {
        const dpr = window.devicePixelRatio || 1;
        const w = panel.wrapperEl.clientWidth;
        const h = panel.wrapperEl.clientHeight;
        panel.overlayCanvas.width  = Math.floor(w * dpr);
        panel.overlayCanvas.height = Math.floor(h * dpr);
        panel.overlayCanvas.style.width  = w + 'px';
        panel.overlayCanvas.style.height = h + 'px';
        panel.offscreenCanvas.width  = panel.overlayCanvas.width;
        panel.offscreenCanvas.height = panel.overlayCanvas.height;
        panel.offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        panel.ctxOverlay.setTransform(1, 0, 0, 1, 0, 0);
        panel.chart.applyOptions({ width: w, height: h });
    }

    // â”€â”€ Golden Layout Initialization & Component Registration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // â”€â”€ Golden Layout Initialization & Component Registration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function initGoldenLayout() {
        const glConfig = {
            root: {
                type: 'row',
                content: [{
                    type: 'component',
                    componentType: 'chartComponent',
                    componentState: { isMain: true },
                    title: 'BTCUSD Main'
                }]
            },
            settings: { showPopoutIcon: false }
        };

        // FIX: Pass the config directly into the constructor for the first boot!
        myLayout = new window.goldenLayout.GoldenLayout(glConfig, document.getElementById('charts-container'));

        myLayout.registerComponentFactoryFunction('chartComponent', function(container, itemConfig) {
            // FIX: Safely extract state in GL v2
            const state = itemConfig.componentState || itemConfig || {};
            const isMain = state.isMain === true;
            const pid = isMain ? 0 : ++extraPanelCounter;

            const wrapperEl = document.createElement('div');
            wrapperEl.className = 'chart-panel-wrapper';
            wrapperEl.id = `panel-wrapper-${pid}`;
            if (isMain) wrapperEl.classList.add('selected');

            const chartContEl = document.createElement('div');
            chartContEl.style.cssText = 'width:100%;height:100%;';

            const overlayEl = document.createElement('canvas');
            overlayEl.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:20;';

            const priceLabelEl = document.createElement('div');
            priceLabelEl.style.cssText = 'position:absolute;right:0;z-index:40;pointer-events:none;display:flex;align-items:center;gap:1px;';

            const timerEl = document.createElement('div');
            timerEl.className = 'hidden absolute bg-black/90 border border-trade-border/50 backdrop-blur text-white px-1 py-1 font-mono text-[11px] font-semibold z-[60] tabular-nums flex items-center gap-1.5 pointer-events-none shadow-lg rounded';
            timerEl.style.cssText = 'min-width:60px;right:10px;top:50%;transform:translateY(-50%);';

            const indicatorsContainer = document.createElement('div');
            indicatorsContainer.id = `indicators-container-${pid}`;
            indicatorsContainer.style.cssText = 'position:absolute;left:0;right:0;bottom:0;pointer-events:none;';

            wrapperEl.append(chartContEl, overlayEl, priceLabelEl, timerEl, indicatorsContainer);

            if (!isMain) {
                const tfBar = document.createElement('div');
                tfBar.className = 'panel-tf-bar';
                [5, 15, 30, 60, 240, 1440].forEach(tf => {
                    const btn = document.createElement('button');
                    btn.className = 'timeframe-btn' + (tf === 5 ? ' active' : '');
                    btn.style.cssText = 'padding:2px 7px;font-size:10px;';
                    btn.textContent = {5:'5m', 15:'15m', 30:'30m', 60:'1h', 240:'4h', 1440:'1D'}[tf];
                    btn.onclick = () => {
                        tfBar.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        panel.displayTimeframe = tf;
                        panel.displayCandles = aggregateCandles(base5mCandles, tf);
                        panel.displayClusters = aggregateClusters(base5mClusters, tf);
                        panel.mainSeries.setData(panel.displayCandles);
                        panel.tpoCacheKey = '';
                        setTimeout(() => { panel.chart.timeScale().fitContent(); schedulePanelDraw(panel); }, 80);
                    };
                    tfBar.appendChild(btn);
                });
                wrapperEl.appendChild(tfBar);
            }

            container.element.appendChild(wrapperEl);

            wrapperEl.addEventListener('mousedown', () => {
                selectedPanelId = pid;
                document.querySelectorAll('.chart-panel-wrapper').forEach(w => w.classList.remove('selected'));
                wrapperEl.classList.add('selected');
                syncHeaderButtons();
            });

            wrapperEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                selectedPanelId = pid;
                document.querySelectorAll('.chart-panel-wrapper').forEach(w => w.classList.remove('selected'));
                wrapperEl.classList.add('selected');
                syncHeaderButtons();
                const ctxMenuMain = document.getElementById('ctx-menu-main');
                ctxMenuMain.style.left = `${Math.min(e.clientX, window.innerWidth - 200)}px`;
                ctxMenuMain.style.top  = `${Math.min(e.clientY, window.innerHeight - 100)}px`;
                ctxMenuMain.classList.remove('hidden');
            });

            const newChart = LightweightCharts.createChart(chartContEl, {
                localization: { timeFormatter: (timestamp) => new Date(timestamp * 1000).toLocaleString('ro-RO', { timeZone: 'Europe/Bucharest', hour: '2-digit', minute: '2-digit' }) },
                layout: { background: { color: config.bgColor }, textColor: '#8b92a7', fontFamily: 'Inter', fontSize: config.priceScaleFontSize },
                grid: { vertLines: { visible: false }, horzLines: { visible: false } },
                rightPriceScale: { borderColor: '#1a1f2e', scaleMargins: { top: 0.05, bottom: 0.20 } },
                crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
                timeScale: { borderColor: '#1a1f2e', timeVisible: true, barSpacing: config.barSpacing, rightOffset: 5 }
            });

            const newSeries = newChart.addCandlestickSeries({
                upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', borderVisible:false,
                wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)',
                priceLineVisible: config.showPriceLine, priceLineColor: config.upColor, priceLineWidth: 1, priceLineStyle: 2, lastValueVisible:false
            });

            const offscreenC = document.createElement('canvas');

            if (isMain) {
                chart = newChart;
                mainSeries = newSeries;
                chartOverlayCanvas = overlayEl;
                ctxOverlay = overlayEl.getContext('2d');
                offscreenCanvas = offscreenC;
                offscreenCtx = offscreenC.getContext('2d');
                activePriceLabelEl = priceLabelEl;
                activeTimerBox = timerEl;
                activeWrapperEl = wrapperEl;
                
                // Initialize main indicator manager safely
                if (typeof IndicatorManager !== 'undefined') {
                    indicatorManager = new IndicatorManager();
                    indicatorManager.chart = chart;
                    indicatorManager.wrapper = wrapperEl;
                    indicatorManager.container = indicatorsContainer;
                    indicatorManager.onLayout = () => scheduleDraw();
                }
            }

            const panelIndicatorManager = isMain ? indicatorManager : new IndicatorManager();
            if (!isMain) {
                panelIndicatorManager.container = indicatorsContainer;
                panelIndicatorManager.chart = newChart;
                panelIndicatorManager.wrapper = wrapperEl;
            }

            const panel = isMain ? null : {
                id: pid, indicatorManager: panelIndicatorManager, wrapperEl, chart: newChart, mainSeries: newSeries,
                overlayCanvas: overlayEl, ctxOverlay: overlayEl.getContext('2d'), offscreenCanvas: offscreenC, offscreenCtx: offscreenC.getContext('2d'),
                priceLabelEl, timerBoxEl: timerEl, displayTimeframe: 5, displayCandles: displayCandles.slice(), displayClusters: structuredClone(displayClusters),
                tpoProfilesCache: null, tpoCacheKey: '', rafRunning: false, needsRedraw: false, lastInteractionTime: 0, rafId: null,
                showTPO: false, vwapVisible: false, showDailyLevels: false, hideFootprints: false, ...makeDefaultIndSettings(),
            };

            if (!isMain) {
                panelIndicatorManager.onLayout = () => schedulePanelDraw(panel);
                newSeries.setData(panel.displayCandles);
                extraPanels.push(panel);
                newChart.timeScale().subscribeVisibleLogicalRangeChange(() => schedulePanelDraw(panel));
            }

// 5. Native Resize Handling (Protects Canvas Math)
            const ro = new ResizeObserver((entries) => {
                for (const entry of entries) {
                    const w = Math.floor(entry.contentRect.width);
                    const h = Math.floor(entry.contentRect.height);
                    
                    if (w === 0 || h === 0) continue;
                    
                    if (isMain) {
                        chart.applyOptions({ width: w, height: h });
                        setupBuffersForSize();
                        if (indicatorManager) indicatorManager.updateLayout();
                        scheduleDraw();
                    } else if (panel) {
                        panel.chart.applyOptions({ width: w, height: h });
                        setupPanelBuffers(panel);
                        panel.indicatorManager.updateLayout();
                        schedulePanelDraw(panel);
                    }
                }
            });
            ro.observe(wrapperEl);

            container.on('destroy', () => {
                ro.disconnect();
                if (isMain) {
                    // Cancel the main panel's global RAF loop so it doesn't keep
                    // running after the panel is torn down on a layout reload.
                    if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
                    rafRunning = false;
                } else {
                    if (panel.rafId) cancelAnimationFrame(panel.rafId);
                    const idx = extraPanels.findIndex(p => p.id === pid);
                    if (idx > -1) extraPanels.splice(idx, 1);
                    panel.chart.remove();
                }
            });
        });
        // FIX: Just call init()! The config was already passed in the constructor above.
        myLayout.init();

        // â”€â”€ Black-screen fix â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // GL emits 'initialised' once its own layout pass is complete, so canvas
        // buffers can now be measured correctly.  Two rAF calls ensure we run
        // after both GL's paint and any pending microtasks.
        myLayout.on('initialised', () => {
            requestAnimationFrame(() => requestAnimationFrame(() => {
                if (chart && activeWrapperEl && activeWrapperEl.clientWidth > 0) {
                    chart.applyOptions({
                        width:  activeWrapperEl.clientWidth,
                        height: activeWrapperEl.clientHeight
                    });
                    setupBuffersForSize();
                    if (indicatorManager) indicatorManager.updateLayout();
                }
                extraPanels.forEach(p => {
                    if (p.wrapperEl && p.wrapperEl.clientWidth > 0) {
                        setupPanelBuffers(p);
                        p.indicatorManager.updateLayout();
                        schedulePanelDraw(p);
                    }
                });
                scheduleDraw();
            }));
        });
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        window.addEventListener('resize', () => myLayout.updateSize());
    }

    // â”€â”€ Global Draw Loop Variables â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let rafId = null, rafRunning = false, needsRedraw = false, lastInteractionTime = 0;
    let clustersDirty = false;
    // â”€â”€ Buffer / Draw Triggers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function updatePaneRight() {
        let right = 54;
        // Use the currently active Golden Layout wrapper to measure the price scale
        if (activeWrapperEl) {
            const lastTd = activeWrapperEl.querySelector('tr td:last-child');
            if (lastTd) {
                const w = Math.round(lastTd.getBoundingClientRect().width);
                if (w > 10) right = w;
            }
        }
        measuredPriceScaleWidth = right;
        
        // Update panes in the main indicator manager
        if (typeof indicatorManager !== 'undefined' && indicatorManager.wrapper) {
            indicatorManager.wrapper.querySelectorAll('.indicator-pane').forEach(el => { el.style.right = right + 'px'; });
            const ph = indicatorManager.wrapper.querySelector('.drag-placeholder');
            if (ph) ph.style.right = right + 'px';
        }
        // Update panes in extra panels
        extraPanels.forEach(p => {
            p.wrapperEl.querySelectorAll('.indicator-pane').forEach(el => { el.style.right = right + 'px'; });
            const ph = p.wrapperEl.querySelector('.drag-placeholder');
            if (ph) ph.style.right = right + 'px';
        });
    }

    function scheduleDraw() {
        needsRedraw = true;
        lastInteractionTime = Date.now();
        extraPanels.forEach(p => schedulePanelDraw(p));
        if (!rafRunning) {
            rafRunning = true;
            const loop = () => {
                const now = Date.now();
                if (now - lastInteractionTime < config.interactionHold) {
                    drawFrames(); rafId = requestAnimationFrame(loop);
                } else {
                    if (needsRedraw) { needsRedraw = false; drawFrames(); rafId = requestAnimationFrame(loop); }
                    else { rafRunning = false; rafId = null; }
                }
            };
            rafId = requestAnimationFrame(loop);
        }
    }

    // â”€â”€ Timeframe Aggregation Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function parseCustomTimeframe(input) {
        input = input.trim().toLowerCase();
        if (input.endsWith('h')) { const h = parseFloat(input.slice(0,-1)); return (isNaN(h)||h<=0)?null:h*60; }
        if (input.endsWith('d')) { const d = parseFloat(input.slice(0,-1)); return (isNaN(d)||d<=0)?null:d*1440; }
        if (input.endsWith('w')) { const w = parseFloat(input.slice(0,-1)); return (isNaN(w)||w<=0)?null:w*10080; }
        if (input.endsWith('m') && input.length > 1) {
            const char = input[input.length-2];
            if (!isNaN(char)) { const m = parseFloat(input.slice(0,-1)); return (isNaN(m)||m<=0)?null:m; }
        }
        const mins = parseFloat(input);
        return (isNaN(mins)||mins<=0) ? null : mins;
    }

    function validateTimeframe(minutes) {
        if (minutes < BASE_TIMEFRAME) { alert(`Footprint information will not migrate to timeframes lower than ${BASE_TIMEFRAME}m`); return false; }
        if (minutes % BASE_TIMEFRAME !== 0) { alert(`Please use timeframes divisible by ${BASE_TIMEFRAME}m`); return false; }
        return true;
    }

    function aggregateCandles(source5mCandles, targetTFMinutes) {
        if (targetTFMinutes === BASE_TIMEFRAME) return source5mCandles.slice();
        const aggregated = [];
        const targetBarSeconds = targetTFMinutes * 60;
        const grouped = {};
        source5mCandles.forEach(candle => {
            const alignedTime = Math.floor(candle.time / targetBarSeconds) * targetBarSeconds;
            if (!grouped[alignedTime]) grouped[alignedTime] = [];
            grouped[alignedTime].push(candle);
        });
        const alignedTimes = Object.keys(grouped).map(Number).sort((a,b)=>a-b);
        alignedTimes.forEach(alignedTime => {
            const chunk = grouped[alignedTime];
            if (chunk.length === 0) return;
            const first = chunk[0], last = chunk[chunk.length-1];
            aggregated.push({
                time: alignedTime, open: first.open,
                high: Math.max(...chunk.map(c=>c.high)), low: Math.min(...chunk.map(c=>c.low)),
                close: last.close, oiOpen: first.oiOpen,
                volume: chunk.reduce((sum, c) => sum + (c.volume || 0), 0),
                oiHigh: Math.max(...chunk.map(c=>c.oiHigh||0)),
                oiLow: Math.min(...chunk.map(c=>c.oiLow||Infinity)),
                oiClose: last.oiClose
            });
        });
        return aggregated;
    }

    function aggregateClusters(source5mClusters, targetTFMinutes) {
        if (targetTFMinutes === BASE_TIMEFRAME) {
            // Fast manual copy â€” structuredClone is O(n) and serializes to JSON internally.
            // A direct property copy is 3â€“5Ã— faster on large cluster maps.
            const copy = {};
            for (const ts in source5mClusters) {
                const src = source5mClusters[ts];
                const dst = {};
                for (const price in src) {
                    dst[price] = { buy: src[price].buy, sell: src[price].sell };
                }
                copy[ts] = dst;
            }
            return copy;
        }
        const aggregated = {};
        const targetBarSeconds = targetTFMinutes * 60;
        const timestamps = Object.keys(source5mClusters).map(Number).sort((a,b)=>a-b);
        const grouped = {};
        timestamps.forEach(ts => {
            const alignedTime = Math.floor(ts / targetBarSeconds) * targetBarSeconds;
            if (!grouped[alignedTime]) grouped[alignedTime] = [];
            grouped[alignedTime].push(ts);
        });
        Object.keys(grouped).forEach(alignedTime => {
            const timeKey = String(alignedTime);
            const tsList = grouped[alignedTime];
            let hasData = false;
            tsList.forEach(ts => { const b = source5mClusters[String(ts)]; if (b && Object.keys(b).length > 0) hasData = true; });
            if (!hasData) return;
            aggregated[timeKey] = {};
            tsList.forEach(ts => {
                const buckets = source5mClusters[String(ts)];
                if (!buckets) return;
                Object.keys(buckets).forEach(priceKey => {
                    const price = parseFloat(priceKey);
                    const data = buckets[priceKey];
                    if (data.buy === 0 && data.sell === 0) return;
                    if (!aggregated[timeKey][price]) aggregated[timeKey][price] = { buy: 0, sell: 0 };
                    aggregated[timeKey][price].buy += data.buy;
                    aggregated[timeKey][price].sell += data.sell;
                });
            });
            if (Object.keys(aggregated[timeKey]).length === 0) delete aggregated[timeKey];
        });
        return aggregated;
    }

    function applyTimeframeChange(newTFMinutes) {
        config.displayTimeframe = newTFMinutes;
        displayCandles = aggregateCandles(base5mCandles, newTFMinutes);
        displayClusters = aggregateClusters(base5mClusters, newTFMinutes);
        mainSeries.setData(displayCandles);
        tpoCacheKey = '';
        document.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
        const tfMap = { 1:1, 3:3, 5:5, 15:15, 30:30, 60:60, 240:240, 1440:'D' };
        const btnValue = tfMap[newTFMinutes];
        if (btnValue) { const btn = document.querySelector(`[data-tf="${btnValue}"]`); if (btn) btn.classList.add('active'); }
        setTimeout(() => { chart.timeScale().fitContent(); needsRedraw = true; scheduleDraw(); }, 100);
    }

    // Modal UI Bindings
    document.getElementById('custom-tf-btn').onclick = () => {
        const modal = document.getElementById('custom-tf-modal');
        modal.classList.add('active');
        document.getElementById('custom-tf-input').value = '';
        document.getElementById('custom-tf-input').focus();
    };
    document.getElementById('custom-tf-cancel').onclick = () => document.getElementById('custom-tf-modal').classList.remove('active');
    document.getElementById('custom-tf-modal').onclick = (e) => { if (e.target.id==='custom-tf-modal') document.getElementById('custom-tf-modal').classList.remove('active'); };
    document.getElementById('custom-tf-input').onkeypress = (e) => { if (e.key==='Enter') document.getElementById('custom-tf-confirm').click(); };
    document.getElementById('custom-tf-confirm').onclick = () => {
        const input = document.getElementById('custom-tf-input').value;
        const minutes = parseCustomTimeframe(input);
        if (minutes === null) { alert('Invalid timeframe format. Examples: 15, 1h, 4h, 1d, 1w'); return; }
        if (!validateTimeframe(minutes)) return;
        document.getElementById('custom-tf-modal').classList.remove('active');
        applyTimeframeChange(minutes);
    };

    function toggleSection(header) { header.parentElement.classList.toggle('expanded'); }

    function toggleSwitch(element) {
        element.classList.toggle('active');
        const switchId = element.id;
        if (switchId === 'toggle-price-line-switch') {
            config.showPriceLine = element.classList.contains('active');
            const lastCandle = displayCandles[displayCandles.length - 1];
            const lineColor = (lastCandle && lastCandle.close >= lastCandle.open) ? config.upColor : config.downColor;
            mainSeries.applyOptions({ priceLineVisible: config.showPriceLine, priceLineColor: lineColor, priceLineWidth: 1, priceLineStyle: 2 });
        }
        else if (switchId === 'toggle-price-label-switch') { config.showPriceLabel = element.classList.contains('active'); scheduleDraw(); }
        else if (switchId === 'toggle-countdown-switch') { config.showCountdown = element.classList.contains('active'); scheduleDraw(); }
        else if (switchId === 'toggle-crosshair-switch') {
            config.showCrosshair = element.classList.contains('active');
            chart.applyOptions({ crosshair: { vertLine: { visible: config.showCrosshair }, horzLine: { visible: config.showCrosshair } } });
        }
    }

    function resetToDefaults() {
        if (!confirm('Reset all settings to default values? This cannot be undone.')) return;
        config = {
            gridSpacing: 1000, gridColor: '#636363', gridOpacity: 1.0, gridLineWidth: 1,
            baseTickSize: 2.5, minCellHeight: 15, upColor: '#608feb', downColor: '#ff4242',
            candleOpacity: 1.0, seriesType: 'candle', minBubbleVolume: 500000,
            showPriceLine: true, showPriceLabel: true, showCountdown: true, showCrosshair: true,
            pocColor: '#f0b90b', currentTimeframe: 5, displayTimeframe: 5, candleWidthPercent: 0.20,
            clusterWidthPercent: 0.80, cumulativeMode: 'all', wickThickness: 1, borderThickness: 1,
            bgColor: '#0a0e1a', panelColor: '#0f1419', accentColor: '#3b82f6',
            absorptionColor: '#FFD700', statsFontFamily: "'JetBrains Mono', monospace",
            statsFontSize: 11, statsFontWeight: '600', cellFontSize: 11, cellFontWeight: '400',
            barSpacing: 50, clusterBgOpacity: 0, pocBorderWidth: 1.5, cellBorderWidth: 1,
            bubbleInnerSize: 5, bubbleOuterSize: 10, bubblePulseSpeed: 1500,
            absorptionDotSize: 4, absorptionGlow: 10, absorptionThreshold: 1000000,
            priceLabelFontSize: 9, timerFontSize: 8, timerOpacity: 0.9,
            defaultIndicatorHeight: 150, oiCandleWidth: 0.5, cvdLineThickness: 1,
            indicatorPadding: 10, indicatorBgOpacity: 0.95, drawDelay: 100, interactionHold: 180,
            clusterVolumeThreshold: 25000,
            showTPO: false, tpoTickSize: 50, tpoBlockWidth: 8,
            tpoOpacityVA: 0.65, tpoOpacityNonVA: 0.70,
            tpoColorSingle: '#ff6ec7', tpoColorVA: '#3b82f6',
            tpoColorNonVA: '#ffffff', tpoColorPOC: '#ffffff',
            priceScaleWidth: 44, priceScaleFontSize: 10,
        };
        tpoCacheKey = '';
        document.getElementById('series-type-select').value = 'candle';
        document.getElementById('bar-spacing-input').value = 50;
        document.getElementById('candle-opacity').value = 100; document.getElementById('opacity-val').textContent = '100%';
        document.getElementById('candle-width-input').value = 20; document.getElementById('cluster-width-input').value = 80;
        document.getElementById('wick-thickness').value = 1; document.getElementById('wick-thickness-val').textContent = '1px';
        document.getElementById('border-thickness').value = 1; document.getElementById('border-thickness-val').textContent = '1px';
        document.getElementById('up-candle-color').value = '#608feb'; document.getElementById('down-candle-color').value = '#ff4242';
        document.getElementById('grid-color-input').value = '#636363'; document.getElementById('poc-color-input').value = '#f0b90b';
        document.getElementById('bg-color-input').value = '#0a0e1a'; document.getElementById('panel-color-input').value = '#0f1419';
        document.getElementById('accent-color-input').value = '#3b82f6'; document.getElementById('absorption-color-input').value = '#FFD700';
        document.getElementById('stats-font-family').value = "'JetBrains Mono', monospace";
        document.getElementById('stats-font-size').value = 9; document.getElementById('stats-font-size-val').textContent = '9px';
        document.getElementById('stats-font-weight').value = '400';
        document.getElementById('cell-font-size').value = 9; document.getElementById('cell-font-size-val').textContent = '9px';
        document.getElementById('cell-font-weight').value = '400';
        document.getElementById('grid-spacing-input').value = 1000;
        document.getElementById('grid-opacity').value = 100; document.getElementById('grid-opacity-val').textContent = '100%';
        document.getElementById('grid-line-width').value = 1; document.getElementById('grid-line-width-val').textContent = '1px';
        document.getElementById('base-tick-input').value = 2.5; document.getElementById('min-cell-height-input').value = 15;
        document.getElementById('cumulative-mode-select').value = 'all';
        document.getElementById('cluster-volume-threshold').value = 50000;
        document.getElementById('cluster-bg-opacity').value = 0; document.getElementById('cluster-bg-opacity-val').textContent = '0%';
        document.getElementById('poc-border-width').value = 1.5; document.getElementById('poc-border-width-val').textContent = '1.5px';
        document.getElementById('cell-border-width').value = 1; document.getElementById('cell-border-width-val').textContent = '1px';
        document.getElementById('bubble-threshold-input').value = 500000;
        document.getElementById('bubble-inner-size').value = 5; document.getElementById('bubble-outer-size').value = 10;
        document.getElementById('bubble-pulse-speed').value = 1500; document.getElementById('bubble-pulse-speed-val').textContent = '1.5s';
        document.getElementById('absorption-dot-size').value = 4; document.getElementById('absorption-glow').value = 10;
        document.getElementById('absorption-threshold').value = 100000;
        document.getElementById('toggle-price-line-switch').classList.remove('active');
        document.getElementById('toggle-price-label-switch').classList.add('active');
        document.getElementById('toggle-countdown-switch').classList.add('active');
        document.getElementById('toggle-crosshair-switch').classList.add('active');
        document.getElementById('price-label-font-size').value = 10; document.getElementById('timer-font-size').value = 11;
        document.getElementById('timer-opacity').value = 90; document.getElementById('timer-opacity-val').textContent = '90%';
        document.getElementById('default-indicator-height').value = 150;
        document.getElementById('oi-candle-width').value = 50; document.getElementById('oi-candle-width-val').textContent = '50%';
        document.getElementById('cvd-line-thickness').value = 1; document.getElementById('cvd-line-thickness-val').textContent = '1px';
        document.getElementById('indicator-padding').value = 10; document.getElementById('indicator-bg-opacity').value = 95;
        document.getElementById('draw-delay').value = 50; document.getElementById('draw-delay-val').textContent = '50ms';
        document.getElementById('interaction-hold').value = 180; document.getElementById('interaction-hold-val').textContent = '180ms';
        updateCandleAppearance();
        chart.applyOptions({ rightPriceScale: { width: 44 }, layout: { background: { color: config.bgColor }, fontSize: 10 }, timeScale: { barSpacing: config.barSpacing } });
        mainSeries.applyOptions({ priceLineVisible: config.showPriceLine });
        chart.applyOptions({ crosshair: { vertLine: { visible: config.showCrosshair }, horzLine: { visible: config.showCrosshair } } });
        applyTimeframeChange(5); 
    }       

    // Settings panel listeners
    document.getElementById('bar-spacing-input').addEventListener('input', (e) => { config.barSpacing = parseInt(e.target.value); chart.timeScale().applyOptions({ barSpacing: config.barSpacing }); scheduleDraw(); });
    document.getElementById('candle-width-input').addEventListener('input', (e) => { config.candleWidthPercent = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('cluster-width-input').addEventListener('input', (e) => { config.clusterWidthPercent = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('wick-thickness').addEventListener('input', (e) => { config.wickThickness = parseFloat(e.target.value); document.getElementById('wick-thickness-val').textContent = config.wickThickness+'px'; scheduleDraw(); });
    document.getElementById('border-thickness').addEventListener('input', (e) => { config.borderThickness = parseFloat(e.target.value); document.getElementById('border-thickness-val').textContent = config.borderThickness+'px'; scheduleDraw(); });
    document.getElementById('bg-color-input').addEventListener('change', (e) => { config.bgColor = e.target.value; chart.applyOptions({ layout: { background: { color: config.bgColor } } }); });
    document.getElementById('panel-color-input').addEventListener('change', (e) => { config.panelColor = e.target.value; });
    document.getElementById('accent-color-input').addEventListener('change', (e) => { config.accentColor = e.target.value; });
    document.getElementById('poc-color-input').addEventListener('change', (e) => { config.pocColor = e.target.value; scheduleDraw(); });
    document.getElementById('absorption-color-input').addEventListener('change', (e) => { config.absorptionColor = e.target.value; scheduleDraw(); });
    document.getElementById('stats-font-family').addEventListener('change', (e) => { config.statsFontFamily = e.target.value; document.getElementById('stats-font-preview').style.fontFamily = e.target.value; scheduleDraw(); });
    document.getElementById('stats-font-size').addEventListener('input', (e) => { config.statsFontSize = parseInt(e.target.value); document.getElementById('stats-font-size-val').textContent = config.statsFontSize+'px'; scheduleDraw(); });
    document.getElementById('stats-font-weight').addEventListener('change', (e) => { config.statsFontWeight = e.target.value; scheduleDraw(); });
    document.getElementById('cell-font-size').addEventListener('input', (e) => { config.cellFontSize = parseInt(e.target.value); document.getElementById('cell-font-size-val').textContent = config.cellFontSize+'px'; scheduleDraw(); });
    document.getElementById('cell-font-weight').addEventListener('change', (e) => { config.cellFontWeight = e.target.value; scheduleDraw(); });
    document.getElementById('grid-opacity').addEventListener('input', (e) => { config.gridOpacity = parseInt(e.target.value)/100; document.getElementById('grid-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('grid-line-width').addEventListener('input', (e) => { config.gridLineWidth = parseFloat(e.target.value); document.getElementById('grid-line-width-val').textContent = config.gridLineWidth+'px'; scheduleDraw(); });
    document.getElementById('base-tick-input').addEventListener('change', (e) => { config.baseTickSize = parseFloat(e.target.value); scheduleDraw(); });
    document.getElementById('min-cell-height-input').addEventListener('change', (e) => { config.minCellHeight = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('cluster-bg-opacity').addEventListener('input', (e) => { config.clusterBgOpacity = parseInt(e.target.value)/100; document.getElementById('cluster-bg-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('poc-border-width').addEventListener('input', (e) => { config.pocBorderWidth = parseFloat(e.target.value); document.getElementById('poc-border-width-val').textContent = config.pocBorderWidth+'px'; scheduleDraw(); });
    document.getElementById('cell-border-width').addEventListener('input', (e) => { config.cellBorderWidth = parseFloat(e.target.value); document.getElementById('cell-border-width-val').textContent = config.cellBorderWidth+'px'; scheduleDraw(); });
    document.getElementById('cluster-volume-threshold').addEventListener('input', (e) => { config.clusterVolumeThreshold = parseFloat(e.target.value) || 0; scheduleDraw(); });
    document.getElementById('bubble-inner-size').addEventListener('input', (e) => { config.bubbleInnerSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('bubble-outer-size').addEventListener('input', (e) => { config.bubbleOuterSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('bubble-pulse-speed').addEventListener('input', (e) => { config.bubblePulseSpeed = parseInt(e.target.value); document.getElementById('bubble-pulse-speed-val').textContent = (config.bubblePulseSpeed/1000).toFixed(1)+'s'; scheduleDraw(); });
    document.getElementById('absorption-dot-size').addEventListener('input', (e) => { config.absorptionDotSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('absorption-glow').addEventListener('input', (e) => { config.absorptionGlow = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('absorption-threshold').addEventListener('input', (e) => { config.absorptionThreshold = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('price-label-font-size').addEventListener('input', (e) => { config.priceLabelFontSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('timer-font-size').addEventListener('input', (e) => { config.timerFontSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('timer-opacity').addEventListener('input', (e) => { config.timerOpacity = parseInt(e.target.value)/100; document.getElementById('timer-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('default-indicator-height').addEventListener('input', (e) => { config.defaultIndicatorHeight = parseInt(e.target.value); });
    document.getElementById('oi-candle-width').addEventListener('input', (e) => { config.oiCandleWidth = parseInt(e.target.value)/100; document.getElementById('oi-candle-width-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('cvd-line-thickness').addEventListener('input', (e) => { config.cvdLineThickness = parseFloat(e.target.value); document.getElementById('cvd-line-thickness-val').textContent = config.cvdLineThickness+'px'; scheduleDraw(); });
    document.getElementById('indicator-padding').addEventListener('input', (e) => { config.indicatorPadding = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('indicator-bg-opacity').addEventListener('input', (e) => { config.indicatorBgOpacity = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('draw-delay').addEventListener('input', (e) => { config.drawDelay = parseInt(e.target.value); document.getElementById('draw-delay-val').textContent = config.drawDelay+'ms'; });
    document.getElementById('interaction-hold').addEventListener('input', (e) => { config.interactionHold = parseInt(e.target.value); document.getElementById('interaction-hold-val').textContent = config.interactionHold+'ms'; });
    document.getElementById('price-scale-font-input').addEventListener('input', (e) => {
        config.priceScaleFontSize = parseInt(e.target.value);
        chart.applyOptions({ layout: { fontSize: config.priceScaleFontSize } });
        extraPanels.forEach(p => p.chart.applyOptions({ layout: { fontSize: config.priceScaleFontSize } }));
        scheduleDraw();
    });

    function getVisibleCandles(cssWidth) {
        const visibleCandles = [];
        if (!displayCandles) return visibleCandles;
        for (let i = 0; i < displayCandles.length; i++) {
            const candle = displayCandles[i];
            const x = chart.timeScale().timeToCoordinate(candle.time);
            if (x === null || x < -100 || x > cssWidth + 100) continue;
            visibleCandles.push({ i, x, candle });
        }
        return visibleCandles;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  TPO / Market Profile Engine (Untouched Math)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function buildTPOProfiles() {
        if (!displayCandles || displayCandles.length === 0) return [];
        const tickSize = Math.max(1, config.tpoTickSize);

        const dayGroups = {};
        for (let i = 0; i < displayCandles.length; i++) {
            const c = displayCandles[i];
            const dayStart = Math.floor(c.time / 86400) * 86400; // 00:00 UTC
            if (!dayGroups[dayStart]) dayGroups[dayStart] = [];
            dayGroups[dayStart].push(c);
        }

        const profiles = [];
        const PERIOD_SECONDS = 1800; // 30-minute TPO periods
        const sortedDays = Object.keys(dayGroups).map(Number).sort((a, b) => a - b);

        sortedDays.forEach(dayStart => {
            const candles = dayGroups[dayStart];
            if (!candles || candles.length === 0) return;

            const periodGroups = {}; 
            candles.forEach(c => {
                const offset = c.time - dayStart;
                const periodIdx = Math.floor(offset / PERIOD_SECONDS);
                if (!periodGroups[periodIdx]) periodGroups[periodIdx] = [];
                periodGroups[periodIdx].push(c);
            });

            const rowMap = {}; 
            Object.values(periodGroups).forEach(pCandles => {
                let pH = -Infinity, pL = Infinity;
                pCandles.forEach(c => {
                    if (c.high > pH) pH = c.high;
                    if (c.low  < pL) pL = c.low;
                });
                const rowLow  = Math.floor(pL / tickSize) * tickSize;
                const rowHigh = Math.floor(pH / tickSize) * tickSize;
                const hitThisPeriod = new Set();
                for (let p = rowLow; p <= rowHigh + tickSize * 0.001; p += tickSize) {
                    const key = Math.round(p); 
                    if (!hitThisPeriod.has(key)) {
                        hitThisPeriod.add(key);
                        rowMap[key] = (rowMap[key] || 0) + 1;
                    }
                }
            });

            const rowKeys = Object.keys(rowMap);
            if (rowKeys.length === 0) return;

            let totalTPO = 0;
            rowKeys.forEach(k => { totalTPO += rowMap[k]; });

            let pocPrice = null, pocCount = 0;
            rowKeys.forEach(k => {
                if (rowMap[k] > pocCount) {
                    pocCount = rowMap[k];
                    pocPrice = parseFloat(k);
                }
            });

            const sortedPrices = rowKeys.map(Number).sort((a, b) => a - b);
            const pocIdx = sortedPrices.findIndex(p => Math.abs(p - pocPrice) < 0.5);

            const vaTarget = totalTPO * 0.70;
            let vaCount = pocCount;
            let vaLow = pocPrice, vaHigh = pocPrice;
            let upIdx = pocIdx + 1, downIdx = pocIdx - 1;

            while (vaCount < vaTarget) {
                const hasUp   = upIdx   <  sortedPrices.length;
                const hasDown = downIdx >= 0;
                if (!hasUp && !hasDown) break;

                const upAdd   = hasUp   ? rowMap[sortedPrices[upIdx]]   : 0;
                const downAdd = hasDown ? rowMap[sortedPrices[downIdx]] : 0;

                if (hasUp && upAdd >= downAdd) {
                    vaCount += upAdd;
                    vaHigh = sortedPrices[upIdx];
                    upIdx++;
                } else if (hasDown) {
                    vaCount += downAdd;
                    vaLow = sortedPrices[downIdx];
                    downIdx--;
                } else {
                    vaCount += upAdd;
                    vaHigh = sortedPrices[upIdx];
                    upIdx++;
                }
            }

            const singlePrints = new Set();
            rowKeys.forEach(k => { if (rowMap[k] === 1) singlePrints.add(parseFloat(k)); });

            const maxBlocks = Math.max(...Object.values(rowMap));
            const sessionHigh = Math.max(...candles.map(c => c.high));
            const sessionLow  = Math.min(...candles.map(c => c.low));
            const firstCandleTime = candles[0].time;

            const topExtremes = new Set();
            const bottomExtremes = new Set();
            for (let i = sortedPrices.length - 1; i >= 0; i--) {
                if (rowMap[sortedPrices[i]] === 2) topExtremes.add(sortedPrices[i]);
                else break;
            }
            for (let i = 0; i < sortedPrices.length; i++) {
                if (rowMap[sortedPrices[i]] === 2) bottomExtremes.add(sortedPrices[i]);
                else break;
            }

            profiles.push({
                dayStart, firstCandleTime, rowMap, sortedPrices, pocPrice, pocCount,
                vaLow, vaHigh, totalTPO, singlePrints, maxBlocks, sessionHigh, sessionLow,
                tickSize, topExtremes, bottomExtremes, sessionEndTime: candles[candles.length - 1].time,   
            });
        });
        return profiles;
    }

    function drawTPO(cssWidth, candleBottomY) {
        if (!config.showTPO) return;

        const lastC = displayCandles[displayCandles.length - 1];
        const newCacheKey = `${displayCandles.length}_${lastC?.time ?? 0}_${Math.round(lastC?.high ?? 0)}_${Math.round(lastC?.low ?? 0)}_${config.tpoTickSize}`;
        if (newCacheKey !== tpoCacheKey || !tpoProfilesCache) {
            tpoProfilesCache = buildTPOProfiles();
            tpoCacheKey = newCacheKey;
        }

        if (!tpoProfilesCache || tpoProfilesCache.length === 0) return;

        const timeScale  = chart.timeScale();
        const blockW     = Math.max(2, config.tpoBlockWidth);

        tpoProfilesCache.forEach(profile => {
            const anchorX = timeScale.timeToCoordinate(profile.firstCandleTime);
            if (anchorX === null) return;

            const profileMaxWidth = profile.maxBlocks * blockW;
            if (anchorX + profileMaxWidth < -50 || anchorX > cssWidth + 50) return;

            const { rowMap, sortedPrices, pocPrice, vaLow, vaHigh, singlePrints, tickSize } = profile;

            sortedPrices.forEach(price => {
                const count = rowMap[price];
                const yTop    = mainSeries.priceToCoordinate(price + tickSize);
                const yBottom = mainSeries.priceToCoordinate(price);
                if (yTop === null || yBottom === null) return;

                const rowY = Math.min(yTop, yBottom);
                const rowH = Math.max(1, Math.abs(yBottom - yTop) - 1);

                if (rowY > candleBottomY || rowY + rowH < 0) return;

                const isSingle  = singlePrints.has(price);
                const isInVA    = price >= vaLow && price <= vaHigh;
                const isPOC     = Math.abs(price - pocPrice) < 0.5;

                let fillColor, fillAlpha;
                if (isSingle) {
                    fillColor = config.tpoColorSingle;
                    fillAlpha = Math.min(1, config.tpoOpacityVA + 0.20);
                } else if (isInVA) {
                    fillColor = config.tpoColorVA;
                    fillAlpha = config.tpoOpacityVA;
                } else {
                    fillColor = config.tpoColorNonVA;
                    fillAlpha = config.tpoOpacityNonVA;
                }

                const totalRowWidth = count * blockW;
                const drawableBlocks = Math.min(count, Math.ceil((cssWidth - anchorX) / blockW));

                for (let b = 0; b < drawableBlocks; b++) {
                    const bx = anchorX + b * blockW;
                    if (bx > cssWidth - 2) break;
                    const bw = Math.min(blockW - 1, cssWidth - bx - 1); 
                    offscreenCtx.fillStyle = hexToRgba(fillColor, fillAlpha);
                    offscreenCtx.fillRect(bx, rowY, bw, rowH);
                }

                if (isPOC && count > 0) {
                    offscreenCtx.save();
                    offscreenCtx.strokeStyle  = config.tpoColorPOC;
                    offscreenCtx.lineWidth    = 1.5;
                    offscreenCtx.shadowColor  = config.tpoColorPOC;
                    offscreenCtx.shadowBlur   = 4;
                    const clippedW = Math.min(totalRowWidth, cssWidth - anchorX - 2);
                    offscreenCtx.strokeRect(anchorX, rowY, clippedW, rowH);
                    offscreenCtx.restore();
                }
            });

            offscreenCtx.save();
            offscreenCtx.strokeStyle = 'rgba(255,255,255,0.06)';
            offscreenCtx.lineWidth   = 1;
            offscreenCtx.setLineDash([3, 5]);
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(anchorX, 0);
            offscreenCtx.lineTo(anchorX, candleBottomY);
            offscreenCtx.stroke();
            offscreenCtx.setLineDash([]);
            offscreenCtx.restore();

            const vaHighY = mainSeries.priceToCoordinate(vaHigh + tickSize);
            const vaLowY  = mainSeries.priceToCoordinate(vaLow);
            const labelX  = anchorX + profile.maxBlocks * blockW + 4;
            if (labelX < cssWidth - 10) {
                offscreenCtx.save();
                offscreenCtx.font      = `600 9px 'JetBrains Mono', monospace`;
                offscreenCtx.fillStyle = hexToRgba(config.tpoColorVA, 0.75);
                offscreenCtx.textAlign = 'left';
                if (vaHighY !== null && vaHighY > 0 && vaHighY < candleBottomY) offscreenCtx.fillText('', labelX, vaHighY - 2);
                if (vaLowY !== null && vaLowY > 0 && vaLowY < candleBottomY) offscreenCtx.fillText('', labelX, vaLowY + 10);
                const pocY = mainSeries.priceToCoordinate(pocPrice + tickSize / 2);
                if (pocY !== null && pocY > 0 && pocY < candleBottomY) {
                    offscreenCtx.fillStyle = hexToRgba(config.tpoColorPOC, 0.90);
                    offscreenCtx.fillText('', labelX, pocY + 4);
                }
                offscreenCtx.restore();
            }

            const sessionEndTime = profile.sessionEndTime;
            let postSessionHigh = -Infinity;
            let postSessionLow  =  Infinity;
            for (let ci = displayCandles.length - 1; ci >= 0; ci--) {
                const c = displayCandles[ci];
                if (c.time <= sessionEndTime) break;
                if (c.high > postSessionHigh) postSessionHigh = c.high;
                if (c.low  < postSessionLow)  postSessionLow  = c.low;
            }
            if (postSessionHigh === -Infinity) postSessionHigh = currentPrice;
            if (postSessionLow  ===  Infinity) postSessionLow  = currentPrice;

            const lastCandleInData = displayCandles[displayCandles.length - 1];
            const currentCandleX = lastCandleInData
                ? (timeScale.timeToCoordinate(lastCandleInData.time) ?? cssWidth - 80)
                : cssWidth - 80;
            const extremeLineEndX   = Math.min(currentCandleX + 20, cssWidth - 80);
            const extremeLineStartX = anchorX + profile.maxBlocks * blockW;

            if (extremeLineStartX < extremeLineEndX) {
                profile.topExtremes.forEach(price => {
                    if (postSessionHigh >= price) return;
                    const rowMidY = mainSeries.priceToCoordinate(price + tickSize * 0.5);
                    if (rowMidY === null || rowMidY < 0 || rowMidY > candleBottomY) return;
                    offscreenCtx.save();
                    offscreenCtx.strokeStyle = config.tpoColorSingle;
                    offscreenCtx.lineWidth   = 1.2;
                    offscreenCtx.globalAlpha = 0.70;
                    offscreenCtx.setLineDash([4, 5]);
                    offscreenCtx.beginPath();
                    offscreenCtx.moveTo(extremeLineStartX, rowMidY);
                    offscreenCtx.lineTo(extremeLineEndX,   rowMidY);
                    offscreenCtx.stroke();
                    offscreenCtx.setLineDash([]);
                    offscreenCtx.restore();
                });

                profile.bottomExtremes.forEach(price => {
                    if (postSessionLow <= price + tickSize) return;
                    const rowMidY = mainSeries.priceToCoordinate(price + tickSize * 0.5);
                    if (rowMidY === null || rowMidY < 0 || rowMidY > candleBottomY) return;
                    offscreenCtx.save();
                    offscreenCtx.strokeStyle = config.tpoColorSingle;
                    offscreenCtx.lineWidth   = 1.2;
                    offscreenCtx.globalAlpha = 0.70;
                    offscreenCtx.setLineDash([4, 5]);
                    offscreenCtx.beginPath();
                    offscreenCtx.moveTo(extremeLineStartX, rowMidY);
                    offscreenCtx.lineTo(extremeLineEndX,   rowMidY);
                    offscreenCtx.stroke();
                    offscreenCtx.setLineDash([]);
                    offscreenCtx.restore();
                });
            }
        }); 
    }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Indicator System
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    class BaseIndicator {
        constructor(id, name, defaultHeight = config.defaultIndicatorHeight) {
            this.id = id; this.name = name; this.height = defaultHeight;
            this.element = null; this.canvas = null; this.ctx = null;
            this.offscreenCanvas = null; this.offscreenCtx = null; this.visible = false;
        }
        createElement() {
            const div = document.createElement('div');
            div.className = 'indicator-pane'; div.id = `indicator-${this.id}`; div.style.height = this.height+'px';
            div.innerHTML = `
                <div class="pane-header" data-indicator="${this.id}">
                    <span class="pane-label">${this.name}</span>
                    <div class="pane-close" data-indicator="${this.id}">âœ•</div>
                </div>
                <div class="resizer-handle" data-indicator="${this.id}"><div class="resizer-line"></div></div>
                <canvas class="pane-canvas" id="canvas-${this.id}"></canvas>`;
            this.element = div;
            this.canvas = div.querySelector(`#canvas-${this.id}`);
            this.ctx = this.canvas.getContext('2d');
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            this.setupEventListeners();
            return div;
        }
        setupEventListeners() {
            this.element.querySelector('.pane-close').addEventListener('click', (e) => {
                e.stopPropagation();
                const mgr = findManagerForIndicator(this.id, this.element);
                mgr.removeIndicator(this.id);
            });
            const resizer = this.element.querySelector('.resizer-handle');
            let dragging = false, startY = 0, startH = 0;
            resizer.addEventListener('mousedown', (e) => {
                e.stopPropagation(); dragging = true; startY = e.clientY; startH = this.height;
                document.body.style.cursor = 'ns-resize';
            });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                this.height = Math.max(MIN_PANE_HEIGHT, startH + (startY - e.clientY));
                const mgr = findManagerForIndicator(this.id, this.element);
                mgr.updateLayout();
            });
            window.addEventListener('mouseup', () => {
                if (dragging) { dragging = false; document.body.style.cursor = ''; }
            });
            this.element.querySelector('.pane-header').addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('pane-close')) return;
                const mgr = findManagerForIndicator(this.id, this.element);
                mgr.startDrag(this.id, e);
            });
        }
        setupBuffers(width, height) {
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = Math.floor(width*dpr); this.canvas.height = Math.floor(height*dpr);
            this.canvas.style.width = width+'px'; this.canvas.style.height = height+'px';
            this.offscreenCanvas.width = this.canvas.width; this.offscreenCanvas.height = this.canvas.height;
            this.offscreenCtx.setTransform(dpr,0,0,dpr,0,0); this.ctx.setTransform(1,0,0,1,0,0);
        }
        show() { this.visible = true; }
        hide() { this.visible = false; }
        draw(cssWidth) {}
        render() {
            if (!this.visible || !this.ctx || !this.offscreenCanvas) return;
            this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
            this.ctx.drawImage(this.offscreenCanvas,0,0);
        }
    }

    class OIIndicator extends BaseIndicator {
        constructor() { super('oi', 'Open Interest', 200); }
        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;
            const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
            const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
            ctxS.clearRect(0, 0, cssWidth, this.height);
            const barSpacing = chart.timeScale().options().barSpacing;
            const visibleCandles = getVisibleCandles(cssWidth);

            let minOI = Infinity, maxOI = -Infinity;
            visibleCandles.forEach(({ candle, x }) => {
                if (x > drawWidth) return;
                if (candle.oiClose && candle.oiClose > 0) {
                    const cHigh = candle.oiHigh || Math.max(candle.oiOpen, candle.oiClose);
                    const cLow  = candle.oiLow  || Math.min(candle.oiOpen, candle.oiClose);
                    if (cHigh > maxOI) maxOI = cHigh;
                    if (cLow < minOI && cLow > 0) minOI = cLow;
                }
            });
            if (maxOI === -Infinity || minOI === Infinity) { minOI = 0; maxOI = 100; }
            if (minOI === maxOI) { minOI = maxOI * 0.99; maxOI = maxOI * 1.01; }

            const oPadding   = config.indicatorPadding;
            const availableH = this.height - oPadding * 2;
            const oiRange    = maxOI - minOI;
            const getOIY = val => val <= 0
                ? this.height - oPadding
                : oPadding + availableH * (1 - (val - minOI) / oiRange);

            visibleCandles.forEach(({ candle, x }) => {
                if (x > drawWidth) return;
                if (!candle.oiClose || candle.oiClose <= 0) return;
                const cOpen  = candle.oiOpen || candle.oiClose;
                const cClose = candle.oiClose;
                const cHigh  = candle.oiHigh || Math.max(cOpen, cClose);
                const cLow   = candle.oiLow  || Math.min(cOpen, cClose);
                const openY  = getOIY(cOpen);
                const closeY = getOIY(cClose);
                const highY  = getOIY(cHigh);
                const lowY   = getOIY(cLow);
                const isUp   = cClose >= cOpen;
                const color  = hexToRgba(isUp ? config.oiUpColor : config.oiDownColor, config.oiOpacity);
                const w      = Math.max(3, barSpacing * config.oiCandleWidth);

                ctxS.strokeStyle = color;
                ctxS.lineWidth   = 1;
                ctxS.beginPath();
                ctxS.moveTo(x, highY);
                ctxS.lineTo(x, lowY);
                ctxS.stroke();

                const bodyTop = Math.min(openY, closeY);
                const bodyH   = Math.max(1, Math.abs(closeY - openY));
                ctxS.fillStyle = color;
                ctxS.fillRect(x - w / 2, bodyTop, w, bodyH);

                ctxS.strokeStyle = config.oiBorderColor;
                ctxS.lineWidth   = 1;
                ctxS.strokeRect(x - w / 2, bodyTop, w, bodyH);
            });
        }
    }

    class CVDIndicator extends BaseIndicator {
        constructor() { super('cvd','Cumulative Volume Delta',150); }
        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;
            const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
            const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
            ctxS.clearRect(0,0,cssWidth,this.height);
            
            const cvdData = []; 
            let cumulativeDelta = 0;
            displayCandles.forEach(candle => {
                const tsKey = String(Math.floor(candle.time));
                const buckets = displayClusters[tsKey];
                if (buckets) { 
                    let d=0; 
                    Object.values(buckets).forEach(b => d+=(b.buy-b.sell)); 
                    cumulativeDelta+=d; 
                }
                cvdData.push({ time: candle.time, cvd: cumulativeDelta });
            });
            
            if (cvdData.length === 0) return;
            const visibleCandles = getVisibleCandles(cssWidth);
            if (visibleCandles.length === 0) return;

            const cvdMap = new Map(cvdData.map(d => [d.time, d.cvd]));
            
            let minCVD = Infinity, maxCVD = -Infinity;
            visibleCandles.forEach(item => {
                const cvd = cvdMap.get(item.candle.time);
                if (cvd !== undefined) { 
                    if (cvd < minCVD) minCVD = cvd; 
                    if (cvd > maxCVD) maxCVD = cvd; 
                }
            });
            
            if (minCVD===Infinity||maxCVD===-Infinity) return;
            if (minCVD===maxCVD) { minCVD-=1000000; maxCVD+=1000000; }
            
            const padding=config.indicatorPadding;
            const availableH=this.height-(padding*2);
            const cvdRange=maxCVD-minCVD;
            const getCVDY = (val) => padding+(availableH*(1-(val-minCVD)/cvdRange));
            
            if (minCVD<=0 && maxCVD>=0) {
                const zeroY = getCVDY(0);
                ctxS.strokeStyle='#3a3f4e'; ctxS.lineWidth=1; ctxS.setLineDash([4,4]);
                ctxS.beginPath(); ctxS.moveTo(0,zeroY); ctxS.lineTo(drawWidth,zeroY); ctxS.stroke(); 
                ctxS.setLineDash([]);
            }
            
            ctxS.beginPath(); 
            let firstPoint=true;
            visibleCandles.forEach(item => {
                const cvd = cvdMap.get(item.candle.time);
                if (cvd === undefined || item.x > drawWidth) return;
                const y = getCVDY(cvd);
                if (firstPoint) { ctxS.moveTo(item.x,y); firstPoint=false; } 
                else ctxS.lineTo(item.x,y);
            });
            
            const finalCVD = cvdData[cvdData.length-1]?.cvd||0;
            const lineColor = (config.cvdLineColor && config.cvdLineColor !== 'auto') ? config.cvdLineColor : (finalCVD >= 0 ? config.upColor : config.downColor);
            ctxS.strokeStyle=lineColor; ctxS.lineWidth=config.cvdLineThickness; ctxS.stroke();
            
            ctxS.font=`10px ${config.statsFontFamily}`; ctxS.textAlign='right'; ctxS.fillStyle='#8b92a7';
            ctxS.fillText(formatUSD(maxCVD),drawWidth-5,getCVDY(maxCVD)+12);
            ctxS.fillText(formatUSD(minCVD),drawWidth-5,getCVDY(minCVD)-5);
            
            if (finalCVD!==undefined) {
                const lastVisible = visibleCandles[visibleCandles.length-1];
                const lastX = lastVisible && lastVisible.x < drawWidth ? lastVisible.x : drawWidth-80;
                ctxS.fillStyle=lineColor; ctxS.font=`bold 11px ${config.statsFontFamily}`;
                ctxS.textAlign='left'; ctxS.fillText(formatUSD(finalCVD),lastX+10,getCVDY(finalCVD)+4);
            }
        }
    }

    class BarStatsIndicator extends BaseIndicator {
        constructor() { super('barstats', 'Bar Statistics', 72); }

        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;

            const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
            const drawWidth = cssWidth - PRICE_SCALE_WIDTH;

            ctxS.clearRect(0, 0, cssWidth, this.height);
            ctxS.save();
            ctxS.beginPath();
            ctxS.rect(0, 0, drawWidth, this.height);
            ctxS.clip();

            const visibleCandles = getVisibleCandles(cssWidth);
            if (visibleCandles.length === 0) return;

            const barSpacing = chart.timeScale().options().barSpacing;
            const cellWidth = Math.max(barSpacing * 0.92, 6);

            const stats = visibleCandles.map(({ candle, x }) => {
                const tsKey = String(Math.floor(candle.time));
                const buckets = displayClusters[tsKey];
                let buy = 0, sell = 0;
                if (buckets) Object.values(buckets).forEach(d => { buy += d.buy; sell += d.sell; });
                return { x, totalVol: buy + sell, delta: buy - sell };
            });

            const maxVol = Math.max(...stats.map(s => s.totalVol), 1);
            const maxDelta = Math.max(...stats.map(s => Math.abs(s.delta)), 1);

            const ROW_H = this.height / 2;

            ctxS.fillStyle = config.bgColor;
            ctxS.fillRect(0, 0, drawWidth, this.height);

            let lineEndX = 0;

            const fontSize = Math.max(8, Math.min(config.cellFontSize, Math.floor(cellWidth * 0.32)));

            stats.forEach(({ x, totalVol, delta }) => {
                if (x > drawWidth) return;

                const currentRightEdge = x + cellWidth / 2;
                lineEndX = Math.min(currentRightEdge, drawWidth);

                const volRatio = totalVol / maxVol;
                const deltaRatio = Math.abs(delta) / maxDelta;
                const isDeltaPos = delta >= 0;
                const colLeft = x - cellWidth / 2;

                const volAlpha = 0.08 + volRatio * 0.65;
                ctxS.fillStyle = hexToRgba(config.barStatsUpColor, volAlpha);
                ctxS.fillRect(colLeft, 0, cellWidth, ROW_H);

                const deltaAlpha = 0.08 + deltaRatio * 0.78;
                ctxS.fillStyle = hexToRgba(isDeltaPos ? config.barStatsUpColor : config.barStatsDownColor, deltaAlpha);
                ctxS.fillRect(colLeft, ROW_H, cellWidth, ROW_H);

                ctxS.strokeStyle = 'rgba(26,31,46,0.35)';
                ctxS.lineWidth = 0.5;
                ctxS.beginPath();
                ctxS.moveTo(colLeft, 0);
                ctxS.lineTo(colLeft, this.height);
                ctxS.stroke();

                if (cellWidth >= 28) {
                    ctxS.textAlign = 'center';
                    ctxS.textBaseline = 'middle';
                    ctxS.font = `${config.cellFontWeight} ${fontSize}px ${config.statsFontFamily}`;
                    ctxS.fillStyle = 'rgba(232,234,237,0.92)';
                    ctxS.fillText(formatUSD(totalVol), x, ROW_H / 2);
                    ctxS.fillText(formatUSD(delta), x, ROW_H * 1.5);
                }
            });

            if (lineEndX > 0) {
                ctxS.strokeStyle = 'rgba(26,31,46,0.7)';
                ctxS.lineWidth = 1;
                ctxS.beginPath();
                ctxS.moveTo(0, ROW_H);
                ctxS.lineTo(lineEndX, ROW_H);
                ctxS.stroke();
            }
            ctxS.restore();
        }
    }

    class VWAPIndicator extends BaseIndicator {
        constructor() { super('vwap', 'VWAP', 0); }
        draw(cssWidth) {
            if (!this.visible) return;
        }
    }

    let vwapData = [];
    let vwapCacheKey = '';

    function calculateVWAP() {
        vwapData = [];
        const now = new Date();
        const todayStart = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0));
        const sessionStartTime = Math.floor(todayStart.getTime() / 1000);
        let cumulativePV = 0, cumulativeVolume = 0;
        for (let i = 0; i < displayCandles.length; i++) {
            const candle = displayCandles[i];
            if (candle.time < sessionStartTime) continue;
            const barVolume = candle.volume || 0;
            if (barVolume === 0) continue;
            const typicalPrice = (candle.high + candle.low + candle.close) / 3;
            cumulativePV += typicalPrice * barVolume;
            cumulativeVolume += barVolume;
            vwapData.push({ time: candle.time, vwap: cumulativeVolume > 0 ? cumulativePV / cumulativeVolume : typicalPrice });
        }
    }

    function drawVWAP(cssWidth, candleBottomY) {
        if (!config.vwapVisible) return;

        const lastCandle = displayCandles[displayCandles.length - 1];
        const cacheKey = `${displayCandles.length}_${lastCandle?.time ?? 0}_${lastCandle?.volume ?? 0}_${lastCandle?.high ?? 0}_${lastCandle?.low ?? 0}`;
        if (cacheKey !== vwapCacheKey) { calculateVWAP(); vwapCacheKey = cacheKey; }
        if (vwapData.length === 0) return;

        const timeScale        = chart.timeScale();
        const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
        const drawWidth        = cssWidth - PRICE_SCALE_WIDTH;

        offscreenCtx.save();
        offscreenCtx.strokeStyle = config.vwapColor;
        offscreenCtx.lineWidth   = 1;
        offscreenCtx.setLineDash(getLineDash(config.vwapLineStyle));
        offscreenCtx.globalAlpha = 0.85;

        offscreenCtx.beginPath();
        let firstPoint = true;
        vwapData.forEach(point => {
            const x = timeScale.timeToCoordinate(point.time);
            if (x === null || x < -100 || x > drawWidth) return;
            const y = mainSeries.priceToCoordinate(point.vwap);
            if (y === null || y < 0 || y > candleBottomY) return;
            if (firstPoint) { offscreenCtx.moveTo(x, y); firstPoint = false; }
            else offscreenCtx.lineTo(x, y);
        });
        offscreenCtx.stroke();
        offscreenCtx.setLineDash([]);

        if (vwapData.length > 0 && (config.vwapShowLabel || config.vwapShowPrice)) {
            const last = vwapData[vwapData.length - 1];
            const lastX = timeScale.timeToCoordinate(last.time);
            const lastY = mainSeries.priceToCoordinate(last.vwap);
            if (lastX !== null && lastY !== null && lastY >= 0 && lastY <= candleBottomY) {
                let text = '';
                if (config.vwapShowLabel) text += 'VWAP';
                if (config.vwapShowLabel && config.vwapShowPrice) text += ' ';
                if (config.vwapShowPrice) text += last.vwap.toFixed(2);
                if (text) {
                    offscreenCtx.font      = "bold 10px 'JetBrains Mono', monospace";
                    offscreenCtx.fillStyle = config.vwapColor;
                    offscreenCtx.textAlign = 'left';
                    offscreenCtx.globalAlpha = 0.9;
                    offscreenCtx.fillText(text, lastX + 8, lastY + 4);
                }
            }
        }
        offscreenCtx.restore();
    }

    function findManagerForIndicator(id, element) {
        if (element) {
            if (indicatorManager.container && indicatorManager.container.contains(element)) return indicatorManager;
            for (const p of extraPanels) {
                if (p.indicatorManager.container.contains(element)) return p.indicatorManager;
            }
        }
        if (indicatorManager.indicators.has(id)) return indicatorManager;
        for (const p of extraPanels) {
            if (p.indicatorManager.indicators.has(id)) return p.indicatorManager;
        }
        return indicatorManager;
    }

    class IndicatorManager {
        constructor() { 
            this.indicators = new Map(); 
            this.order = []; 
            this.container = null; // Set dynamically in Golden Layout component initialization
            this.dragState = null; 
            this.placeholder = null; 
            this.chart = null; 
            this.wrapper = null; 
            this.onLayout = null; 
        }
        addIndicator(indicator) {
            if (this.indicators.has(indicator.id)) return;
            this.container.appendChild(indicator.createElement());
            this.indicators.set(indicator.id, indicator); 
            this.order.push(indicator.id); 
            indicator.show(); 
            this.updateLayout();
        }
        removeIndicator(id) {
            const indicator = this.indicators.get(id); if (!indicator) return;
            indicator.hide(); 
            indicator.element.remove(); 
            this.indicators.delete(id); 
            this.order = this.order.filter(i=>i!==id); 
            this.updateLayout();
            const toggleBtn = document.getElementById(`toggle-${id}`); 
            if (toggleBtn) toggleBtn.classList.remove('active');
        }
        getIndicator(id) { return this.indicators.get(id); }
        updateLayout() {
            const activeChart = this.chart || chart;
            const wrapper = this.wrapper || activeWrapperEl || document.getElementById('panel-wrapper-0');
            // If the wrapper isn't fully initialized by GL yet, bail.
            if (!wrapper || wrapper.clientWidth === 0) return; 

            const totalHeight = wrapper.clientHeight;
            let totalIndicatorHeight = 0;
            this.order.forEach(id => { const ind = this.indicators.get(id); if (ind && ind.visible) totalIndicatorHeight += ind.height; });
            const marginPct = Math.min(0.92, (totalIndicatorHeight + TIME_AXIS_HEIGHT) / totalHeight);
            
            activeChart.priceScale('right').applyOptions({ scaleMargins: { top: 0.05, bottom: marginPct } });
            
            let currentBottom = TIME_AXIS_HEIGHT;
            this.order.forEach(id => {
                const indicator = this.indicators.get(id); if (!indicator || !indicator.visible) return;
                indicator.element.style.bottom = currentBottom+'px'; 
                indicator.element.style.height = indicator.height+'px';
                indicator.setupBuffers(wrapper.clientWidth, indicator.height); 
                currentBottom += indicator.height;
            });
            
            activeChart.applyOptions({ width: wrapper.clientWidth, height: totalHeight });
            updatePaneRight();
            
            if (this.onLayout) this.onLayout();
            else if (typeof scheduleDraw === 'function') scheduleDraw();
        }
        startDrag(id, e) {
            const indicator = this.indicators.get(id); if (!indicator) return;
            this.dragState = { id, startY: e.clientY, startOrder: [...this.order] };
            indicator.element.classList.add('dragging');
            this.placeholder = document.createElement('div'); 
            this.placeholder.className = 'drag-placeholder'; 
            this.placeholder.style.height = '2px';
            (this.wrapper || document.getElementById('panel-wrapper-0')).appendChild(this.placeholder);
            document.addEventListener('mousemove', this.handleDragMove); 
            document.addEventListener('mouseup', this.handleDragEnd);
        }
        handleDragMove = (e) => {
            if (!this.dragState) {
                // Safety valve: if dragState was lost (e.g. mouseup outside window),
                // clean up the orphaned listeners so they don't accumulate.
                document.removeEventListener('mousemove', this.handleDragMove);
                document.removeEventListener('mouseup', this.handleDragEnd);
                return;
            }
            const wrapper = this.wrapper || document.getElementById('panel-wrapper-0');
            const relativeY = wrapper.getBoundingClientRect().bottom - e.clientY;
            let insertIndex = 0, cumulativeHeight = TIME_AXIS_HEIGHT;
            for (let i=0; i<this.order.length; i++) {
                const ind = this.indicators.get(this.order[i]); if (!ind || ind.id===this.dragState.id) continue;
                if (relativeY > cumulativeHeight + (ind.height/2)) insertIndex = i+1;
                cumulativeHeight += ind.height;
            }
            let placeholderBottom = TIME_AXIS_HEIGHT;
            for (let i=0; i<insertIndex; i++) { 
                const ind = this.indicators.get(this.order[i]); 
                if (ind && ind.id!==this.dragState.id) placeholderBottom += ind.height; 
            }
            this.placeholder.style.bottom = placeholderBottom+'px';
        }
        handleDragEnd = () => {
            if (!this.dragState) return;
            const indicator = this.indicators.get(this.dragState.id); 
            if (indicator) indicator.element.classList.remove('dragging');
            const placeholderBottom = parseInt(this.placeholder.style.bottom);
            let newOrder = [], cumulativeHeight = TIME_AXIS_HEIGHT, inserted = false;
            this.order.forEach(id => {
                if (id === this.dragState.id) return;
                const ind = this.indicators.get(id); if (!ind) return;
                if (!inserted && cumulativeHeight >= placeholderBottom) { newOrder.push(this.dragState.id); inserted = true; }
                newOrder.push(id); cumulativeHeight += ind.height;
            });
            if (!inserted) newOrder.push(this.dragState.id);
            this.order = newOrder;
            if (this.placeholder) { this.placeholder.remove(); this.placeholder = null; }
            document.removeEventListener('mousemove', this.handleDragMove); 
            document.removeEventListener('mouseup', this.handleDragEnd);
            this.dragState = null; 
            this.updateLayout();
        }
        drawAll(cssWidth) { this.indicators.forEach(ind => { if (ind.visible) { ind.draw(cssWidth); ind.render(); } }); }
    }

    // â”€â”€ Toggle Event Listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('toggle-oi').addEventListener('click', function() {
        const mgr = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
        if (!mgr) return;
        const ind = mgr.getIndicator('oi');
        if (ind && ind.visible) { mgr.removeIndicator('oi'); this.classList.remove('active'); }
        else { mgr.addIndicator(new OIIndicator()); this.classList.add('active'); }
    });
    
    document.getElementById('toggle-cvd').addEventListener('click', function() {
        const mgr = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
        if (!mgr) return;
        const ind = mgr.getIndicator('cvd');
        if (ind && ind.visible) { mgr.removeIndicator('cvd'); this.classList.remove('active'); }
        else { mgr.addIndicator(new CVDIndicator()); this.classList.add('active'); }
    });
    
    document.getElementById('toggle-barstats').addEventListener('click', function() {
        const mgr = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
        if (!mgr) return;
        const ind = mgr.getIndicator('barstats');
        if (ind && ind.visible) { mgr.removeIndicator('barstats'); this.classList.remove('active'); }
        else { mgr.addIndicator(new BarStatsIndicator()); this.classList.add('active'); }
        scheduleDraw();
    });

    document.getElementById('toggle-dailylevels').addEventListener('click', function() {
        if (selectedPanelId === 0) {
            config.showDailyLevels = !config.showDailyLevels;
            this.classList.toggle('active', config.showDailyLevels);
            scheduleDraw();
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.showDailyLevels = !panel.showDailyLevels;
                this.classList.toggle('active', panel.showDailyLevels);
                schedulePanelDraw(panel);
            }
        }
    });

    document.getElementById('toggle-tpo').addEventListener('click', function() {
        if (selectedPanelId === 0) {
            config.showTPO = !config.showTPO;
            this.classList.toggle('active', config.showTPO);
            const sw = document.getElementById('toggle-tpo-switch');
            if (sw) sw.classList.toggle('active', config.showTPO);
            tpoCacheKey = '';
            scheduleDraw();
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.showTPO = !panel.showTPO;
                this.classList.toggle('active', panel.showTPO);
                panel.tpoCacheKey = '';
                schedulePanelDraw(panel);
            }
        }
    });

    document.getElementById('toggle-vwap').addEventListener('click', function() {
        if (selectedPanelId === 0) {
            config.vwapVisible = !config.vwapVisible;
            this.classList.toggle('active', config.vwapVisible);
            scheduleDraw();
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.vwapVisible = !panel.vwapVisible;
                this.classList.toggle('active', panel.vwapVisible);
                schedulePanelDraw(panel);
            }
        }
    });

    function getLineDash(style) {
        switch (style) {
            case 'solid':  return [];
            case 'dashed': return [8, 4];
            case 'dotted': return [2, 4];
            default:       return [4, 4];
        }
    }

    // â”€â”€ Context Menu Builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function _iRow(label, controlEl) {
        const row = document.createElement('div');
        row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:10px;min-height:26px;';
        const lbl = document.createElement('span');
        lbl.style.cssText = 'font-size:10px;color:#8b92a7;text-transform:uppercase;letter-spacing:0.04em;white-space:nowrap;flex-shrink:0;';
        lbl.textContent = label;
        row.appendChild(lbl);
        row.appendChild(controlEl);
        return row;
    }

    function _iDivider() {
        const d = document.createElement('div');
        d.style.cssText = 'height:1px;background:rgba(26,31,46,0.8);margin:1px 0;';
        return d;
    }

    function _iSectionLabel(text) {
        const s = document.createElement('div');
        s.style.cssText = 'font-size:9px;color:#5a6178;text-transform:uppercase;letter-spacing:0.06em;margin-top:2px;';
        s.textContent = text;
        return s;
    }

    function _iColor(value, onChange) {
        const wrap = document.createElement('div');
        wrap.style.cssText = 'width:54px;height:22px;border-radius:4px;overflow:hidden;border:1px solid #1a1f2e;cursor:pointer;flex-shrink:0;transition:border-color 0.2s;';
        wrap.onmouseover = () => wrap.style.borderColor = '#3b82f6';
        wrap.onmouseout  = () => wrap.style.borderColor = '#1a1f2e';
        const inp = document.createElement('input');
        inp.type = 'color';
        inp.value = value;
        inp.style.cssText = 'border:none;width:200%;height:200%;transform:translate(-25%,-25%);cursor:pointer;background:none;';
        inp.addEventListener('input', e => onChange(e.target.value));
        wrap.appendChild(inp);
        return wrap;
    }

    function _iSlider(value, min, max, step, format, onChange) {
        const wrap = document.createElement('div');
        wrap.style.cssText = 'display:flex;align-items:center;gap:6px;flex:1;min-width:0;';
        const inp = document.createElement('input');
        inp.type = 'range';
        inp.min = min; inp.max = max; inp.step = step; inp.value = value;
        inp.style.cssText = 'flex:1;min-width:0;';
        const val = document.createElement('span');
        val.style.cssText = 'font-size:10px;color:#3b82f6;min-width:36px;text-align:right;flex-shrink:0;';
        val.textContent = format(value);
        inp.addEventListener('input', e => { val.textContent = format(e.target.value); onChange(parseFloat(e.target.value)); });
        wrap.appendChild(inp);
        wrap.appendChild(val);
        return wrap;
    }

    function _iSelect(options, value, onChange) {
        const sel = document.createElement('select');
        sel.style.cssText = 'background:#0a0e1a;border:1px solid #1a1f2e;color:#e8eaed;font-family:"JetBrains Mono",monospace;font-size:10px;border-radius:4px;padding:3px 6px;cursor:pointer;flex-shrink:0;';
        options.forEach(o => {
            const opt = document.createElement('option');
            opt.value = o.v; opt.textContent = o.l;
            if (o.v === value) opt.selected = true;
            sel.appendChild(opt);
        });
        sel.addEventListener('change', e => onChange(e.target.value));
        return sel;
    }

    function _iToggle(checked, onChange) {
        const sw = document.createElement('div');
        sw.style.cssText = `width:36px;height:20px;background:${checked ? '#3b82f6' : '#1a1f2e'};
            border-radius:10px;cursor:pointer;position:relative;transition:background 0.2s;flex-shrink:0;`;
        const knob = document.createElement('div');
        knob.style.cssText = `position:absolute;top:2px;left:${checked ? '16' : '2'}px;
            width:16px;height:16px;background:white;border-radius:50%;transition:left 0.2s;
            box-shadow:0 1px 3px rgba(0,0,0,0.3);`;
        sw.appendChild(knob);
        let state = checked;
        sw.addEventListener('click', () => {
            state = !state;
            sw.style.background = state ? '#3b82f6' : '#1a1f2e';
            knob.style.left = state ? '16px' : '2px';
            onChange(state);
        });
        return sw;
    }

    function getIC() {
        if (selectedPanelId === 0) return config;
        return extraPanels.find(p => p.id === selectedPanelId) || config;
    }

    function invalidateTpoCache() {
        if (selectedPanelId === 0) { tpoCacheKey = ''; } 
        else { const p = extraPanels.find(p => p.id === selectedPanelId); if (p) p.tpoCacheKey = ''; }
    }

    function _menuOI(body) {
        const ic = getIC();
        body.appendChild(_iRow('Up Color',     _iColor(ic.oiUpColor,    v => { getIC().oiUpColor    = v; scheduleDraw(); })));
        body.appendChild(_iRow('Down Color',   _iColor(ic.oiDownColor,  v => { getIC().oiDownColor  = v; scheduleDraw(); })));
        body.appendChild(_iRow('Border Color', _iColor(ic.oiBorderColor,v => { getIC().oiBorderColor= v; scheduleDraw(); })));
        body.appendChild(_iRow('Opacity', _iSlider(Math.round(ic.oiOpacity * 100), 10, 100, 5, v => v + '%', v => { getIC().oiOpacity = v / 100; scheduleDraw(); })));
    }

    function _menuCVD(body) {
        const ic = getIC();
        body.appendChild(_iSectionLabel('Line Color'));
        const autoRow = _iRow('Auto (up/down)', _iToggle(ic.cvdLineColor === 'auto', on => {
            getIC().cvdLineColor = on ? 'auto' : '#3b82f6';
            colorWrap.style.opacity       = on ? '0.3' : '1';
            colorWrap.style.pointerEvents = on ? 'none' : 'auto';
            scheduleDraw();
        }));
        body.appendChild(autoRow);
        const colorWrap = document.createElement('div');
        const isAuto    = ic.cvdLineColor === 'auto';
        colorWrap.style.opacity       = isAuto ? '0.3' : '1';
        colorWrap.style.pointerEvents = isAuto ? 'none' : 'auto';
        const colorCtrl = _iColor(isAuto ? '#3b82f6' : ic.cvdLineColor, v => { if (getIC().cvdLineColor !== 'auto') { getIC().cvdLineColor = v; scheduleDraw(); } });
        colorWrap.appendChild(colorCtrl);
        body.appendChild(_iRow('Custom Color', colorWrap));
        body.appendChild(_iDivider());
        body.appendChild(_iRow('Thickness', _iSlider(ic.cvdLineThickness, 1, 5, 0.5, v => v + 'px', v => { getIC().cvdLineThickness = v; scheduleDraw(); })));
    }

    function _menuBarStats(body) {
        const ic = getIC();
        body.appendChild(_iRow('Positive Color', _iColor(ic.barStatsUpColor,   v => { getIC().barStatsUpColor   = v; scheduleDraw(); })));
        body.appendChild(_iRow('Negative Color', _iColor(ic.barStatsDownColor, v => { getIC().barStatsDownColor = v; scheduleDraw(); })));
    }

    function _menuTPO(body) {
        const ic = getIC();
        body.appendChild(_iRow('Tick Size ($)', _iSlider(ic.tpoTickSize, 10, 500, 10, v => '$' + v, v => { getIC().tpoTickSize = v; invalidateTpoCache(); scheduleDraw(); })));
        body.appendChild(_iRow('Block Width', _iSlider(ic.tpoBlockWidth, 3, 24, 1, v => v + 'px', v => { getIC().tpoBlockWidth = v; scheduleDraw(); })));
        body.appendChild(_iDivider());
        body.appendChild(_iSectionLabel('Opacity'));
        body.appendChild(_iRow('Value Area', _iSlider(Math.round(ic.tpoOpacityVA * 100), 10, 100, 5, v => v + '%', v => { getIC().tpoOpacityVA = v / 100; scheduleDraw(); })));
        body.appendChild(_iRow('Non-VA', _iSlider(Math.round(ic.tpoOpacityNonVA * 100), 5, 80, 5, v => v + '%', v => { getIC().tpoOpacityNonVA = v / 100; scheduleDraw(); })));
        body.appendChild(_iDivider());
        body.appendChild(_iSectionLabel('Colors'));
        body.appendChild(_iRow('Value Area',   _iColor(ic.tpoColorVA,     v => { getIC().tpoColorVA     = v; scheduleDraw(); })));
        body.appendChild(_iRow('Non-VA',       _iColor(ic.tpoColorNonVA,  v => { getIC().tpoColorNonVA  = v; scheduleDraw(); })));
        body.appendChild(_iRow('Single Print', _iColor(ic.tpoColorSingle, v => { getIC().tpoColorSingle = v; scheduleDraw(); })));
        body.appendChild(_iRow('POC Border',   _iColor(ic.tpoColorPOC,    v => { getIC().tpoColorPOC    = v; scheduleDraw(); })));
    }

    function _menuVWAP(body) {
        const ic = getIC();
        body.appendChild(_iRow('Color', _iColor(ic.vwapColor, v => { getIC().vwapColor = v; scheduleDraw(); })));
        body.appendChild(_iRow('Line Style', _iSelect([{ v:'solid', l:'â”€â”€â”€â”€ Solid' }, { v:'dashed', l:'- - - Dashed' }, { v:'dotted', l:'Â·Â·Â· Dotted' }], ic.vwapLineStyle, v => { getIC().vwapLineStyle = v; scheduleDraw(); })));
        body.appendChild(_iDivider());
        body.appendChild(_iSectionLabel('Labels'));
        body.appendChild(_iRow('Show "VWAP"', _iToggle(ic.vwapShowLabel, v => { getIC().vwapShowLabel = v; scheduleDraw(); })));
        body.appendChild(_iRow('Show Price',  _iToggle(ic.vwapShowPrice, v => { getIC().vwapShowPrice = v; scheduleDraw(); })));
    }

    function _menuLevels(body) {
        const ic = getIC();
        body.appendChild(_iRow('Color', _iColor(ic.levelsColor, v => { getIC().levelsColor = v; scheduleDraw(); })));
        body.appendChild(_iRow('Line Style', _iSelect([{ v:'solid', l:'â”€â”€â”€â”€ Solid' }, { v:'dashed', l:'- - - Dashed' }, { v:'dotted', l:'Â·Â·Â· Dotted' }], ic.levelsLineStyle, v => { getIC().levelsLineStyle = v; scheduleDraw(); })));
        body.appendChild(_iDivider());
        body.appendChild(_iSectionLabel('Visible Levels'));
        const LABELS = { dOpen:'Day Open', dHigh:'Day High', dLow:'Day Low', dEQ:'Day EQ', pdHigh:'Prev High', pdLow:'Prev Low', pdEQ:'Prev EQ' };
        Object.entries(LABELS).forEach(([key, label]) => { body.appendChild(_iRow(label, _iToggle(ic.levelsEnabled[key], v => { getIC().levelsEnabled[key] = v; scheduleDraw(); }))); });
    }

    let _indCtxActive = null;

    function showIndicatorCtxMenu(id, anchorEl) {
        const menu  = document.getElementById('indicator-ctx-menu');
        const title = document.getElementById('ind-ctx-title');
        const body  = document.getElementById('ind-ctx-body');

        const NAMES = { oi: 'Open Interest', cvd: 'Volume Delta', barstats: 'Bar Statistics', tpo: 'TPO / Market Profile', vwap: 'VWAP', dailylevels: 'Key Levels' };
        title.textContent = NAMES[id] || id;
        body.innerHTML = '';

        switch (id) {
            case 'oi':         _menuOI(body);         break;
            case 'cvd':        _menuCVD(body);        break;
            case 'barstats':   _menuBarStats(body);   break;
            case 'tpo':        _menuTPO(body);        break;
            case 'vwap':       _menuVWAP(body);       break;
            case 'dailylevels': _menuLevels(body);    break;
        }

        _indCtxActive = id;
        menu.style.display = 'block';

        const rect = anchorEl.getBoundingClientRect();
        const mw   = menu.offsetWidth  || 252;
        const mh   = menu.offsetHeight || 300;
        let left = rect.left;
        let top  = rect.bottom + 6;
        if (left + mw > window.innerWidth  - 8) left = window.innerWidth  - mw - 8;
        if (top  + mh > window.innerHeight - 8) top  = rect.top - mh - 6;
        menu.style.left = left + 'px';
        menu.style.top  = top  + 'px';
    }

    function hideIndicatorCtxMenu() {
        document.getElementById('indicator-ctx-menu').style.display = 'none';
        _indCtxActive = null;
    }

    ['oi', 'cvd', 'barstats', 'tpo', 'vwap', 'dailylevels'].forEach(id => {
        const btn = document.getElementById(`toggle-${id}`);
        if (!btn) return;
        btn.addEventListener('contextmenu', e => { e.preventDefault(); e.stopPropagation(); showIndicatorCtxMenu(id, btn); });
    });

    document.addEventListener('mousedown', e => {
        const menu = document.getElementById('indicator-ctx-menu');
        if (menu && menu.style.display !== 'none' && !menu.contains(e.target)) hideIndicatorCtxMenu();
    });

    document.getElementById('ind-ctx-close').addEventListener('click', hideIndicatorCtxMenu);
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Core Drawing & Data Processing
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    function hexToRgba(hex, alpha) {
        if (!hex || hex.length < 7) return `rgba(100,100,100,${alpha})`;
        const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    function calculateCellOpacity(totalVolume) {
        if (totalVolume < 50000) return 0.10;
        else if (totalVolume < 250000) { const t=(totalVolume-50000)/200000; return 0.40+t*0.20; }
        else if (totalVolume < 1000000) { const t=(totalVolume-250000)/750000; return 0.60+t*0.10; }
        else if (totalVolume < 1200000) { const t=(totalVolume-1000000)/200000; return 0.70+t*0.30; }
        else return 1.0;
    }

    function createSeries(type) {
        if (mainSeries) { try { chart.removeSeries(mainSeries); } catch(e){} mainSeries = null; }
        const options = { upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', borderVisible:false, wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)', priceLineVisible:config.showPriceLine, lastValueVisible:false, priceLineColor: config.upColor, priceLineWidth: 1, priceLineStyle: 2 };
        mainSeries = (type==='candle') ? chart.addCandlestickSeries(options) : chart.addBarSeries(options);
        return mainSeries;
    }

    function updateCandleAppearance() {
        const lastCandle = displayCandles[displayCandles.length - 1];
        const lineColor = (lastCandle && lastCandle.close >= lastCandle.open) ? config.upColor : config.downColor;
        mainSeries.applyOptions({ upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)', priceLineVisible:config.showPriceLine, lastValueVisible:false, priceLineColor: lineColor, priceLineWidth: 1, priceLineStyle: 2 });
    }

    function setupBuffersForSize() {
        if (!activeWrapperEl) return;
        const dpr = window.devicePixelRatio||1;
        const chartW = activeWrapperEl.clientWidth, chartH = activeWrapperEl.clientHeight;
        chartOverlayCanvas.width = Math.floor(chartW*dpr); chartOverlayCanvas.height = Math.floor(chartH*dpr);
        chartOverlayCanvas.style.width = chartW+'px'; chartOverlayCanvas.style.height = chartH+'px';
        offscreenCanvas.width = chartOverlayCanvas.width; offscreenCanvas.height = chartOverlayCanvas.height;
        offscreenCtx.setTransform(dpr,0,0,dpr,0,0); ctxOverlay.setTransform(1,0,0,1,0,0);
    }

    function formatUSD(val) {
        if (val===0) return '0'; const abs=Math.abs(val);
        if (abs>=1000000) return (val/1000000).toFixed(1)+'M';
        if (abs>=1000) return (val/1000).toFixed(0)+'K';
        return Math.round(val).toString();
    }

    function upsertCandle(tsSec,o,h,l,c,v=0) {
        if (!base5mCandles) base5mCandles=[];
        const key=Math.floor(tsSec); let found=false;
        for (let i=base5mCandles.length-1; i>=0; i--) {
            if (Math.floor(base5mCandles[i].time)===key) {
                base5mCandles[i].open=o; base5mCandles[i].high=h; base5mCandles[i].low=l; base5mCandles[i].close=c; base5mCandles[i].volume=v; found=true; break;
            }
        }
        if (!found) {
            const prevOI = base5mCandles.length>0 ? (base5mCandles[base5mCandles.length-1].oiClose||0) : 0;
            base5mCandles.push({ time:key, open:o, high:h, low:l, close:c, volume:v, oiOpen:prevOI, oiHigh:prevOI, oiLow:prevOI, oiClose:prevOI });
            base5mCandles.sort((a,b)=>a.time-b.time);

            // â”€â”€ Memory cap: evict oldest candles and their cluster data â”€â”€â”€â”€â”€â”€
            const MAX_CANDLES = 1500;
            if (base5mCandles.length > MAX_CANDLES) {
                const pruned = base5mCandles.splice(0, base5mCandles.length - MAX_CANDLES);
                pruned.forEach(c => delete base5mClusters[String(c.time)]);
            }
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        }
    }

    function getDynamicTickSize(baseTick, minPx) {
        const y1=mainSeries.priceToCoordinate(currentPrice), y2=mainSeries.priceToCoordinate(currentPrice+baseTick);
        if (y1===null||y2===null) return baseTick*2;
        const pxPerBase=Math.abs(y1-y2);
        const multipliers=[1,2,3,4,5,6,7,8,9,10,12,14,16,18,20,25,30,40,50,60,80,100,200];
        for (let m of multipliers) { if (pxPerBase*m>=minPx) return baseTick*m; }
        return baseTick*500;
    }

    function updateCustomPriceLabel() {
        if (!config.showPriceLabel||!mainSeries||!currentPrice||!activePriceLabelEl) { if(activePriceLabelEl) activePriceLabelEl.style.display='none'; return; }
        const yCoord=mainSeries.priceToCoordinate(currentPrice);
        if (yCoord===null) { activePriceLabelEl.style.display='none'; return; }
        const marginB=chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY=activeWrapperEl.clientHeight*(1-marginB);
        if (yCoord<0||yCoord>candleBottomY) { activePriceLabelEl.style.display='none'; return; }
        
        const lastCandle=displayCandles[displayCandles.length-1];
        const isUp=lastCandle?(lastCandle.close>=lastCandle.open):true;
        const color=isUp?config.upColor:config.downColor;
        
        activePriceLabelEl.style.display='flex'; 
        activePriceLabelEl.style.top=(yCoord-13)+'px';
        activePriceLabelEl.style.fontFamily=config.statsFontFamily; 
        activePriceLabelEl.style.fontSize=config.priceLabelFontSize+'px';
        
        const priceText=currentPrice.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
        const nowSec = Math.floor(Date.now()/1000);
        const barSeconds = getBarSeconds(config.displayTimeframe);
        const diff = (lastBarTime + barSeconds) - nowSec;
        const timerStr = (diff > 0) ? formatTime(diff) : "0:00";
        const solidBg = hexToRgba(color, 0.85);
        
        activePriceLabelEl.innerHTML = `<div class="price-label-box" style="background:${solidBg};color:#ffffff;font-size:${config.priceLabelFontSize}px;align-items:center;">
            <span style="font-weight:700;letter-spacing:0.01em;line-height:1.2;">${priceText}</span>
            ${config.showCountdown ? `<span style="font-size:${config.timerFontSize}px;opacity:0.88;line-height:1.2;text-align:center;width:100%;">${timerStr}</span>` : ''}
        </div>`;
    }

    function drawDailyLevels(cssWidth, candleBottomY) {
        if (!config.showDailyLevels || !displayCandles || displayCandles.length === 0) return;

        const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
        const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
        const timeScale = chart.timeScale();

        const now            = new Date();
        const todayStart     = Math.floor(new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate())).getTime() / 1000);
        const yesterdayStart = todayStart - 86400;

        let dOpen = null, dHigh = -Infinity, dLow = Infinity;
        let pdHigh = -Infinity, pdLow = Infinity;

        for (const c of displayCandles) {
            if (c.time >= todayStart) {
                if (dOpen === null) dOpen = c.open;
                if (c.high > dHigh) dHigh = c.high;
                if (c.low  < dLow)  dLow  = c.low;
            } else if (c.time >= yesterdayStart) {
                if (c.high > pdHigh) pdHigh = c.high;
                if (c.low  < pdLow)  pdLow  = c.low;
            }
        }

        const dEQ  = (dHigh  > -Infinity && dLow  < Infinity) ? (dHigh  + dLow)  / 2 : null;
        const pdEQ = (pdHigh > -Infinity && pdLow < Infinity) ? (pdHigh + pdLow) / 2 : null;

        const todayFirstCandle = displayCandles.find(c => c.time >= todayStart);
        const todayX = todayFirstCandle ? (timeScale.timeToCoordinate(todayFirstCandle.time) ?? 0) : 0;
        const pdFirstCandle = displayCandles.find(c => c.time >= yesterdayStart && c.time < todayStart);
        const pdX = pdFirstCandle ? (timeScale.timeToCoordinate(pdFirstCandle.time) ?? 0) : 0;

        const levels = [
            { value: dOpen,                               label: 'dOpen',  startX: todayX },
            { value: dHigh  > -Infinity ? dHigh  : null,  label: 'dHigh',  startX: todayX },
            { value: dLow   < Infinity  ? dLow   : null,  label: 'dLow',   startX: todayX },
            { value: dEQ,                                 label: 'dEQ',    startX: todayX },
            { value: pdHigh > -Infinity ? pdHigh : null,  label: 'pdHigh', startX: pdX    },
            { value: pdLow  < Infinity  ? pdLow  : null,  label: 'pdLow',  startX: pdX    },
            { value: pdEQ,                                label: 'pdEQ',   startX: pdX    },
        ];

        const lineColor  = hexToRgba(config.levelsColor, 0.75);
        const labelColor = hexToRgba(config.levelsColor, 0.92);
        const GAP        = 6;

        offscreenCtx.save();
        offscreenCtx.font         = "600 9px 'JetBrains Mono', monospace";
        offscreenCtx.textBaseline = 'middle';
        offscreenCtx.lineWidth    = 1;
        offscreenCtx.strokeStyle  = lineColor;
        offscreenCtx.fillStyle    = labelColor;
        const dash = getLineDash(config.levelsLineStyle);

        levels.forEach(({ value, label, startX }) => {
            if (!config.levelsEnabled[label]) return;
            if (value === null || value === undefined) return;
            const y = mainSeries.priceToCoordinate(value);
            if (y === null || y < 0 || y > candleBottomY) return;
            const lineStart = Math.max(0, startX);
            if (lineStart >= drawWidth) return;

            const labelWidth = offscreenCtx.measureText(label).width;
            const labelX     = drawWidth - labelWidth - 12;
            if (labelX <= lineStart + 20) return;

            const labelLeft  = labelX - GAP;
            const labelRight = labelX + labelWidth + GAP;

            offscreenCtx.setLineDash(dash);
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(lineStart, y);
            offscreenCtx.lineTo(labelLeft, y);
            offscreenCtx.stroke();
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(labelRight, y);
            offscreenCtx.lineTo(drawWidth,  y);
            offscreenCtx.stroke();
            offscreenCtx.setLineDash([]);
            offscreenCtx.fillText(label, labelX, y);
        });
        offscreenCtx.restore();
    }

    function drawCumulativeCluster(cssWidth, cssHeight, candleBottomY) {
        if (config.hideFootprints) return;
        const timeScale=chart.timeScale(); const barSpacing=timeScale.options().barSpacing;
        const visibleRange=timeScale.getVisibleLogicalRange(); if (!visibleRange) return;
        const renderTickSize=getDynamicTickSize(config.baseTickSize,config.minCellHeight);
        const clusterWidth=barSpacing*2*0.92;
        let rightmostX=0, rightmostTime=0;
        for (let i=displayCandles.length-1; i>=0; i--) {
            const candle=displayCandles[i]; const x=timeScale.timeToCoordinate(candle.time);
            if (x!==null&&x>=0&&x<=cssWidth&&candle.time>rightmostTime) { rightmostTime=candle.time; rightmostX=x; }
        }
        if (rightmostX===0&&displayCandles.length>0) { const x=timeScale.timeToCoordinate(displayCandles[displayCandles.length-1].time); if (x!==null) rightmostX=x; }
        let clusterX=rightmostX+150;
        if (clusterX+clusterWidth>cssWidth-75) clusterX=cssWidth-75-clusterWidth;
        if (clusterX<0) return;
        let aggregatedData={}, totalBuy=0, totalSell=0;
        Object.keys(displayClusters).forEach(timestamp => {
            const ts=parseInt(timestamp); const x=timeScale.timeToCoordinate(ts);
            if (config.cumulativeMode==='visible' && (x===null||x<-100||x>cssWidth+100)) return;
            const rawClusters=displayClusters[timestamp];
            Object.keys(rawClusters).forEach(priceKey => {
                const price=parseFloat(priceKey); const data=rawClusters[priceKey];
                const aggPrice=Math.floor(price/renderTickSize)*renderTickSize;
                if (!aggregatedData[aggPrice]) aggregatedData[aggPrice]={buy:0,sell:0};
                aggregatedData[aggPrice].buy+=data.buy; aggregatedData[aggPrice].sell+=data.sell;
                totalBuy+=data.buy; totalSell+=data.sell;
            });
        });
        if (Object.keys(aggregatedData).length===0) return;
        let pocBucketKey=null, pocTotal=-Infinity;
        Object.keys(aggregatedData).forEach(pk => { const t=aggregatedData[pk].buy+aggregatedData[pk].sell; if (t>pocTotal){pocTotal=t;pocBucketKey=pk;} });
        let minPrice=Infinity, maxPrice=-Infinity;
        Object.keys(aggregatedData).forEach(pk => { const p=parseFloat(pk); if(p<minPrice)minPrice=p; if(p>maxPrice)maxPrice=p; });
        const yTop=mainSeries.priceToCoordinate(maxPrice+renderTickSize), yBottom=mainSeries.priceToCoordinate(minPrice);
        if (yTop===null||yBottom===null) return;
        let clippedYTop, clippedYBottom, clusterBoxHeight, clusterBoxY;
        if (config.cumulativeMode==='all') {
            clippedYTop=yTop; clippedYBottom=yBottom;
            clusterBoxHeight=Math.abs(clippedYBottom-clippedYTop); clusterBoxY=Math.min(clippedYTop,clippedYBottom);
        } else {
            clippedYTop=Math.max(0,Math.min(yTop,candleBottomY)); clippedYBottom=Math.max(0,Math.min(yBottom,candleBottomY));
            if (clippedYTop>=candleBottomY) return;
            clusterBoxHeight=Math.abs(clippedYBottom-clippedYTop); clusterBoxY=Math.min(clippedYTop,clippedYBottom);
        }
        offscreenCtx.fillStyle=hexToRgba(config.panelColor,config.clusterBgOpacity);
        offscreenCtx.fillRect(clusterX,clusterBoxY,clusterWidth,clusterBoxHeight);
        offscreenCtx.strokeStyle='#1a1f2e'; offscreenCtx.lineWidth=config.cellBorderWidth;
        offscreenCtx.strokeRect(clusterX,clusterBoxY,clusterWidth,clusterBoxHeight);
        offscreenCtx.font=`${config.cellFontWeight} ${config.cellFontSize}px ${config.statsFontFamily}`;
        offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";
        Object.keys(aggregatedData).forEach(priceKey => {
            const priceFloor=parseFloat(priceKey); const data=aggregatedData[priceKey];
            let cellYTop=mainSeries.priceToCoordinate(priceFloor+renderTickSize);
            let cellYBottom=mainSeries.priceToCoordinate(priceFloor);
            if (cellYTop===null||cellYBottom===null) return;
            if (config.cumulativeMode==='visible') {
                cellYTop=Math.max(0,Math.min(cellYTop,candleBottomY)); cellYBottom=Math.max(0,Math.min(cellYBottom,candleBottomY));
                if (cellYTop>=candleBottomY) return;
            }
            const heightCell=Math.abs(cellYBottom-cellYTop); const drawY=Math.min(cellYTop,cellYBottom);
            const delta=data.buy-data.sell; const totalVolume=data.buy+data.sell;
            const isBullish=delta>=0;
            const cellColor=isBullish?config.upColor:config.downColor;
            const cellOpacity=calculateCellOpacity(totalVolume);
            offscreenCtx.fillStyle=hexToRgba(cellColor,cellOpacity);
            offscreenCtx.fillRect(clusterX,drawY,clusterWidth,heightCell);
            if (String(priceKey)===String(pocBucketKey)) {
                offscreenCtx.strokeStyle=config.pocColor; offscreenCtx.lineWidth=config.pocBorderWidth;
                offscreenCtx.strokeRect(clusterX,drawY,clusterWidth,heightCell);
            }
            if (heightCell>14) { offscreenCtx.fillStyle='#ffffff'; offscreenCtx.fillText(formatUSD(delta),clusterX+(clusterWidth/2),drawY+(heightCell/2)); }
        });
        const totalDelta=totalBuy-totalSell, statsY=clusterBoxY-25;
        const shouldShowStats=config.cumulativeMode==='all'||(statsY>0&&statsY<candleBottomY);
        if (shouldShowStats) {
            const deltaColor=totalDelta>=0?config.upColor:config.downColor;
            const centerX=clusterX+(clusterWidth/2);
            offscreenCtx.font=`${config.statsFontWeight} ${config.statsFontSize}px ${config.statsFontFamily}`; offscreenCtx.textAlign='center';
            offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText(`V:${formatUSD(totalBuy+totalSell)}`,centerX,statsY-8);
            const deltaValue=formatUSD(totalDelta);
            const dW=offscreenCtx.measureText('D:').width, dvW=offscreenCtx.measureText(deltaValue).width;
            offscreenCtx.textAlign='left';
            offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText('D:',centerX-(dW+dvW)/2,statsY+8);
            offscreenCtx.fillStyle=deltaColor; offscreenCtx.fillText(deltaValue,centerX-(dW+dvW)/2+dW,statsY+8);
            offscreenCtx.textAlign='center';
        }
    }

    function syncHeaderButtons() {
        const isMain = selectedPanelId === 0;
        const panel  = isMain ? null : extraPanels.find(p => p.id === selectedPanelId);
        const mgr    = isMain ? indicatorManager : panel?.indicatorManager;

        const oiActive = mgr?.getIndicator('oi')?.visible ?? false;
        document.getElementById('toggle-oi').classList.toggle('active', oiActive);
        const cvdActive = mgr?.getIndicator('cvd')?.visible ?? false;
        document.getElementById('toggle-cvd').classList.toggle('active', cvdActive);
        const bsActive = mgr?.getIndicator('barstats')?.visible ?? false;
        document.getElementById('toggle-barstats').classList.toggle('active', bsActive);

        const tpoActive = isMain ? config.showTPO : (panel?.showTPO ?? false);
        document.getElementById('toggle-tpo').classList.toggle('active', tpoActive);
        const tpoSwitch = document.getElementById('toggle-tpo-switch');
        if (tpoSwitch) tpoSwitch.classList.toggle('active', tpoActive);

        const vwapActive = isMain ? config.vwapVisible : (panel?.vwapVisible ?? false);
        document.getElementById('toggle-vwap').classList.toggle('active', vwapActive);

        const levelsActive = isMain ? config.showDailyLevels : (panel?.showDailyLevels ?? false);
        document.getElementById('toggle-dailylevels').classList.toggle('active', levelsActive);
    }

    function drawFrames() {
        if (clustersDirty) {
            displayClusters = aggregateClusters(base5mClusters, config.displayTimeframe);
            extraPanels.forEach(p => { p.displayClusters = aggregateClusters(base5mClusters, p.displayTimeframe); });
            clustersDirty = false;
        }
        if (!offscreenCtx || !chartOverlayCanvas) return;
        const cssWidth = chartOverlayCanvas.clientWidth, cssHeight = chartOverlayCanvas.clientHeight;
        const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
        const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
        
        offscreenCtx.clearRect(0,0,cssWidth,cssHeight);
        offscreenCtx.save();
        offscreenCtx.beginPath();
        offscreenCtx.rect(0, 0, drawWidth, cssHeight);
        offscreenCtx.clip();
        
        const timeScale=chart.timeScale(), barSpacing=timeScale.options().barSpacing;
        const visibleRange=timeScale.getVisibleLogicalRange();
        if (!visibleRange) { ctxOverlay.clearRect(0,0,cssWidth,cssHeight); ctxOverlay.drawImage(offscreenCanvas,0,0); return; }

        const renderTickSize=getDynamicTickSize(config.baseTickSize,config.minCellHeight);
        document.getElementById('tick-display').innerText=`${renderTickSize}`;
        const marginB=chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY=cssHeight*(1-marginB);
        const totalWidth=barSpacing*0.92, candleWidth=totalWidth*config.candleWidthPercent, clusterWidth=totalWidth*config.clusterWidthPercent;
        const timestamps=Object.keys(displayClusters);

        offscreenCtx.lineWidth=config.gridLineWidth; offscreenCtx.strokeStyle=hexToRgba(config.gridColor,config.gridOpacity);
        offscreenCtx.beginPath();
        const approxRange=60000;
        const startPrice=Math.floor(currentPrice/config.gridSpacing)*config.gridSpacing-approxRange;
        const endPrice=Math.floor(currentPrice/config.gridSpacing)*config.gridSpacing+approxRange;
        for (let p=startPrice; p<=endPrice; p+=config.gridSpacing) {
            const y=mainSeries.priceToCoordinate?mainSeries.priceToCoordinate(p):null;
            if (y!==null&&y>=0&&y<=candleBottomY) { offscreenCtx.moveTo(0,y); offscreenCtx.lineTo(cssWidth-60,y); }
        }
        offscreenCtx.stroke();

        drawTPO(cssWidth, candleBottomY);
        drawVWAP(cssWidth, candleBottomY);
        drawDailyLevels(cssWidth, candleBottomY);

        displayCandles.forEach(candle => {
            const x=timeScale.timeToCoordinate(candle.time);
            if (x===null||x<-100||x>cssWidth+100) return;
            const openY=mainSeries.priceToCoordinate(candle.open), closeY=mainSeries.priceToCoordinate(candle.close);
            const highY=mainSeries.priceToCoordinate(candle.high), lowY=mainSeries.priceToCoordinate(candle.low);
            if (openY===null||closeY===null||highY===null||lowY===null) return;
            const clippedHighY=Math.max(0,highY), clippedLowY=Math.min(candleBottomY,lowY);
            const clippedOpenY=Math.min(candleBottomY,Math.max(0,openY)), clippedCloseY=Math.min(candleBottomY,Math.max(0,closeY));
            if (clippedHighY>candleBottomY) return;
            const isUp=candle.close>=candle.open, color=isUp?config.upColor:config.downColor;
            const colorWithOpacity=hexToRgba(color,config.candleOpacity);
            const startX=x-(totalWidth/2), candleX=startX;
            offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=config.wickThickness;
            offscreenCtx.beginPath(); offscreenCtx.moveTo(candleX+candleWidth/2,clippedHighY); offscreenCtx.lineTo(candleX+candleWidth/2,clippedLowY); offscreenCtx.stroke();
            const bodyTop=Math.min(clippedOpenY,clippedCloseY), bodyHeight=Math.max(1,Math.abs(clippedCloseY-clippedOpenY));
            if (config.seriesType==='candle') {
                offscreenCtx.fillStyle=colorWithOpacity; offscreenCtx.fillRect(candleX,bodyTop,candleWidth,bodyHeight);
                if (config.borderThickness>0) { offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=config.borderThickness; offscreenCtx.strokeRect(candleX,bodyTop,candleWidth,bodyHeight); }
            } else {
                offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=2;
                offscreenCtx.beginPath(); offscreenCtx.moveTo(candleX,clippedOpenY); offscreenCtx.lineTo(candleX+candleWidth/2,clippedOpenY);
                offscreenCtx.moveTo(candleX+candleWidth/2,clippedCloseY); offscreenCtx.lineTo(candleX+candleWidth,clippedCloseY); offscreenCtx.stroke();
            }
        });

        if (!config.hideFootprints) {
            for (let ti=0; ti<timestamps.length; ti++) {
                const timestamp=timestamps[ti], ts=parseInt(timestamp);
                const x=timeScale.timeToCoordinate(ts);
                if (x===null||x<-100||x>cssWidth+100) continue;
                const rawClusters=displayClusters[timestamp];
                if (!rawClusters||Object.keys(rawClusters).length===0) continue;

                let aggregatedData={};
                Object.keys(rawClusters).forEach(priceKey => {
                    const price=parseFloat(priceKey), data=rawClusters[priceKey];
                    const aggPrice=Math.floor(price/renderTickSize)*renderTickSize;
                    if (!aggregatedData[aggPrice]) aggregatedData[aggPrice]={buy:0,sell:0};
                    aggregatedData[aggPrice].buy+=data.buy; aggregatedData[aggPrice].sell+=data.sell;
                });

                let pocBucketKey=null, pocTotal=-Infinity;
                const aggKeys=Object.keys(aggregatedData);
                aggKeys.forEach(pk => { const t=aggregatedData[pk].buy+aggregatedData[pk].sell; if(t>pocTotal){pocTotal=t;pocBucketKey=pk;} });

                let minPrice=Infinity, maxPrice=-Infinity;
                aggKeys.forEach(pk => { const p=parseFloat(pk); if(p<minPrice)minPrice=p; if(p>maxPrice)maxPrice=p; });

                const yTop=mainSeries.priceToCoordinate(maxPrice+renderTickSize), yBottom=mainSeries.priceToCoordinate(minPrice);
                if (yTop===null||yBottom===null) continue;
                const clippedYTop=Math.max(0,Math.min(yTop,candleBottomY)), clippedYBottom=Math.max(0,Math.min(yBottom,candleBottomY));
                if (clippedYTop>=candleBottomY) continue;

                const clusterBoxH=Math.abs(clippedYBottom-clippedYTop), clusterBoxY2=Math.min(clippedYTop,clippedYBottom);
                const startX=x-(totalWidth/2), boxX=startX+candleWidth, boxWidth=clusterWidth;

                offscreenCtx.fillStyle=hexToRgba(config.panelColor,config.clusterBgOpacity);
                offscreenCtx.fillRect(boxX,clusterBoxY2,boxWidth,clusterBoxH);
                offscreenCtx.strokeStyle='#1a1f2e'; offscreenCtx.lineWidth=config.cellBorderWidth;
                offscreenCtx.strokeRect(boxX,clusterBoxY2,boxWidth,clusterBoxH);
                offscreenCtx.font=`${config.cellFontWeight} ${config.cellFontSize}px ${config.statsFontFamily}`;
                offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";

                for (let pkIdx=0; pkIdx<aggKeys.length; pkIdx++) {
                    const priceKey=aggKeys[pkIdx], priceFloor=parseFloat(priceKey), data=aggregatedData[priceKey];
                    let cellYTop=mainSeries.priceToCoordinate(priceFloor+renderTickSize);
                    let cellYBottom=mainSeries.priceToCoordinate(priceFloor);
                    if (cellYTop===null||cellYBottom===null) continue;
                    cellYTop=Math.max(0,Math.min(cellYTop,candleBottomY)); cellYBottom=Math.max(0,Math.min(cellYBottom,candleBottomY));
                    if (cellYTop>=candleBottomY) continue;

                    const heightCell=Math.abs(cellYBottom-cellYTop), drawY=Math.min(cellYTop,cellYBottom);
                    const delta=data.buy-data.sell, totalVolume=data.buy+data.sell;

                    if (config.clusterVolumeThreshold > 0 && Math.abs(delta) < config.clusterVolumeThreshold) {
                        offscreenCtx.fillStyle = '#485060';
                    } else {
                        const isBullish = delta >= 0;
                        const cellColor = isBullish ? config.upColor : config.downColor;
                        const cellOpacity = calculateCellOpacity(totalVolume);
                        offscreenCtx.fillStyle = hexToRgba(cellColor, cellOpacity);
                    }
                    offscreenCtx.fillRect(boxX,drawY,boxWidth,heightCell);

                    if (String(priceKey)===String(pocBucketKey)) {
                        offscreenCtx.strokeStyle=config.pocColor; offscreenCtx.lineWidth=config.pocBorderWidth;
                        offscreenCtx.strokeRect(boxX,drawY,boxWidth,heightCell);
                    }

                    if (heightCell>14) {
                        offscreenCtx.fillStyle='#ffffff';
                        offscreenCtx.fillText(formatUSD(delta),boxX+(boxWidth/2),drawY+(heightCell/2));
                    }
                }
            }
        }

        drawCumulativeCluster(cssWidth,cssHeight,candleBottomY);

        if (!config.hideFootprints && displayCandles&&config.minBubbleVolume>0) {
            const currentTime=Date.now();
            const pulsePhase=(currentTime%config.bubblePulseSpeed)/config.bubblePulseSpeed;
            const pulseOpacity=0.3+(Math.sin(pulsePhase*Math.PI*2)*0.3);
            displayCandles.forEach(candle => {
                const x=timeScale.timeToCoordinate(candle.time);
                if (x===null||x<-20||x>cssWidth+20) return;
                const tsKey=String(Math.floor(candle.time)), buckets=displayClusters[tsKey];
                if (!buckets) return;
                let totalBuy=0, totalSell=0;
                Object.values(buckets).forEach(d=>{totalBuy+=d.buy;totalSell+=d.sell;});
                const delta=totalBuy-totalSell;
                if (Math.abs(delta)>=config.minBubbleVolume) {
                    const isBullishCandle=candle.close>=candle.open, isDeltaPositive=delta>=0;
                    const statsY=isBullishCandle?mainSeries.priceToCoordinate(candle.high)-45:mainSeries.priceToCoordinate(candle.low)+40;
                    if (statsY<0||statsY>candleBottomY) return;
                    const dotY=isBullishCandle?statsY-30:statsY+30;
                    const barCenterX=(x-(totalWidth/2))+(totalWidth/2);
                    const dotColor=isDeltaPositive?config.upColor:config.downColor;
                    offscreenCtx.save(); offscreenCtx.globalAlpha=pulseOpacity;
                    offscreenCtx.beginPath(); offscreenCtx.arc(barCenterX,dotY,config.bubbleOuterSize,0,Math.PI*2);
                    offscreenCtx.fillStyle=dotColor; offscreenCtx.fill(); offscreenCtx.restore();
                    offscreenCtx.save(); offscreenCtx.beginPath(); offscreenCtx.arc(barCenterX,dotY,config.bubbleInnerSize,0,Math.PI*2);
                    offscreenCtx.fillStyle=dotColor; offscreenCtx.fill(); offscreenCtx.restore();
                }
            });
        }

        if (!config.hideFootprints && displayCandles) {
            offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";
            displayCandles.forEach(candle => {
                const x=timeScale.timeToCoordinate(candle.time);
                if (x===null||x<-50||x>cssWidth+50) return;
                const tsKey=String(Math.floor(candle.time)), buckets=displayClusters[tsKey];
                if (!buckets) return;
                let totalBuy=0, totalSell=0;
                Object.values(buckets).forEach(d=>{totalBuy+=d.buy;totalSell+=d.sell;});
                const totalVol=totalBuy+totalSell, delta=totalBuy-totalSell;
                if (totalVol===0) return;
                const isBullishCandle=candle.close>=candle.open;
                const oiOpen=candle.oiOpen||0, oiClose=candle.oiClose||0, oiIncreasing=oiClose>oiOpen;
                let vwapNum=0, vwapDen=0;
                Object.keys(buckets).forEach(priceKey => {
                    const price=parseFloat(priceKey), vol=buckets[priceKey].buy+buckets[priceKey].sell;
                    vwapNum+=price*vol; vwapDen+=vol;
                });
                const candleVWAP=vwapDen>0?vwapNum/vwapDen:candle.open;
                const isBullishAbsorption=delta<=-config.absorptionThreshold&&candle.close>candleVWAP&&oiIncreasing;
                const isBearishAbsorption=delta>=config.absorptionThreshold&&candle.close<candleVWAP&&oiIncreasing;
                if (isBullishAbsorption||isBearishAbsorption) {
                    const dotY=isBullishAbsorption?mainSeries.priceToCoordinate(candle.low)+25:mainSeries.priceToCoordinate(candle.high)-25;
                    if (dotY>0&&dotY<candleBottomY) {
                        offscreenCtx.save(); offscreenCtx.shadowColor=config.absorptionColor; offscreenCtx.shadowBlur=config.absorptionGlow; offscreenCtx.fillStyle=config.absorptionColor;
                        offscreenCtx.beginPath(); offscreenCtx.arc(x,dotY,config.absorptionDotSize,0,Math.PI*2); offscreenCtx.fill();
                        offscreenCtx.shadowBlur=0; offscreenCtx.strokeStyle="#FFFFFF"; offscreenCtx.lineWidth=1; offscreenCtx.stroke(); offscreenCtx.restore();
                    }
                }

                const indicatorManagerToUse = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
                const _barStatsActive = indicatorManagerToUse?.getIndicator('barstats')?.visible;
                if (!_barStatsActive && !config.hideFootprints) {
                    const statsY=isBullishCandle?mainSeries.priceToCoordinate(candle.high)-45:mainSeries.priceToCoordinate(candle.low)+40;
                    if (statsY>=0&&statsY<=candleBottomY) {
                        const deltaColor=delta>=0?config.upColor:config.downColor;
                        const barCenterX=(x-(totalWidth/2))+(totalWidth/2);
                        offscreenCtx.font=`${config.statsFontWeight} ${config.statsFontSize}px ${config.statsFontFamily}`;
                        offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.textAlign='center';
                        offscreenCtx.fillText(`V:${formatUSD(totalVol)}`,barCenterX,statsY-8);
                        const deltaValue=formatUSD(delta), dW=offscreenCtx.measureText('D:').width, dvW=offscreenCtx.measureText(deltaValue).width;
                        offscreenCtx.textAlign='left';
                        offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText('D:',barCenterX-(dW+dvW)/2,statsY+8);
                        offscreenCtx.fillStyle=deltaColor; offscreenCtx.fillText(deltaValue,barCenterX-(dW+dvW)/2+dW,statsY+8);
                        offscreenCtx.textAlign='center';
                    }
                }
            });
        }
        offscreenCtx.restore(); 
        
        const activeMgr = indicatorManager;
        if (activeMgr) activeMgr.drawAll(cssWidth);

        const timerBox = activeTimerBox;
        if (timerBox && !timerBox.classList.contains('hidden')) {
            timerBox.classList.add('hidden');
            timerBox.style.display = 'none';
        }

        updateCustomPriceLabel();
        updatePaneRight();

        ctxOverlay.clearRect(0, 0, chartOverlayCanvas.width, chartOverlayCanvas.height);
        ctxOverlay.drawImage(offscreenCanvas, 0, 0);
    }

    // â”€â”€ Utilities & WebSockets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function formatTime(seconds) {
        if (seconds>=3600) { const h=Math.floor(seconds/3600), m=Math.floor((seconds%3600)/60); return `${h}:${m.toString().padStart(2,'0')}`; }
        const m=Math.floor(seconds/60), s=seconds%60; return `${m}:${s.toString().padStart(2,'0')}`;
    }
    function getIntervalString(tf) { return {1:'1',3:'3',5:'5',15:'15',30:'30',60:'60',240:'240','D':'D'}[tf]||'5'; }
    function getOIIntervalString(tf) { return {1:'5min',3:'5min',5:'5min',15:'15min',30:'30min',60:'1h',240:'4h','D':'1d'}[tf]||'5min'; }
    function getBarSeconds(tfMinutes) { if (tfMinutes==='D') return 86400; return tfMinutes*60; }
    function getWSInterval(tf) { return {1:'1',3:'3',5:'5',15:'15',30:'30',60:'60',240:'240','D':'D'}[tf]||'5'; }

    async function changeTimeframe(newTF) {
        if (newTF < BASE_TIMEFRAME) { alert(`Footprint information will not migrate to timeframes lower than ${BASE_TIMEFRAME}m`); return; }
        applyTimeframeChange(newTF);
    }

    document.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.addEventListener('click', () => { const tf=btn.getAttribute('data-tf'); changeTimeframe(tf==='D'?1440:parseInt(tf)); });
    });

    const ctxMenuMain=document.getElementById('ctx-menu-main'), settingsPanel=document.getElementById('settings-panel');

    document.addEventListener('click', (e) => { 
        if (!e.target.closest('.context-menu')&&!e.target.closest('#settings-panel')&&!e.target.closest('#header-settings-btn')) 
            ctxMenuMain.classList.add('hidden'); 
    });

    document.getElementById('ctx-reset').onclick = () => {
        if (selectedPanelId === 0) {
            chart.timeScale().scrollToRealTime();
            chart.priceScale('right').applyOptions({ autoScale: true });
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.chart.timeScale().scrollToRealTime();
                panel.chart.priceScale('right').applyOptions({ autoScale: true });
            }
        }
        ctxMenuMain.classList.add('hidden');
    };

    const toggleSettings=()=>{ settingsPanel.classList.toggle('-translate-x-full'); settingsPanel.classList.toggle('translate-x-0'); };
    document.getElementById('header-settings-btn').onclick = toggleSettings;
    document.getElementById('close-settings').onclick = toggleSettings;
    document.getElementById('ctx-settings-trigger').onclick = toggleSettings;

    document.getElementById('ctx-hide-footprints').onclick = () => {
        if (selectedPanelId === 0) {
            config.hideFootprints = !config.hideFootprints;
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) panel.hideFootprints = !panel.hideFootprints;
        }
        const active = selectedPanelId === 0
            ? config.hideFootprints
            : (extraPanels.find(p => p.id === selectedPanelId)?.hideFootprints ?? false);
        document.getElementById('ctx-hide-footprints-indicator').textContent = active ? 'â—' : 'â—‹';
        document.getElementById('ctx-hide-footprints-indicator').style.color = active ? '#3b82f6' : '';
        ctxMenuMain.classList.add('hidden');
        scheduleDraw();
    };

    document.getElementById('cumulative-mode-select').onchange = (e) => { config.cumulativeMode=e.target.value; scheduleDraw(); };
    document.getElementById('series-type-select').onchange = (e) => { config.seriesType=e.target.value; mainSeries=createSeries(config.seriesType); mainSeries.setData(displayCandles); updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('up-candle-color').onchange = (e) => { config.upColor=e.target.value; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('down-candle-color').onchange = (e) => { config.downColor=e.target.value; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('candle-opacity').oninput = (e) => { config.candleOpacity=e.target.value/100; document.getElementById('opacity-val').innerText=e.target.value+'%'; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('grid-spacing-input').onchange = (e) => { config.gridSpacing=parseFloat(e.target.value); scheduleDraw(); };
    document.getElementById('grid-color-input').oninput = (e) => { config.gridColor=e.target.value; scheduleDraw(); };
    document.getElementById('bubble-threshold-input').onchange = (e) => { config.minBubbleVolume=parseFloat(e.target.value); scheduleDraw(); };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Golden Layout Configuration Manager
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function captureCurrentLayout() {
        const panels = [];
        // Save Main Panel
        const mainIndicators = [];
        indicatorManager.indicators.forEach((ind, id) => { if (ind.visible) mainIndicators.push(id); });
        panels.push({
            id: 0,
            timeframe: config.displayTimeframe,
            indicators: mainIndicators,
            hideFootprints: config.hideFootprints,
            showTPO: config.showTPO,
            vwapVisible: config.vwapVisible,
            showDailyLevels: config.showDailyLevels,
            visibleRange: chart.timeScale().getVisibleRange(),
            barSpacing: chart.timeScale().options().barSpacing,
        });

        // Save Extra Panels
        extraPanels.forEach(p => {
            const panelIndicators = [];
            p.indicatorManager.indicators.forEach((ind, id) => { if (ind.visible) panelIndicators.push(id); });
            panels.push({
                id: p.id,
                timeframe: p.displayTimeframe,
                indicators: panelIndicators,
                hideFootprints: p.hideFootprints,
                showTPO: p.showTPO,
                vwapVisible: p.vwapVisible,
                showDailyLevels: p.showDailyLevels,
                visibleRange: p.chart.timeScale().getVisibleRange(),
                barSpacing: p.chart.timeScale().options().barSpacing,
            });
        });

        const glConfig = myLayout.saveLayout();

        return {
            name: `Layout ${Date.now()}`,
            timestamp: Date.now(),
            schemaVersion: 1,       // â† bump this when the panel/glConfig shape changes
            panels,
            glConfig
        };
    }

    function saveLayout() {
        const name = prompt('Name this layout:', `Layout ${new Date().toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' })}`);
        if (!name || name.trim() === '') return;
        const layout = captureCurrentLayout();
        layout.name = name.trim();
        let layouts = getSavedLayouts();
        layouts.push(layout);
        if (layouts.length > 10) layouts = layouts.slice(-10);
        localStorage.setItem('btcChartLayouts', JSON.stringify(layouts));
        renderSavedLayouts();
    }

    function getSavedLayouts() {
        try { const raw = localStorage.getItem('btcChartLayouts'); return raw ? JSON.parse(raw) : []; } 
        catch(e) { return []; }
    }

    function deleteLayout(timestamp) {
        let layouts = getSavedLayouts().filter(l => l.timestamp !== timestamp);
        localStorage.setItem('btcChartLayouts', JSON.stringify(layouts));
        renderSavedLayouts();
    }

    function applyLayout(layout) {
        if (!layout.glConfig) {
            alert('This layout format is from an older version and is incompatible with the new Layout Engine.');
            return;
        }

        // â”€â”€ Schema version guard â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const CURRENT_SCHEMA = 1;
        if (layout.schemaVersion === undefined) {
            // Pre-versioning layout â€” warn but attempt to load
            console.warn('Loading a layout saved before schema versioning was introduced. It may behave unexpectedly.');
        } else if (layout.schemaVersion > CURRENT_SCHEMA) {
            alert(`This layout was saved with a newer version of the app (schema v${layout.schemaVersion}) and cannot be loaded here (current schema v${CURRENT_SCHEMA}). Please update the app.`);
            return;
        }
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    function fixGLSizes(obj) {
            if (!obj || typeof obj !== 'object') return;

            // Row/Col relative sizes â€” GL v2 wants percentage strings
            if (typeof obj.size === 'number')   obj.size   = obj.size   + '%';
            if (typeof obj.width === 'number')  obj.width  = obj.width  + '%';
            if (typeof obj.height === 'number') obj.height = obj.height + '%';

            // Pixel-unit props â€” GL v2 needs strings like "0px", NOT raw numbers.
            // Also covers settings-level defaults that resolveDefaultMinItemHeight
            // reads with .trimStart(), which crashes on numbers or null/undefined.
            const pxProps = [
                'minItemHeight', 'minItemWidth', 'minHeight', 'minWidth',
                'defaultMinItemHeight', 'defaultMinItemWidth'   // â† NEW
            ];
            pxProps.forEach(prop => {
                if (obj[prop] === null || obj[prop] === undefined) {
                    delete obj[prop];           // Let GL use its own built-in default
                } else if (typeof obj[prop] === 'number') {
                    obj[prop] = obj[prop] + 'px';
                }
            });

            // Recurse â€” guard against null values so we don't re-enter on null
            Object.values(obj).forEach(val => {
                if (val && typeof val === 'object') fixGLSizes(val);  // â† added null guard
            });
        }
        fixGLSizes(layout.glConfig);
        // -----------------------------------------

        // 1. Teardown existing extra panels & indicators safely
        [...extraPanels].forEach(p => {
            if (p.rafId) cancelAnimationFrame(p.rafId);
            p.chart.remove();
        });
        extraPanels.length = 0;
        extraPanelCounter = 0;

        ['oi', 'cvd', 'barstats'].forEach(id => {
            const ind = indicatorManager.getIndicator(id);
            if (ind && ind.visible) indicatorManager.removeIndicator(id);
        });

        // 2. Feed the configuration back to Golden Layout. 
        // This triggers the Component Factory synchronously, rebuilding panels 1 by 1.
        myLayout.loadLayout(layout.glConfig);

        // 3. Restore Main Panel state
        const mainLayout = layout.panels.find(p => p.id === 0);
        if (mainLayout) {
            applyTimeframeChange(mainLayout.timeframe);
            mainLayout.indicators.forEach(id => {
                if      (id === 'oi')       indicatorManager.addIndicator(new OIIndicator());
                else if (id === 'cvd')      indicatorManager.addIndicator(new CVDIndicator());
                else if (id === 'barstats') indicatorManager.addIndicator(new BarStatsIndicator());
            });
            config.hideFootprints  = mainLayout.hideFootprints;
            config.showTPO         = mainLayout.showTPO;
            config.vwapVisible     = mainLayout.vwapVisible;
            config.showDailyLevels = mainLayout.showDailyLevels;
            tpoCacheKey = '';
            
            if (mainLayout.barSpacing) chart.timeScale().applyOptions({ barSpacing: mainLayout.barSpacing });
            if (mainLayout.visibleRange) setTimeout(() => { try { chart.timeScale().setVisibleRange(mainLayout.visibleRange); } catch(e){} }, 50);
        }

        // 4. Restore Extra Panels states (matches by array index since components were added sequentially)
        const extraLayouts = layout.panels.filter(p => p.id !== 0);
        extraPanels.forEach((newPanel, i) => {
            const savedPanel = extraLayouts[i];
            if (!savedPanel) return;

            newPanel.displayTimeframe = savedPanel.timeframe;
            newPanel.displayCandles   = aggregateCandles(base5mCandles, savedPanel.timeframe);
            newPanel.displayClusters  = aggregateClusters(base5mClusters, savedPanel.timeframe);
            newPanel.mainSeries.setData(newPanel.displayCandles);

            savedPanel.indicators.forEach(id => {
                if      (id === 'oi')       newPanel.indicatorManager.addIndicator(new OIIndicator());
                else if (id === 'cvd')      newPanel.indicatorManager.addIndicator(new CVDIndicator());
                else if (id === 'barstats') newPanel.indicatorManager.addIndicator(new BarStatsIndicator());
            });

            newPanel.hideFootprints  = savedPanel.hideFootprints;
            newPanel.showTPO         = savedPanel.showTPO;
            newPanel.vwapVisible     = savedPanel.vwapVisible;
            newPanel.showDailyLevels = savedPanel.showDailyLevels;
            newPanel.tpoCacheKey     = '';

            if (savedPanel.barSpacing) newPanel.chart.timeScale().applyOptions({ barSpacing: savedPanel.barSpacing });
            if (savedPanel.visibleRange) setTimeout(() => { try { newPanel.chart.timeScale().setVisibleRange(savedPanel.visibleRange); } catch(e){} }, 50);
            
            syncPanelTFBar(newPanel, savedPanel.timeframe);
            schedulePanelDraw(newPanel);
        });

        selectedPanelId = 0;
        syncHeaderButtons();
        scheduleDraw();
        closeLayoutsDropdown();
    }

    function renderSavedLayouts() {
        const container = document.getElementById('saved-layouts-list');
        const layouts = getSavedLayouts();
        if (layouts.length === 0) {
            container.innerHTML = '<div class="px-4 py-2 text-[10px] text-gray-600 font-mono italic">No saved layouts yet</div>';
            return;
        }
        container.innerHTML = '';
        [...layouts].reverse().forEach(layout => {
            const row = document.createElement('div');
            row.className = 'group flex items-center justify-between px-4 py-2 hover:bg-blue-600/10 cursor-pointer transition-colors';
            const panelCount = layout.panels.length;
            const timeStr = new Date(layout.timestamp).toLocaleString('ro-RO', { day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit' });
            row.innerHTML = `
                <div class="flex-1 min-w-0" onclick="">
                    <div class="text-[11px] font-mono text-gray-300 group-hover:text-blue-400 transition-colors truncate">${layout.name}</div>
                    <div class="text-[9px] text-gray-600 font-mono mt-0.5">${panelCount} chart${panelCount>1?'s':''} Â· ${timeStr}</div>
                </div>
                <button class="delete-layout-btn ml-2 opacity-0 group-hover:opacity-100 transition-opacity text-gray-600 hover:text-red-400 text-xs p-1 rounded" data-ts="${layout.timestamp}">âœ•</button>
            `;
            row.querySelector('.flex-1').addEventListener('click', () => applyLayout(layout));
            row.querySelector('.delete-layout-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm(`Delete "${layout.name}"?`)) deleteLayout(layout.timestamp);
            });
            container.appendChild(row);
        });
    }

    function syncPanelTFBar(panel, timeframe) {
        const tfBar = panel.wrapperEl.querySelector('.panel-tf-bar');
        if (!tfBar) return;
        tfBar.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.classList.remove('active');
            const tfMap = { '5m': 5, '15m': 15, '30m': 30, '1h': 60, '4h': 240, '1D': 1440 };
            if (tfMap[btn.textContent.trim()] === timeframe) btn.classList.add('active');
        });
    }

    function closeLayoutsDropdown() {
        const dd = document.getElementById('layouts-dropdown');
        dd.classList.remove('open');
        setTimeout(() => dd.classList.add('hidden'), 200);
    }

    document.getElementById('layouts-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const dd = document.getElementById('layouts-dropdown');
        const isOpen = dd.classList.contains('open');
        if (isOpen) { closeLayoutsDropdown(); } 
        else { dd.classList.remove('hidden'); requestAnimationFrame(() => dd.classList.add('open')); renderSavedLayouts(); }
    });

    document.getElementById('save-layout-btn').addEventListener('click', (e) => { e.stopPropagation(); saveLayout(); });
    document.addEventListener('click', (e) => { if (!e.target.closest('#layouts-wrapper')) closeLayoutsDropdown(); });

    // â”€â”€ Boot Sequence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function fetchOpenInterest() {
        try {
            const oiInterval=getOIIntervalString(BASE_TIMEFRAME);
            const resp=await fetch(`https://api.bybit.com/v5/market/open-interest?category=inverse&symbol=BTCUSD&intervalTime=${oiInterval}&limit=200`);
            const oiData=await resp.json();
            if (oiData.result&&oiData.result.list) {
                const oiMap={}, barSec=getBarSeconds(BASE_TIMEFRAME);
                oiData.result.list.forEach(item=>{ const ts=parseInt(item.timestamp)/1000; oiMap[Math.floor(ts/barSec)*barSec]=parseFloat(item.openInterest); });
                let previousOI=0;
                const firstTs=Object.keys(oiMap).sort()[0];
                if (firstTs) previousOI=oiMap[firstTs]/base5mCandles.find(c=>c.time>=firstTs)?.close||0;
                for (let i=0;i<base5mCandles.length;i++) {
                    const c=base5mCandles[i], foundRawOI=oiMap[c.time];
                    if (foundRawOI) {
                        const oiBTC=foundRawOI/c.close;
                        if (previousOI===0) previousOI=oiBTC;
                        c.oiOpen=previousOI; c.oiClose=oiBTC; c.oiHigh=Math.max(previousOI,oiBTC); c.oiLow=Math.min(previousOI,oiBTC); previousOI=oiBTC;
                    } else { c.oiOpen=previousOI; c.oiClose=previousOI; c.oiHigh=previousOI; c.oiLow=previousOI; }
                }
                displayCandles=base5mCandles.slice();
                if (previousOI>0) document.getElementById('oi-display').innerText=previousOI.toFixed(2);
            }
        } catch(e) { console.error("OI Fetch Error",e); }
    }

    function startWebSockets() {
        const wsInterval = getWSInterval(BASE_TIMEFRAME);
        ws = new WebSocket("wss://stream.bybit.com/v5/public/inverse");
        ws.onopen = () => ws.send(JSON.stringify({op:"subscribe",args:[`kline.${wsInterval}.BTCUSD`,"publicTrade.BTCUSD","tickers.BTCUSD"]}));
        ws.onclose = () => { console.warn('WebSocket disconnected, reconnecting in 3s...'); setTimeout(startWebSockets, 3000); };
        ws.onerror = (e) => { console.error('WebSocket error', e); ws.close(); };
        ws.onmessage = (event) => {
            let msg;
            try { msg = JSON.parse(event.data); } catch(e) { console.warn('WS parse error:', e); return; }
            if (!msg.data) return;
            try {
            if (msg.topic&&msg.topic.includes("tickers")&&msg.data.openInterest) {
                const rawOI=parseFloat(msg.data.openInterest), lastCandle=base5mCandles[base5mCandles.length-1];
                if (lastCandle&&currentPrice>0) {
                    const oiBTC=rawOI/currentPrice;
                    document.getElementById('oi-display').innerText=oiBTC.toFixed(2);
                    if (lastCandle.oiOpen===0||!lastCandle.oiOpen) lastCandle.oiOpen=(base5mCandles.length>1)?base5mCandles[base5mCandles.length-2].oiClose:oiBTC;
                    lastCandle.oiClose=oiBTC; lastCandle.oiHigh=Math.max(lastCandle.oiHigh||-Infinity,oiBTC); lastCandle.oiLow=Math.min(lastCandle.oiLow||Infinity,oiBTC);
                    displayCandles=aggregateCandles(base5mCandles,config.displayTimeframe); scheduleDraw();
                }
            }
            if (msg.topic&&msg.topic.includes("kline")) {
                const k=msg.data[0], ts=parseInt(k.start)/1000;
                if (ts>lastBarTime) {
                    const closingOI=base5mCandles[base5mCandles.length-1]?.oiClose||0;
                    base5mClusters[String(ts)]={};lastBarTime=ts;
                    upsertCandle(ts,parseFloat(k.open),parseFloat(k.high),parseFloat(k.low),parseFloat(k.close),parseFloat(k.volume||0));
                    const newCandle=base5mCandles[base5mCandles.length-1];
                    newCandle.oiOpen=closingOI;newCandle.oiClose=closingOI;newCandle.oiHigh=closingOI;newCandle.oiLow=closingOI;
                    tpoCacheKey = '';
                } else { upsertCandle(ts,parseFloat(k.open),parseFloat(k.high),parseFloat(k.low),parseFloat(k.close),parseFloat(k.volume||0)); }
                displayCandles=aggregateCandles(base5mCandles,config.displayTimeframe);
                displayClusters=aggregateClusters(base5mClusters,config.displayTimeframe);
                mainSeries.update(displayCandles[displayCandles.length-1]);
                extraPanels.forEach(p => {
                    p.displayCandles = aggregateCandles(base5mCandles, p.displayTimeframe);
                    p.displayClusters = aggregateClusters(base5mClusters, p.displayTimeframe);
                    const last = p.displayCandles[p.displayCandles.length-1];
                    if (last) p.mainSeries.update(last);
                });
                scheduleDraw();
            }
            if (msg.topic&&msg.topic.includes("publicTrade")) {
                msg.data.forEach(trade => {
                    const price = parseFloat(trade.p); currentPrice = price;
                    const valUsd = parseFloat(trade.v);
                    const bucket = Math.floor(price / config.baseTickSize) * config.baseTickSize;
                    const timeKey = String(lastBarTime), bucketKey = String(bucket);
                    if (!base5mClusters[timeKey]) base5mClusters[timeKey] = {};
                    if (!base5mClusters[timeKey][bucketKey]) base5mClusters[timeKey][bucketKey] = { buy: 0, sell: 0 };
                    if (trade.S === "Buy") base5mClusters[timeKey][bucketKey].buy += valUsd;
                    else base5mClusters[timeKey][bucketKey].sell += valUsd;
                    clustersDirty = true;

                    const lastBase = base5mCandles[base5mCandles.length - 1];
                    if (lastBase) {
                        lastBase.close = price;
                        if (price > lastBase.high) lastBase.high = price;
                        if (price < lastBase.low) lastBase.low = price;
                        const lastDisplay = displayCandles[displayCandles.length - 1];
                        if (lastDisplay) {
                            lastDisplay.close = price;
                            if (price > lastDisplay.high) lastDisplay.high = price;
                            if (price < lastDisplay.low) lastDisplay.low = price;
                            mainSeries.update(lastDisplay);
                        }
                    }
                    document.getElementById('price').innerText = price.toLocaleString();
                    scheduleDraw();
                });
            }
        } catch(e) { console.error('WS message processing error:', e, event.data); }
        };
    }       

// â”€â”€ Add Chart Button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('add-chart-btn').addEventListener('click', () => {
        if (!myLayout) return;
        
        const panelConfig = {
            type: 'component',
            componentType: 'chartComponent',
            componentState: { isMain: false },
            title: `BTCUSD ${extraPanelCounter + 1}`
        };

        try {
            // Golden Layout v2 natively handles injecting the new tab into the active row
            if (myLayout.rootItem && myLayout.rootItem.contentItems.length > 0) {
                myLayout.rootItem.contentItems[0].addItem(panelConfig);
            } else {
                myLayout.addItem(panelConfig);
            }
        } catch(e) {
            console.error("Failed to add chart panel:", e);
        }
    });

async function init() {
        const glModule = await import('https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm');
        window.goldenLayout = glModule;

        // Boot up Golden Layout (myLayout.init() inside here builds the DOM)
        initGoldenLayout();

        // Wait 50ms for the DOM to attach safely before drawing indicators
        setTimeout(async () => {
            if (!chart || !mainSeries) {
                console.error("Golden Layout failed to map Panel 0 correctly.");
                return;
            }

            chart.timeScale().subscribeVisibleLogicalRangeChange(() => { if (typeof scheduleDraw === 'function') scheduleDraw(); });
            
            // This is what was crashing before! Now the container is guaranteed to exist.
            if(indicatorManager) indicatorManager.addIndicator(new OIIndicator());
            syncHeaderButtons();

            try {
                const interval = getIntervalString(BASE_TIMEFRAME);
                const response = await fetch(`https://api.bybit.com/v5/market/kline?category=inverse&symbol=BTCUSD&interval=${interval}&limit=1000`);
                const data = await response.json();
                if (data.result && data.result.list) {
                    base5mCandles = data.result.list.map(d=>({
                        time: parseInt(d[0])/1000, open: parseFloat(d[1]), high: parseFloat(d[2]),
                        low: parseFloat(d[3]), close: parseFloat(d[4]), volume: parseFloat(d[5]),
                        oiOpen:0, oiHigh:0, oiLow:0, oiClose:0
                    })).sort((a,b) => a.time - b.time);
                    
                    displayCandles = base5mCandles.slice();
                    displayClusters = aggregateClusters(base5mClusters, config.displayTimeframe);
                    mainSeries.setData(displayCandles);
                    
                    lastBarTime = base5mCandles[base5mCandles.length-1].time;
                    currentPrice = base5mCandles[base5mCandles.length-1].close;
                    tpoCacheKey = ''; 
                    
                    await fetchOpenInterest();
                    chart.timeScale().fitContent();
                    updateCandleAppearance();
                }
                startWebSockets();
                setInterval(() => { needsRedraw = true; scheduleDraw(); }, config.drawDelay);
            } catch(e) { console.error(e); }
        }, 50);
    }

    // Launch!
    init();

</script>
</body>
</html>
