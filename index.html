<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Pro Order Flow - Enhanced Settings</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸ“Š</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600;700&family=Fira+Code:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        trade: {
                            bg: '#0a0e1a',
                            panel: '#0f1419',
                            border: '#1a1f2e',
                            accent: '#3b82f6',
                            up: '#608feb',
                            down: '#ff4242',
                            text: '#8b92a7',
                            textLight: '#e8eaed',
                            surface: '#12161f',
                            pocGold: '#f0b90b'
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body { 
            background-color: #0a0e1a; 
            overflow: hidden; 
            user-select: none;
            color: #8b92a7;
        }

        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #1a1f2e; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #2a2f3e; }

        #chart-wrapper { 
            position: relative; 
            flex: 1; 
            min-height: 0; 
            background: #0a0e1a; 
            overflow: hidden; 
        }
        
        #chart-container { 
            width: 100%; 
            height: 100%; 
            z-index: 10;
        }
        
        #footprint-overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            pointer-events: none; 
            z-index: 20;
        }
        
        .indicator-pane { 
            position: absolute; 
            left: 0; 
            right: 77px;
            background: rgba(10, 14, 26, 0.95);
            border-top: 1px solid #1a1f2e; 
            z-index: 30;
            backdrop-filter: blur(4px);
            transition: bottom 0.2s ease;
            pointer-events: none;
        }

        .indicator-pane.dragging {
            z-index: 100;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            border: 1px solid #3b82f6;
        }
        
        .pane-canvas { display: block; width: 100%; height: 100%; pointer-events: none; }
        
        .pane-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            background: transparent;
            cursor: move;
            z-index: 100;
            pointer-events: auto;
        }

        .pane-header:hover {
            background: rgba(10, 14, 26, 0.8);
            backdrop-filter: blur(4px);
        }

        .pane-header:hover .pane-label { color: #a6afd3; }
        .pane-header:hover .pane-close { color: #8b92a7; }

        .pane-label { 
            font-size: 9px; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(139, 146, 167, 0.5); 
            font-family: 'JetBrains Mono', monospace; 
            font-weight: 600;
            transition: color 0.2s;
        }

        .pane-close {
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            font-size: 11px;
            color: rgba(139, 146, 167, 0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        .pane-close:hover {
            background: rgba(255, 66, 66, 0.2);
            color: #ff4242;
        }

        .resizer-handle {
            position: absolute;
            top: -5px; 
            left: 0; 
            right: 0;
            height: 10px;
            cursor: ns-resize;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        
        .resizer-line { width: 0%; height: 0px; background: transparent; }
        .resizer-handle:hover .resizer-line { background: transparent; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #e8eaed; border: 2px solid #3b82f6; cursor: pointer; margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #1a1f2e; border-radius: 2px; }

        select, input[type="number"], input[type="text"] {
            appearance: none; background-color: #0f1419; border: 1px solid #1a1f2e;
            color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 12px;
            border-radius: 4px; transition: all 0.2s;
        }
        select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        
        .select-wrapper { position: relative; }
        .select-wrapper::after {
            content: 'â–¼'; font-size: 8px; color: #5a6178; position: absolute;
            right: 10px; top: 50%; transform: translateY(-50%); pointer-events: none;
        }
        
        .color-picker-wrapper {
            position: relative; height: 28px; width: 100%; border-radius: 4px;
            overflow: hidden; border: 1px solid #1a1f2e; cursor: pointer;
            transition: all 0.2s;
        }
        .color-picker-wrapper:hover { border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        input[type="color"] { border: none; width: 200%; height: 200%; transform: translate(-25%, -25%); cursor: pointer; background: none; }

        .timeframe-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #1a1f2e;
            color: #8b92a7;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timeframe-btn:hover { background: #1a1f2e; color: #e8eaed; }
        .timeframe-btn.active { background: #3b82f6; border-color: #3b82f6; color: white; font-weight: 600; }

        .timeframe-btn-plus {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid #1a1f2e;
            color: #8b92a7;
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .timeframe-btn-plus:hover { background: #1a1f2e; color: #3b82f6; border-color: #3b82f6; transform: rotate(90deg); }

        #custom-price-label {
            position: absolute;
            right: 0;
            z-index: 40;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .price-label-box {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.05) 100%);
            border: 1.5px solid;
            border-radius: 4px;
            padding: 4px 10px;
            font-weight: 600;
            font-size: 10px;
            letter-spacing: 0.02em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            position: relative;
        }

        .price-label-box::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            border-radius: 3px;
            pointer-events: none;
        }

        .price-label-arrow { width: 0; height: 0; border-style: solid; }

        .indicator-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid #1a1f2e;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            color: #8b92a7;
        }
        .indicator-toggle:hover { background: #1a1f2e; color: #e8eaed; }
        .indicator-toggle.active { background: rgba(59, 130, 246, 0.1); border-color: #3b82f6; color: #3b82f6; }

        .indicator-checkbox {
            width: 14px; height: 14px;
            border: 2px solid #1a1f2e;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .indicator-toggle.active .indicator-checkbox { background: #3b82f6; border-color: #3b82f6; }
        .indicator-checkbox svg { width: 10px; height: 10px; stroke: white; opacity: 0; transition: opacity 0.2s; }
        .indicator-toggle.active .indicator-checkbox svg { opacity: 1; }

        .drag-placeholder {
            position: absolute;
            left: 0; right: 77px;
            height: 2px;
            background: #3b82f6;
            z-index: 150;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .modal-overlay.active { opacity: 1; pointer-events: all; }

        .modal-content {
            background: linear-gradient(135deg, #0d1117 0%, #0f1419 100%);
            border: 1px solid #1a1f2e;
            border-radius: 12px;
            padding: 32px;
            min-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .modal-overlay.active .modal-content { transform: scale(1); }

        .modal-title { font-family: 'JetBrains Mono', monospace; font-size: 18px; font-weight: 600; color: #e8eaed; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-description { font-size: 13px; color: #8b92a7; margin-bottom: 24px; line-height: 1.5; }
        .modal-input { width: 100%; padding: 12px 16px; background: #0a0e1a; border: 2px solid #1a1f2e; border-radius: 8px; color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 16px; transition: all 0.2s; margin-bottom: 24px; }
        .modal-input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .modal-buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .modal-btn { padding: 10px 24px; border-radius: 6px; font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-btn-cancel { background: transparent; border: 1px solid #1a1f2e; color: #8b92a7; }
        .modal-btn-cancel:hover { background: #1a1f2e; color: #e8eaed; }
        .modal-btn-confirm { background: #3b82f6; border: 1px solid #3b82f6; color: white; }
        .modal-btn-confirm:hover { background: #2563eb; border-color: #2563eb; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }

        #settings-panel { background: linear-gradient(135deg, #0d1117 0%, #0f1419 100%); }

        .settings-section { border-bottom: 1px solid rgba(26, 31, 46, 0.5); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section:last-child { border-bottom: none; }

        .section-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 16px 20px; cursor: pointer; transition: all 0.2s ease;
            background: transparent; position: relative; overflow: hidden;
        }
        .section-header::before {
            content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
            background: #3b82f6; transform: scaleY(0); transition: transform 0.3s ease;
        }
        .section-header:hover { background: rgba(59, 130, 246, 0.05); }
        .section-header:hover::before { transform: scaleY(1); }

        .section-title-wrapper { display: flex; align-items: center; gap: 12px; }
        .section-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: #3b82f6; opacity: 0.8; transition: all 0.3s ease; }
        .section-header:hover .section-icon { opacity: 1; transform: scale(1.1); }
        .section-title { font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600; color: #e8eaed; text-transform: uppercase; letter-spacing: 0.05em; }

        .section-chevron { width: 16px; height: 16px; color: #5a6178; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section.expanded .section-chevron { transform: rotate(180deg); color: #3b82f6; }

        .section-content { max-height: 0; overflow: hidden; transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section.expanded .section-content { max-height: 2000px; }

        .section-body { padding: 0 20px 20px 20px; display: grid; gap: 16px; }
        .setting-group { display: grid; gap: 12px; }
        .setting-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .setting-item { display: flex; flex-direction: column; gap: 6px; }
        .setting-item.full-width { grid-column: 1 / -1; }

        .setting-label { font-size: 11px; font-weight: 500; color: #a6afd3; text-transform: uppercase; letter-spacing: 0.05em; font-family: 'JetBrains Mono', monospace; }
        .setting-description { font-size: 10px; color: #5a6178; margin-top: -2px; font-family: 'Inter', sans-serif; }

        .slider-container { display: flex; flex-direction: column; gap: 8px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; }
        .slider-value { font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 600; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 2px 8px; border-radius: 3px; min-width: 50px; text-align: center; }

        .setting-divider { height: 1px; background: linear-gradient(90deg, transparent 0%, rgba(26, 31, 46, 0.5) 50%, transparent 100%); margin: 8px 0; }

        .font-preview { padding: 8px 12px; background: rgba(10, 14, 26, 0.5); border: 1px solid #1a1f2e; border-radius: 4px; font-size: 12px; color: #8b92a7; text-align: center; transition: all 0.2s; }
        .font-preview:hover { border-color: #3b82f6; color: #e8eaed; }

        .toggle-switch {
            position: relative; width: 44px; height: 24px;
            background: #1a1f2e; border-radius: 12px; cursor: pointer;
            transition: all 0.3s ease; border: 1px solid #1a1f2e;
        }
        .toggle-switch.active { background: #3b82f6; border-color: #3b82f6; }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 18px; height: 18px; background: white; border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .toggle-switch.active::after { transform: translateX(20px); }

        .reset-button {
            padding: 8px 16px; background: rgba(255, 66, 66, 0.1); border: 1px solid rgba(255, 66, 66, 0.3);
            color: #ff4242; border-radius: 4px; font-family: 'JetBrains Mono', monospace;
            font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.05em;
        }
        .reset-button:hover { background: rgba(255, 66, 66, 0.2); border-color: #ff4242; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(255, 66, 66, 0.2); }
        .reset-button:active { transform: translateY(0); }
    </style>
</head>
<body class="font-sans text-trade-text antialiased h-screen flex flex-col">

    <header class="h-[48px] bg-trade-panel/90 backdrop-blur-md border-b border-trade-border flex items-center justify-between px-4 shrink-0 z-50 relative">
        <div class="flex items-center gap-6 font-mono">
            <div class="flex items-center gap-2.5">
                <div class="relative flex h-2 w-2">
                  <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                  <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                </div>
                <div class="flex flex-col leading-none">
                    <span class="text-white font-bold tracking-wider text-sm">BTCUSD</span>
                    <span class="text-[10px] text-gray-500 font-sans">Perpetual</span>
                </div>
                <div class="flex gap-1 ml-2">
                    <button class="timeframe-btn" data-tf="1">1m</button>
                    <button class="timeframe-btn" data-tf="3">3m</button>
                    <button class="timeframe-btn active" data-tf="5">5m</button>
                    <button class="timeframe-btn" data-tf="15">15m</button>
                    <button class="timeframe-btn" data-tf="30">30m</button>
                    <button class="timeframe-btn" data-tf="60">1h</button>
                    <button class="timeframe-btn" data-tf="240">4h</button>
                    <button class="timeframe-btn" data-tf="D">1D</button>
                    <button class="timeframe-btn-plus" id="custom-tf-btn">+</button>
                </div>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-baseline gap-1.5">
                <span id="price" class="text-[#f0b90b] text-lg font-bold tracking-tight">0.00</span>
                <span class="text-[10px] text-gray-500">USD</span>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-center gap-4">
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Tick Size</span>
                    <span id="tick-display" class="text-xs font-medium text-gray-300">5</span>
                </div>
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Open Interest</span>
                    <span id="oi-display" class="text-xs text-blue-400 font-medium font-mono">Loading...</span>
                </div>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
                <span class="text-[10px] text-gray-500 uppercase tracking-wider">Indicators:</span>
                <button id="toggle-oi" class="indicator-toggle active">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>OI</span>
                </button>
                <button id="toggle-cvd" class="indicator-toggle">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>CVD</span>
                </button>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <button id="header-settings-btn" class="p-2 hover:bg-[#1a1f2e] rounded-md text-gray-400 hover:text-white transition-all active:scale-95 group">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:rotate-45 transition-transform duration-300"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
            </button>
        </div>
    </header>

    <div id="chart-wrapper">
        <div id="chart-container"></div>
        <canvas id="footprint-overlay"></canvas>
        <div id="custom-price-label"></div>
        <div id="indicators-container"></div>
        <div id="timer-box" class="hidden absolute right-[10px] bg-black/90 border border-trade-border/50 backdrop-blur text-white px-1 py-1 font-mono text-[11px] font-semibold z-[60] tabular-nums flex items-center gap-1.5 pointer-events-none shadow-lg rounded" style="min-width: 60px;">
            <span class="w-1.5 h-1.5 rounded-full bg-white/90 animate-pulse"></span>
            <span id="timer-text">00:00</span>
        </div>
    </div>

    <!-- Custom Timeframe Modal -->
    <div id="custom-tf-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title">Custom Timeframe</h2>
            <p class="modal-description">
                Enter a timeframe: Numbers for minutes (e.g., "15", "45")<br>
                Add suffix for periods: "d" = days, "w" = weeks, "M" = months
            </p>
            <input type="text" id="custom-tf-input" class="modal-input" placeholder="e.g., 15, 1h, 1d, 1w" autocomplete="off">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="custom-tf-cancel">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="custom-tf-confirm">Apply</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Settings Panel -->
    <div id="settings-panel" class="absolute top-[49px] left-0 bottom-0 w-96 backdrop-blur-xl border-r border-trade-border z-[1000] transform -translate-x-full transition-transform duration-300 ease-out shadow-2xl flex flex-col">
        
        <div class="flex items-center justify-between p-5 border-b border-trade-border/50 bg-gradient-to-r from-blue-600/10 to-transparent">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 rounded-lg bg-blue-600/20 flex items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                </div>
                <h2 class="text-white font-semibold text-base">Chart Settings</h2>
            </div>
            <button id="close-settings" class="text-gray-500 hover:text-white transition p-2 rounded-lg hover:bg-white/10 active:scale-95">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>

        <div class="flex-1 overflow-y-auto custom-scroll">
            
            <!-- Chart Appearance -->
            <div class="settings-section expanded">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg></div>
                        <span class="section-title">Chart Appearance</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Chart Type</label>
                                <div class="select-wrapper">
                                    <select id="series-type-select" class="w-full px-3 py-2">
                                        <option value="candle" selected>Candles</option>
                                        <option value="bar">Bars</option>
                                    </select>
                                </div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bar Spacing</label>
                                <input type="number" id="bar-spacing-input" value="50" min="10" max="200" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Candle Opacity</label>
                                    <span id="opacity-val" class="slider-value">100%</span>
                                </div>
                                <input type="range" id="candle-opacity" min="0" max="100" value="100" step="5">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Candle Width %</label>
                                <input type="number" id="candle-width-input" value="20" min="5" max="80" step="5" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Cluster Width %</label>
                                <input type="number" id="cluster-width-input" value="80" min="20" max="95" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Wick Thickness</label>
                                    <span id="wick-thickness-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="wick-thickness" min="1" max="5" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Border Thickness</label>
                                    <span id="border-thickness-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="border-thickness" min="0" max="5" value="1" step="0.5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Colors -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r=".5"></circle><circle cx="17.5" cy="10.5" r=".5"></circle><circle cx="8.5" cy="7.5" r=".5"></circle><circle cx="6.5" cy="12.5" r=".5"></circle><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path></svg></div>
                        <span class="section-title">Colors & Theme</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Bullish Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="up-candle-color" value="#608feb"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bearish Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="down-candle-color" value="#ff4242"></div>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Grid Lines</label>
                            <div class="color-picker-wrapper"><input type="color" id="grid-color-input" value="#636363"></div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">POC Highlight</label>
                            <div class="color-picker-wrapper"><input type="color" id="poc-color-input" value="#f0b90b"></div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Background</label>
                                <div class="color-picker-wrapper"><input type="color" id="bg-color-input" value="#0a0e1a"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Panel Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="panel-color-input" value="#0f1419"></div>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Accent Color</label>
                            <div class="color-picker-wrapper"><input type="color" id="accent-color-input" value="#3b82f6"></div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Absorption Dot Color</label>
                            <div class="color-picker-wrapper"><input type="color" id="absorption-color-input" value="#FFD700"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Typography -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg></div>
                        <span class="section-title">Typography</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Stats Font Family</label>
                            <div class="select-wrapper">
                                <select id="stats-font-family" class="w-full px-3 py-2">
                                    <option value="'JetBrains Mono', monospace" selected>JetBrains Mono</option>
                                    <option value="'IBM Plex Mono', monospace">IBM Plex Mono</option>
                                    <option value="'Fira Code', monospace">Fira Code</option>
                                    <option value="monospace">System Mono</option>
                                </select>
                            </div>
                            <div class="font-preview" id="stats-font-preview" style="font-family: 'JetBrains Mono', monospace;">V:1.2M D:+250K</div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Stats Font Size</label>
                                    <span id="stats-font-size-val" class="slider-value">Auto</span>
                                </div>
                                <input type="range" id="stats-font-size" min="7" max="16" value="11" step="1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Stats Font Weight</label>
                            <div class="select-wrapper">
                                <select id="stats-font-weight" class="w-full px-3 py-2">
                                    <option value="400">Regular (400)</option>
                                    <option value="500">Medium (500)</option>
                                    <option value="600" selected>Semi-Bold (600)</option>
                                    <option value="700">Bold (700)</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cell Font Size</label>
                                    <span id="cell-font-size-val" class="slider-value">11px</span>
                                </div>
                                <input type="range" id="cell-font-size" min="8" max="16" value="11" step="1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Cell Font Weight</label>
                            <div class="select-wrapper">
                                <select id="cell-font-weight" class="w-full px-3 py-2">
                                    <option value="400" selected>Regular (400)</option>
                                    <option value="500">Medium (500)</option>
                                    <option value="600">Semi-Bold (600)</option>
                                    <option value="700">Bold (700)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Grid & Scale -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg></div>
                        <span class="section-title">Grid & Scale</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Grid Spacing ($)</label>
                            <input type="number" id="grid-spacing-input" value="1000" step="100" min="100" max="10000" class="w-full px-3 py-2">
                            <span class="setting-description">Price interval between horizontal grid lines</span>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Grid Opacity</label>
                                    <span id="grid-opacity-val" class="slider-value">100%</span>
                                </div>
                                <input type="range" id="grid-opacity" min="0" max="100" value="100" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Grid Line Width</label>
                                    <span id="grid-line-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="grid-line-width" min="0.5" max="3" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Base Tick Size</label>
                            <input type="number" id="base-tick-input" value="2.5" step="0.5" min="0.5" max="50" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum price level grouping</span>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Min Cell Height (px)</label>
                            <input type="number" id="min-cell-height-input" value="15" step="1" min="8" max="40" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum height before auto-scaling kicks in</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                 FOOTPRINT CLUSTERS â€” includes new clusterVolumeThreshold input
                 â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg></div>
                        <span class="section-title">Footprint Clusters</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Calculation Mode</label>
                            <div class="select-wrapper">
                                <select id="cumulative-mode-select" class="w-full px-3 py-2">
                                    <option value="all" selected>All Candles</option>
                                    <option value="visible">Visible Candles Only</option>
                                </select>
                            </div>
                            <span class="setting-description">Cumulative cluster aggregation range</span>
                        </div>

                        <div class="setting-divider"></div>

                        <!-- â˜… NEW: Low-volume cluster threshold filter -->
                        <div class="setting-item">
                            <label class="setting-label">Low-Volume Cell Threshold (USD)</label>
                            <input type="number" id="cluster-volume-threshold" value="50000" min="0" step="10000" class="w-full px-3 py-2">
                            <span class="setting-description">Cells below this total volume are shown in muted gray. Set to 0 to disable.</span>
                        </div>

                        <div class="setting-divider"></div>

                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cluster BG Opacity</label>
                                    <span id="cluster-bg-opacity-val" class="slider-value">85%</span>
                                </div>
                                <input type="range" id="cluster-bg-opacity" min="0" max="100" value="85" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">POC Border Width</label>
                                    <span id="poc-border-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="poc-border-width" min="1" max="5" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cell Border Width</label>
                                    <span id="cell-border-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="cell-border-width" min="0" max="3" value="1" step="0.5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Volume Analysis -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg></div>
                        <span class="section-title">Volume Analysis</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Min Delta for Bubbles (USD)</label>
                            <input type="number" id="bubble-threshold-input" value="500000" step="100000" min="0" max="10000000" class="w-full px-3 py-2">
                            <span class="setting-description">Show pulsing indicator when delta exceeds this threshold</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Bubble Inner Size</label>
                                <input type="number" id="bubble-inner-size" value="5" min="2" max="15" step="1" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bubble Outer Size</label>
                                <input type="number" id="bubble-outer-size" value="10" min="5" max="25" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Bubble Pulse Speed</label>
                                    <span id="bubble-pulse-speed-val" class="slider-value">1.5s</span>
                                </div>
                                <input type="range" id="bubble-pulse-speed" min="500" max="3000" value="1500" step="100">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Absorption Dot Size</label>
                                <input type="number" id="absorption-dot-size" value="4" min="2" max="12" step="1" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Absorption Glow</label>
                                <input type="number" id="absorption-glow" value="10" min="0" max="30" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Absorption Threshold (USD)</label>
                            <input type="number" id="absorption-threshold" value="100000" step="10000" min="0" max="1000000" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum delta for absorption detection</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- UI Elements -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m0 0"></path><circle cx="12" cy="12" r="10"></circle></svg></div>
                        <span class="section-title">UI Elements</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Price Line</label>
                                <div class="toggle-switch" id="toggle-price-line-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Price Label</label>
                                <div class="toggle-switch active" id="toggle-price-label-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Countdown Timer</label>
                                <div class="toggle-switch active" id="toggle-countdown-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Crosshair</label>
                                <div class="toggle-switch active" id="toggle-crosshair-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Price Label Font Size</label>
                            <input type="number" id="price-label-font-size" value="10" min="8" max="16" step="1" class="w-full px-3 py-2">
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Timer Font Size</label>
                            <input type="number" id="timer-font-size" value="11" min="8" max="16" step="1" class="w-full px-3 py-2">
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Timer Opacity</label>
                                    <span id="timer-opacity-val" class="slider-value">90%</span>
                                </div>
                                <input type="range" id="timer-opacity" min="0" max="100" value="90" step="5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Indicators -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg></div>
                        <span class="section-title">Indicators</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Default Indicator Height</label>
                            <input type="number" id="default-indicator-height" value="150" min="50" max="500" step="10" class="w-full px-3 py-2">
                            <span class="setting-description">Initial height for new indicators (px)</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">OI Candle Width</label>
                                    <span id="oi-candle-width-val" class="slider-value">50%</span>
                                </div>
                                <input type="range" id="oi-candle-width" min="20" max="100" value="50" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">CVD Line Thickness</label>
                                    <span id="cvd-line-thickness-val" class="slider-value">2px</span>
                                </div>
                                <input type="range" id="cvd-line-thickness" min="1" max="5" value="2" step="0.5">
                            </div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Indicator Padding</label>
                                <input type="number" id="indicator-padding" value="10" min="0" max="30" step="2" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Indicator BG Opacity</label>
                                <input type="number" id="indicator-bg-opacity" value="95" min="0" max="100" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg></div>
                        <span class="section-title">Advanced</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Draw Frame Delay</label>
                                    <span id="draw-delay-val" class="slider-value">100ms</span>
                                </div>
                                <input type="range" id="draw-delay" min="50" max="500" value="100" step="50">
                            </div>
                            <span class="setting-description">Lower = more responsive, higher = better performance</span>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Interaction Hold Time</label>
                                    <span id="interaction-hold-val" class="slider-value">180ms</span>
                                </div>
                                <input type="range" id="interaction-hold" min="50" max="500" value="180" step="10">
                            </div>
                            <span class="setting-description">Duration to keep drawing after user interaction</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item full-width">
                            <button class="reset-button w-full" onclick="resetToDefaults()">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 6px;"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
                                Reset All Settings to Defaults
                            </button>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="ctx-menu-main" class="hidden absolute w-52 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] text-sm backdrop-blur-sm">
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-reset">
            <span class="font-medium">Reset View</span><span class="text-gray-500 text-xs group-hover:text-blue-400">R</span>
        </div>
        <div class="h-px bg-trade-border mx-2 my-1"></div>
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-settings-trigger">
            <span class="font-medium">Settings</span><span class="text-gray-500 text-[10px] group-hover:text-blue-400">â–¶</span>
        </div>
    </div>

<script>
    const HEADER_HEIGHT = 48;
    const TIME_AXIS_HEIGHT = 28;
    const MIN_PANE_HEIGHT = 50;
    const BASE_TIMEFRAME = 5;

    // â˜… CHANGE 1: added clusterVolumeThreshold to config (default 0 = disabled)
    let config = {
        gridSpacing: 1000, gridColor: '#636363', gridOpacity: 1.0, gridLineWidth: 1,
        baseTickSize: 2.5, minCellHeight: 15, upColor: '#608feb', downColor: '#ff4242',
        candleOpacity: 1.0, seriesType: 'candle', minBubbleVolume: 500000,
        showPriceLine: false, showPriceLabel: true, showCountdown: true, showCrosshair: true,
        pocColor: '#f0b90b', currentTimeframe: 5, displayTimeframe: 5,
        candleWidthPercent: 0.20, clusterWidthPercent: 0.80, cumulativeMode: 'all',
        wickThickness: 1, borderThickness: 1, bgColor: '#0a0e1a', panelColor: '#0f1419',
        accentColor: '#3b82f6', absorptionColor: '#FFD700',
        statsFontFamily: "'JetBrains Mono', monospace", statsFontSize: 11,
        statsFontWeight: '600', cellFontSize: 11, cellFontWeight: '400', barSpacing: 50,
        clusterBgOpacity: 0.85, pocBorderWidth: 1, cellBorderWidth: 1,
        bubbleInnerSize: 5, bubbleOuterSize: 10, bubblePulseSpeed: 1500,
        absorptionDotSize: 4, absorptionGlow: 10, absorptionThreshold: 100000,
        priceLabelFontSize: 10, timerFontSize: 11, timerOpacity: 0.9,
        defaultIndicatorHeight: 150, oiCandleWidth: 0.5, cvdLineThickness: 2,
        indicatorPadding: 10, indicatorBgOpacity: 0.95, drawDelay: 100, interactionHold: 180,
        clusterVolumeThreshold: 50000   // â˜… NEW â€” 0 means disabled
    };

    let base5mClusters = {};
    let base5mCandles = [];
    let displayCandles = [];
    let displayClusters = {};
    let lastBarTime = 0;
    let currentPrice = 0;
    let mainSeries;
    let ws = null;

    const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
        layout: { background: { color: config.bgColor }, textColor: '#8b92a7', fontFamily: 'Inter' },
        grid: { vertLines: { visible: false }, horzLines: { visible: false } },
        rightPriceScale: { borderColor: '#1a1f2e', width: 60, scaleMargins: { top: 0.05, bottom: 0.20 } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        timeScale: { borderColor: '#1a1f2e', timeVisible: true, barSpacing: config.barSpacing, rightOffset: 5, visible: true }
    });

    function parseCustomTimeframe(input) {
        input = input.trim().toLowerCase();
        if (input.endsWith('h')) { const h = parseFloat(input.slice(0,-1)); return (isNaN(h)||h<=0)?null:h*60; }
        if (input.endsWith('d')) { const d = parseFloat(input.slice(0,-1)); return (isNaN(d)||d<=0)?null:d*1440; }
        if (input.endsWith('w')) { const w = parseFloat(input.slice(0,-1)); return (isNaN(w)||w<=0)?null:w*10080; }
        if (input.endsWith('m') && input.length > 1) {
            const char = input[input.length-2];
            if (!isNaN(char)) { const m = parseFloat(input.slice(0,-1)); return (isNaN(m)||m<=0)?null:m; }
        }
        const mins = parseFloat(input);
        return (isNaN(mins)||mins<=0) ? null : mins;
    }

    function validateTimeframe(minutes) {
        if (minutes < BASE_TIMEFRAME) { alert(`Footprint information will not migrate to timeframes lower than ${BASE_TIMEFRAME}m`); return false; }
        if (minutes % BASE_TIMEFRAME !== 0) { alert(`Please use timeframes divisible by ${BASE_TIMEFRAME}m`); return false; }
        return true;
    }

    function aggregateCandles(source5mCandles, targetTFMinutes) {
        if (targetTFMinutes === BASE_TIMEFRAME) return source5mCandles.slice();
        const aggregated = [];
        const targetBarSeconds = targetTFMinutes * 60;
        const grouped = {};
        source5mCandles.forEach(candle => {
            const alignedTime = Math.floor(candle.time / targetBarSeconds) * targetBarSeconds;
            if (!grouped[alignedTime]) grouped[alignedTime] = [];
            grouped[alignedTime].push(candle);
        });
        const alignedTimes = Object.keys(grouped).map(Number).sort((a,b)=>a-b);
        alignedTimes.forEach(alignedTime => {
            const chunk = grouped[alignedTime];
            if (chunk.length === 0) return;
            const first = chunk[0], last = chunk[chunk.length-1];
            aggregated.push({
                time: alignedTime, open: first.open,
                high: Math.max(...chunk.map(c=>c.high)), low: Math.min(...chunk.map(c=>c.low)),
                close: last.close, oiOpen: first.oiOpen,
                oiHigh: Math.max(...chunk.map(c=>c.oiHigh||0)),
                oiLow: Math.min(...chunk.map(c=>c.oiLow||Infinity)),
                oiClose: last.oiClose
            });
        });
        return aggregated;
    }

    function aggregateClusters(source5mClusters, targetTFMinutes) {
        if (targetTFMinutes === BASE_TIMEFRAME) return JSON.parse(JSON.stringify(source5mClusters));
        const aggregated = {};
        const targetBarSeconds = targetTFMinutes * 60;
        const timestamps = Object.keys(source5mClusters).map(Number).sort((a,b)=>a-b);
        const grouped = {};
        timestamps.forEach(ts => {
            const alignedTime = Math.floor(ts / targetBarSeconds) * targetBarSeconds;
            if (!grouped[alignedTime]) grouped[alignedTime] = [];
            grouped[alignedTime].push(ts);
        });
        Object.keys(grouped).forEach(alignedTime => {
            const timeKey = String(alignedTime);
            const tsList = grouped[alignedTime];
            let hasData = false;
            tsList.forEach(ts => { const b = source5mClusters[String(ts)]; if (b && Object.keys(b).length > 0) hasData = true; });
            if (!hasData) return;
            aggregated[timeKey] = {};
            tsList.forEach(ts => {
                const buckets = source5mClusters[String(ts)];
                if (!buckets) return;
                Object.keys(buckets).forEach(priceKey => {
                    const price = parseFloat(priceKey);
                    const data = buckets[priceKey];
                    if (data.buy === 0 && data.sell === 0) return;
                    if (!aggregated[timeKey][price]) aggregated[timeKey][price] = { buy: 0, sell: 0 };
                    aggregated[timeKey][price].buy += data.buy;
                    aggregated[timeKey][price].sell += data.sell;
                });
            });
            if (Object.keys(aggregated[timeKey]).length === 0) delete aggregated[timeKey];
        });
        return aggregated;
    }

    function applyTimeframeChange(newTFMinutes) {
        config.displayTimeframe = newTFMinutes;
        displayCandles = aggregateCandles(base5mCandles, newTFMinutes);
        displayClusters = aggregateClusters(base5mClusters, newTFMinutes);
        mainSeries.setData(displayCandles);
        document.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
        const tfMap = { 1:1, 3:3, 5:5, 15:15, 30:30, 60:60, 240:240, 1440:'D' };
        const btnValue = tfMap[newTFMinutes];
        if (btnValue) { const btn = document.querySelector(`[data-tf="${btnValue}"]`); if (btn) btn.classList.add('active'); }
        setTimeout(() => { chart.timeScale().fitContent(); needsRedraw = true; scheduleDraw(); }, 100);
    }

    document.getElementById('custom-tf-btn').onclick = () => {
        const modal = document.getElementById('custom-tf-modal');
        modal.classList.add('active');
        document.getElementById('custom-tf-input').value = '';
        document.getElementById('custom-tf-input').focus();
    };
    document.getElementById('custom-tf-cancel').onclick = () => document.getElementById('custom-tf-modal').classList.remove('active');
    document.getElementById('custom-tf-modal').onclick = (e) => { if (e.target.id==='custom-tf-modal') document.getElementById('custom-tf-modal').classList.remove('active'); };
    document.getElementById('custom-tf-input').onkeypress = (e) => { if (e.key==='Enter') document.getElementById('custom-tf-confirm').click(); };
    document.getElementById('custom-tf-confirm').onclick = () => {
        const input = document.getElementById('custom-tf-input').value;
        const minutes = parseCustomTimeframe(input);
        if (minutes === null) { alert('Invalid timeframe format. Examples: 15, 1h, 4h, 1d, 1w'); return; }
        if (!validateTimeframe(minutes)) return;
        document.getElementById('custom-tf-modal').classList.remove('active');
        applyTimeframeChange(minutes);
    };

    function toggleSection(header) { header.parentElement.classList.toggle('expanded'); }

    function toggleSwitch(element) {
        element.classList.toggle('active');
        const switchId = element.id;
        if (switchId === 'toggle-price-line-switch') { config.showPriceLine = element.classList.contains('active'); mainSeries.applyOptions({ priceLineVisible: config.showPriceLine }); }
        else if (switchId === 'toggle-price-label-switch') { config.showPriceLabel = element.classList.contains('active'); scheduleDraw(); }
        else if (switchId === 'toggle-countdown-switch') { config.showCountdown = element.classList.contains('active'); scheduleDraw(); }
        else if (switchId === 'toggle-crosshair-switch') {
            config.showCrosshair = element.classList.contains('active');
            chart.applyOptions({ crosshair: { vertLine: { visible: config.showCrosshair }, horzLine: { visible: config.showCrosshair } } });
        }
    }

    function resetToDefaults() {
        if (!confirm('Reset all settings to default values? This cannot be undone.')) return;
        config = {
            gridSpacing: 1000, gridColor: '#636363', gridOpacity: 1.0, gridLineWidth: 1,
            baseTickSize: 2.5, minCellHeight: 15, upColor: '#608feb', downColor: '#ff4242',
            candleOpacity: 1.0, seriesType: 'candle', minBubbleVolume: 500000,
            showPriceLine: false, showPriceLabel: true, showCountdown: true, showCrosshair: true,
            pocColor: '#f0b90b', currentTimeframe: 5, displayTimeframe: 5, candleWidthPercent: 0.20,
            clusterWidthPercent: 0.80, cumulativeMode: 'all', wickThickness: 1, borderThickness: 1,
            bgColor: '#0a0e1a', panelColor: '#0f1419', accentColor: '#3b82f6',
            absorptionColor: '#FFD700', statsFontFamily: "'JetBrains Mono', monospace",
            statsFontSize: 11, statsFontWeight: '600', cellFontSize: 11, cellFontWeight: '400',
            barSpacing: 50, clusterBgOpacity: 0.85, pocBorderWidth: 1, cellBorderWidth: 1,
            bubbleInnerSize: 5, bubbleOuterSize: 10, bubblePulseSpeed: 1500,
            absorptionDotSize: 4, absorptionGlow: 10, absorptionThreshold: 100000,
            priceLabelFontSize: 10, timerFontSize: 11, timerOpacity: 0.9,
            defaultIndicatorHeight: 150, oiCandleWidth: 0.5, cvdLineThickness: 2,
            indicatorPadding: 10, indicatorBgOpacity: 0.95, drawDelay: 100, interactionHold: 180,
            clusterVolumeThreshold: 50000  // â˜… reset new field
        };
        document.getElementById('series-type-select').value = 'candle';
        document.getElementById('bar-spacing-input').value = 50;
        document.getElementById('candle-opacity').value = 100; document.getElementById('opacity-val').textContent = '100%';
        document.getElementById('candle-width-input').value = 20; document.getElementById('cluster-width-input').value = 80;
        document.getElementById('wick-thickness').value = 1; document.getElementById('wick-thickness-val').textContent = '1px';
        document.getElementById('border-thickness').value = 1; document.getElementById('border-thickness-val').textContent = '1px';
        document.getElementById('up-candle-color').value = '#608feb'; document.getElementById('down-candle-color').value = '#ff4242';
        document.getElementById('grid-color-input').value = '#636363'; document.getElementById('poc-color-input').value = '#f0b90b';
        document.getElementById('bg-color-input').value = '#0a0e1a'; document.getElementById('panel-color-input').value = '#0f1419';
        document.getElementById('accent-color-input').value = '#3b82f6'; document.getElementById('absorption-color-input').value = '#FFD700';
        document.getElementById('stats-font-family').value = "'JetBrains Mono', monospace";
        document.getElementById('stats-font-size').value = 11; document.getElementById('stats-font-size-val').textContent = '11px';
        document.getElementById('stats-font-weight').value = '600';
        document.getElementById('cell-font-size').value = 11; document.getElementById('cell-font-size-val').textContent = '11px';
        document.getElementById('cell-font-weight').value = '400';
        document.getElementById('grid-spacing-input').value = 1000;
        document.getElementById('grid-opacity').value = 100; document.getElementById('grid-opacity-val').textContent = '100%';
        document.getElementById('grid-line-width').value = 1; document.getElementById('grid-line-width-val').textContent = '1px';
        document.getElementById('base-tick-input').value = 2.5; document.getElementById('min-cell-height-input').value = 15;
        document.getElementById('cumulative-mode-select').value = 'all';
        document.getElementById('cluster-volume-threshold').value = 50000;  // â˜… reset new field UI
        document.getElementById('cluster-bg-opacity').value = 85; document.getElementById('cluster-bg-opacity-val').textContent = '85%';
        document.getElementById('poc-border-width').value = 1; document.getElementById('poc-border-width-val').textContent = '1px';
        document.getElementById('cell-border-width').value = 1; document.getElementById('cell-border-width-val').textContent = '1px';
        document.getElementById('bubble-threshold-input').value = 500000;
        document.getElementById('bubble-inner-size').value = 5; document.getElementById('bubble-outer-size').value = 10;
        document.getElementById('bubble-pulse-speed').value = 1500; document.getElementById('bubble-pulse-speed-val').textContent = '1.5s';
        document.getElementById('absorption-dot-size').value = 4; document.getElementById('absorption-glow').value = 10;
        document.getElementById('absorption-threshold').value = 100000;
        document.getElementById('toggle-price-line-switch').classList.remove('active');
        document.getElementById('toggle-price-label-switch').classList.add('active');
        document.getElementById('toggle-countdown-switch').classList.add('active');
        document.getElementById('toggle-crosshair-switch').classList.add('active');
        document.getElementById('price-label-font-size').value = 10; document.getElementById('timer-font-size').value = 11;
        document.getElementById('timer-opacity').value = 90; document.getElementById('timer-opacity-val').textContent = '90%';
        document.getElementById('default-indicator-height').value = 150;
        document.getElementById('oi-candle-width').value = 50; document.getElementById('oi-candle-width-val').textContent = '50%';
        document.getElementById('cvd-line-thickness').value = 2; document.getElementById('cvd-line-thickness-val').textContent = '2px';
        document.getElementById('indicator-padding').value = 10; document.getElementById('indicator-bg-opacity').value = 95;
        document.getElementById('draw-delay').value = 100; document.getElementById('draw-delay-val').textContent = '100ms';
        document.getElementById('interaction-hold').value = 180; document.getElementById('interaction-hold-val').textContent = '180ms';
        updateCandleAppearance();
        chart.applyOptions({ layout: { background: { color: config.bgColor } }, timeScale: { barSpacing: config.barSpacing } });
        mainSeries.applyOptions({ priceLineVisible: config.showPriceLine });
        chart.applyOptions({ crosshair: { vertLine: { visible: config.showCrosshair }, horzLine: { visible: config.showCrosshair } } });
        applyTimeframeChange(5);
    }

    // â”€â”€â”€ Settings event listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('bar-spacing-input').addEventListener('input', (e) => { config.barSpacing = parseInt(e.target.value); chart.timeScale().applyOptions({ barSpacing: config.barSpacing }); scheduleDraw(); });
    document.getElementById('candle-width-input').addEventListener('input', (e) => { config.candleWidthPercent = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('cluster-width-input').addEventListener('input', (e) => { config.clusterWidthPercent = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('wick-thickness').addEventListener('input', (e) => { config.wickThickness = parseFloat(e.target.value); document.getElementById('wick-thickness-val').textContent = config.wickThickness+'px'; scheduleDraw(); });
    document.getElementById('border-thickness').addEventListener('input', (e) => { config.borderThickness = parseFloat(e.target.value); document.getElementById('border-thickness-val').textContent = config.borderThickness+'px'; scheduleDraw(); });
    document.getElementById('bg-color-input').addEventListener('change', (e) => { config.bgColor = e.target.value; chart.applyOptions({ layout: { background: { color: config.bgColor } } }); });
    document.getElementById('panel-color-input').addEventListener('change', (e) => { config.panelColor = e.target.value; });
    document.getElementById('accent-color-input').addEventListener('change', (e) => { config.accentColor = e.target.value; });
    document.getElementById('poc-color-input').addEventListener('change', (e) => { config.pocColor = e.target.value; scheduleDraw(); });
    document.getElementById('absorption-color-input').addEventListener('change', (e) => { config.absorptionColor = e.target.value; scheduleDraw(); });
    document.getElementById('stats-font-family').addEventListener('change', (e) => { config.statsFontFamily = e.target.value; document.getElementById('stats-font-preview').style.fontFamily = e.target.value; scheduleDraw(); });
    document.getElementById('stats-font-size').addEventListener('input', (e) => { config.statsFontSize = parseInt(e.target.value); document.getElementById('stats-font-size-val').textContent = config.statsFontSize+'px'; scheduleDraw(); });
    document.getElementById('stats-font-weight').addEventListener('change', (e) => { config.statsFontWeight = e.target.value; scheduleDraw(); });
    document.getElementById('cell-font-size').addEventListener('input', (e) => { config.cellFontSize = parseInt(e.target.value); document.getElementById('cell-font-size-val').textContent = config.cellFontSize+'px'; scheduleDraw(); });
    document.getElementById('cell-font-weight').addEventListener('change', (e) => { config.cellFontWeight = e.target.value; scheduleDraw(); });
    document.getElementById('grid-opacity').addEventListener('input', (e) => { config.gridOpacity = parseInt(e.target.value)/100; document.getElementById('grid-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('grid-line-width').addEventListener('input', (e) => { config.gridLineWidth = parseFloat(e.target.value); document.getElementById('grid-line-width-val').textContent = config.gridLineWidth+'px'; scheduleDraw(); });
    document.getElementById('base-tick-input').addEventListener('change', (e) => { config.baseTickSize = parseFloat(e.target.value); scheduleDraw(); });
    document.getElementById('min-cell-height-input').addEventListener('change', (e) => { config.minCellHeight = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('cluster-bg-opacity').addEventListener('input', (e) => { config.clusterBgOpacity = parseInt(e.target.value)/100; document.getElementById('cluster-bg-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('poc-border-width').addEventListener('input', (e) => { config.pocBorderWidth = parseFloat(e.target.value); document.getElementById('poc-border-width-val').textContent = config.pocBorderWidth+'px'; scheduleDraw(); });
    document.getElementById('cell-border-width').addEventListener('input', (e) => { config.cellBorderWidth = parseFloat(e.target.value); document.getElementById('cell-border-width-val').textContent = config.cellBorderWidth+'px'; scheduleDraw(); });
    // â˜… CHANGE 2: event listener for the new threshold input
    document.getElementById('cluster-volume-threshold').addEventListener('input', (e) => { config.clusterVolumeThreshold = parseFloat(e.target.value) || 0; scheduleDraw(); });
    document.getElementById('bubble-inner-size').addEventListener('input', (e) => { config.bubbleInnerSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('bubble-outer-size').addEventListener('input', (e) => { config.bubbleOuterSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('bubble-pulse-speed').addEventListener('input', (e) => { config.bubblePulseSpeed = parseInt(e.target.value); document.getElementById('bubble-pulse-speed-val').textContent = (config.bubblePulseSpeed/1000).toFixed(1)+'s'; scheduleDraw(); });
    document.getElementById('absorption-dot-size').addEventListener('input', (e) => { config.absorptionDotSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('absorption-glow').addEventListener('input', (e) => { config.absorptionGlow = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('absorption-threshold').addEventListener('input', (e) => { config.absorptionThreshold = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('price-label-font-size').addEventListener('input', (e) => { config.priceLabelFontSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('timer-font-size').addEventListener('input', (e) => { config.timerFontSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('timer-opacity').addEventListener('input', (e) => { config.timerOpacity = parseInt(e.target.value)/100; document.getElementById('timer-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('default-indicator-height').addEventListener('input', (e) => { config.defaultIndicatorHeight = parseInt(e.target.value); });
    document.getElementById('oi-candle-width').addEventListener('input', (e) => { config.oiCandleWidth = parseInt(e.target.value)/100; document.getElementById('oi-candle-width-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('cvd-line-thickness').addEventListener('input', (e) => { config.cvdLineThickness = parseFloat(e.target.value); document.getElementById('cvd-line-thickness-val').textContent = config.cvdLineThickness+'px'; scheduleDraw(); });
    document.getElementById('indicator-padding').addEventListener('input', (e) => { config.indicatorPadding = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('indicator-bg-opacity').addEventListener('input', (e) => { config.indicatorBgOpacity = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('draw-delay').addEventListener('input', (e) => { config.drawDelay = parseInt(e.target.value); document.getElementById('draw-delay-val').textContent = config.drawDelay+'ms'; });
    document.getElementById('interaction-hold').addEventListener('input', (e) => { config.interactionHold = parseInt(e.target.value); document.getElementById('interaction-hold-val').textContent = config.interactionHold+'ms'; });

    // â”€â”€â”€ Core draw loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let rafId = null, rafRunning = false, needsRedraw = false, lastInteractionTime = 0;

    function scheduleDraw() {
        needsRedraw = true;
        lastInteractionTime = Date.now();
        if (!rafRunning) {
            rafRunning = true;
            const loop = () => {
                const now = Date.now();
                if (now - lastInteractionTime < config.interactionHold) {
                    drawFrames(); rafId = requestAnimationFrame(loop);
                } else {
                    if (needsRedraw) { needsRedraw = false; drawFrames(); rafId = requestAnimationFrame(loop); }
                    else { rafRunning = false; rafId = null; }
                }
            };
            rafId = requestAnimationFrame(loop);
        }
    }

    function getVisibleCandles(cssWidth) {
        const visibleCandles = [];
        if (!displayCandles) return visibleCandles;
        for (let i = 0; i < displayCandles.length; i++) {
            const candle = displayCandles[i];
            const x = chart.timeScale().timeToCoordinate(candle.time);
            if (x === null || x < -100 || x > cssWidth + 100) continue;
            visibleCandles.push({ i, x, candle });
        }
        return visibleCandles;
    }

    // â”€â”€â”€ Indicator system â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    class BaseIndicator {
        constructor(id, name, defaultHeight = config.defaultIndicatorHeight) {
            this.id = id; this.name = name; this.height = defaultHeight;
            this.element = null; this.canvas = null; this.ctx = null;
            this.offscreenCanvas = null; this.offscreenCtx = null; this.visible = false;
        }
        createElement() {
            const div = document.createElement('div');
            div.className = 'indicator-pane'; div.id = `indicator-${this.id}`; div.style.height = this.height+'px';
            div.innerHTML = `
                <div class="pane-header" data-indicator="${this.id}">
                    <span class="pane-label">${this.name}</span>
                    <div class="pane-close" data-indicator="${this.id}">âœ•</div>
                </div>
                <div class="resizer-handle" data-indicator="${this.id}"><div class="resizer-line"></div></div>
                <canvas class="pane-canvas" id="canvas-${this.id}"></canvas>`;
            this.element = div;
            this.canvas = div.querySelector(`#canvas-${this.id}`);
            this.ctx = this.canvas.getContext('2d');
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            this.setupEventListeners();
            return div;
        }
        setupEventListeners() {
            this.element.querySelector('.pane-close').addEventListener('click', (e) => { e.stopPropagation(); indicatorManager.removeIndicator(this.id); });
            const resizer = this.element.querySelector('.resizer-handle');
            let dragging = false, startY = 0, startH = 0;
            resizer.addEventListener('mousedown', (e) => { e.stopPropagation(); dragging = true; startY = e.clientY; startH = this.height; document.body.style.cursor = 'ns-resize'; });
            window.addEventListener('mousemove', (e) => { if (!dragging) return; this.height = Math.max(MIN_PANE_HEIGHT, startH+(startY-e.clientY)); indicatorManager.updateLayout(); });
            window.addEventListener('mouseup', () => { if (dragging) { dragging = false; document.body.style.cursor = ''; } });
            this.element.querySelector('.pane-header').addEventListener('mousedown', (e) => { if (e.target.classList.contains('pane-close')) return; indicatorManager.startDrag(this.id, e); });
        }
        setupBuffers(width, height) {
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = Math.floor(width*dpr); this.canvas.height = Math.floor(height*dpr);
            this.canvas.style.width = width+'px'; this.canvas.style.height = height+'px';
            this.offscreenCanvas.width = this.canvas.width; this.offscreenCanvas.height = this.canvas.height;
            this.offscreenCtx.setTransform(dpr,0,0,dpr,0,0); this.ctx.setTransform(1,0,0,1,0,0);
        }
        show() { this.visible = true; }
        hide() { this.visible = false; }
        draw(cssWidth) {}
        render() {
            if (!this.visible || !this.ctx || !this.offscreenCanvas) return;
            this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
            this.ctx.drawImage(this.offscreenCanvas,0,0);
        }
    }

    class OIIndicator extends BaseIndicator {
        constructor() { super('oi','Open Interest',200); }
        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;
            ctxS.clearRect(0,0,cssWidth,this.height); ctxS.textAlign = 'center';
            const barSpacing = chart.timeScale().options().barSpacing;
            const visibleCandles = getVisibleCandles(cssWidth);
            let minOI = Infinity, maxOI = -Infinity;
            visibleCandles.forEach(item => {
                const c = item.candle;
                if (c.oiClose && c.oiClose > 0) {
                    const cHigh = c.oiHigh || Math.max(c.oiOpen,c.oiClose);
                    const cLow = c.oiLow || Math.min(c.oiOpen,c.oiClose);
                    if (cHigh > maxOI) maxOI = cHigh;
                    if (cLow < minOI && cLow > 0) minOI = cLow;
                }
            });
            if (maxOI === -Infinity || minOI === Infinity) { minOI = 0; maxOI = 100; }
            if (minOI === maxOI) { minOI = maxOI*0.99; maxOI = maxOI*1.01; }
            const padding = config.indicatorPadding;
            const availableH = this.height - (padding*2);
            const oiRange = maxOI - minOI;
            const getOIY = (val) => { if (val<=0) return this.height-padding; return padding+(availableH*(1-(val-minOI)/oiRange)); };
            visibleCandles.forEach(item => {
                const { candle, x } = item;
                if (!candle.oiClose || candle.oiClose <= 0) return;
                const cOpen = candle.oiOpen || candle.oiClose, cClose = candle.oiClose;
                const cHigh = candle.oiHigh||Math.max(cOpen,cClose), cLow = candle.oiLow||Math.min(cOpen,cClose);
                const openY = getOIY(cOpen), closeY = getOIY(cClose);
                const highY = getOIY(cHigh), lowY = getOIY(cLow);
                const isUp = cClose >= cOpen;
                const color = isUp ? config.upColor : config.downColor;
                const w = Math.max(3, barSpacing*config.oiCandleWidth);
                ctxS.fillStyle = color; ctxS.strokeStyle = color; ctxS.lineWidth = 1;
                ctxS.beginPath(); ctxS.moveTo(x,highY); ctxS.lineTo(x,lowY); ctxS.stroke();
                let bodyTop = Math.min(openY,closeY), bodyHeight = Math.abs(closeY-openY);
                if (bodyHeight < 1) bodyHeight = 1;
                ctxS.fillRect(x-w/2,bodyTop,w,bodyHeight);
                ctxS.strokeStyle = '#ffffff'; ctxS.lineWidth = 1; ctxS.strokeRect(x-w/2,bodyTop,w,bodyHeight);
            });
        }
    }

    class CVDIndicator extends BaseIndicator {
        constructor() { super('cvd','Cumulative Volume Delta',150); }
        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;
            ctxS.clearRect(0,0,cssWidth,this.height);
            const cvdData = []; let cumulativeDelta = 0;
            displayCandles.forEach(candle => {
                const tsKey = String(Math.floor(candle.time));
                const buckets = displayClusters[tsKey];
                if (buckets) { let d=0; Object.values(buckets).forEach(b => d+=(b.buy-b.sell)); cumulativeDelta+=d; }
                cvdData.push({ time: candle.time, cvd: cumulativeDelta });
            });
            if (cvdData.length === 0) return;
            const visibleCandles = getVisibleCandles(cssWidth);
            if (visibleCandles.length === 0) return;
            let minCVD = Infinity, maxCVD = -Infinity;
            visibleCandles.forEach(item => {
                const cvdPoint = cvdData.find(d => d.time===item.candle.time);
                if (cvdPoint) { if (cvdPoint.cvd<minCVD) minCVD=cvdPoint.cvd; if (cvdPoint.cvd>maxCVD) maxCVD=cvdPoint.cvd; }
            });
            if (minCVD===Infinity||maxCVD===-Infinity) return;
            if (minCVD===maxCVD) { minCVD-=1000000; maxCVD+=1000000; }
            const padding=config.indicatorPadding, availableH=this.height-(padding*2), cvdRange=maxCVD-minCVD;
            const getCVDY = (val) => padding+(availableH*(1-(val-minCVD)/cvdRange));
            if (minCVD<=0 && maxCVD>=0) {
                const zeroY = getCVDY(0);
                ctxS.strokeStyle='#3a3f4e'; ctxS.lineWidth=1; ctxS.setLineDash([4,4]);
                ctxS.beginPath(); ctxS.moveTo(0,zeroY); ctxS.lineTo(cssWidth,zeroY); ctxS.stroke(); ctxS.setLineDash([]);
            }
            ctxS.beginPath(); let firstPoint=true;
            visibleCandles.forEach(item => {
                const cvdPoint = cvdData.find(d => d.time===item.candle.time);
                if (!cvdPoint) return;
                const y = getCVDY(cvdPoint.cvd);
                if (firstPoint) { ctxS.moveTo(item.x,y); firstPoint=false; } else ctxS.lineTo(item.x,y);
            });
            const finalCVD = cvdData[cvdData.length-1]?.cvd||0;
            const lineColor = finalCVD>=0 ? config.upColor : config.downColor;
            ctxS.strokeStyle=lineColor; ctxS.lineWidth=config.cvdLineThickness; ctxS.stroke();
            ctxS.font=`10px ${config.statsFontFamily}`; ctxS.textAlign='right'; ctxS.fillStyle='#8b92a7';
            ctxS.fillText(formatUSD(maxCVD),cssWidth-5,getCVDY(maxCVD)+12);
            ctxS.fillText(formatUSD(minCVD),cssWidth-5,getCVDY(minCVD)-5);
            if (finalCVD!==undefined) {
                const lastX = visibleCandles[visibleCandles.length-1]?.x||cssWidth-80;
                ctxS.fillStyle=lineColor; ctxS.font=`bold 11px ${config.statsFontFamily}`;
                ctxS.textAlign='left'; ctxS.fillText(formatUSD(finalCVD),lastX+10,getCVDY(finalCVD)+4);
            }
        }
    }

    class IndicatorManager {
        constructor() { this.indicators = new Map(); this.order = []; this.container = document.getElementById('indicators-container'); this.dragState = null; this.placeholder = null; }
        addIndicator(indicator) {
            if (this.indicators.has(indicator.id)) return;
            this.container.appendChild(indicator.createElement());
            this.indicators.set(indicator.id, indicator); this.order.push(indicator.id); indicator.show(); this.updateLayout();
        }
        removeIndicator(id) {
            const indicator = this.indicators.get(id); if (!indicator) return;
            indicator.hide(); indicator.element.remove(); this.indicators.delete(id); this.order = this.order.filter(i=>i!==id); this.updateLayout();
            const toggleBtn = document.getElementById(`toggle-${id}`); if (toggleBtn) toggleBtn.classList.remove('active');
        }
        getIndicator(id) { return this.indicators.get(id); }
        updateLayout() {
            const wrapper = document.getElementById('chart-wrapper');
            const totalHeight = window.innerHeight - HEADER_HEIGHT;
            let totalIndicatorHeight = 0;
            this.order.forEach(id => { const ind = this.indicators.get(id); if (ind && ind.visible) totalIndicatorHeight += ind.height; });
            const marginPct = (totalIndicatorHeight + TIME_AXIS_HEIGHT) / totalHeight;
            chart.priceScale('right').applyOptions({ scaleMargins: { top: 0.05, bottom: marginPct } });
            let currentBottom = TIME_AXIS_HEIGHT;
            this.order.forEach(id => {
                const indicator = this.indicators.get(id); if (!indicator || !indicator.visible) return;
                indicator.element.style.bottom = currentBottom+'px'; indicator.element.style.height = indicator.height+'px';
                indicator.setupBuffers(wrapper.clientWidth, indicator.height); currentBottom += indicator.height;
            });
            chart.applyOptions({ width: wrapper.clientWidth, height: totalHeight }); scheduleDraw();
        }
        startDrag(id, e) {
            const indicator = this.indicators.get(id); if (!indicator) return;
            this.dragState = { id, startY: e.clientY, startOrder: [...this.order] };
            indicator.element.classList.add('dragging');
            this.placeholder = document.createElement('div'); this.placeholder.className = 'drag-placeholder'; this.placeholder.style.height = '2px';
            document.getElementById('chart-wrapper').appendChild(this.placeholder);
            document.addEventListener('mousemove', this.handleDragMove); document.addEventListener('mouseup', this.handleDragEnd);
        }
        handleDragMove = (e) => {
            if (!this.dragState) return;
            const wrapper = document.getElementById('chart-wrapper');
            const relativeY = wrapper.getBoundingClientRect().bottom - e.clientY;
            let insertIndex = 0, cumulativeHeight = TIME_AXIS_HEIGHT;
            for (let i=0; i<this.order.length; i++) {
                const ind = this.indicators.get(this.order[i]); if (!ind || ind.id===this.dragState.id) continue;
                if (relativeY > cumulativeHeight + (ind.height/2)) insertIndex = i+1;
                cumulativeHeight += ind.height;
            }
            let placeholderBottom = TIME_AXIS_HEIGHT;
            for (let i=0; i<insertIndex; i++) { const ind = this.indicators.get(this.order[i]); if (ind && ind.id!==this.dragState.id) placeholderBottom += ind.height; }
            this.placeholder.style.bottom = placeholderBottom+'px';
        }
        handleDragEnd = () => {
            if (!this.dragState) return;
            const indicator = this.indicators.get(this.dragState.id); if (indicator) indicator.element.classList.remove('dragging');
            const placeholderBottom = parseInt(this.placeholder.style.bottom);
            let newOrder = [], cumulativeHeight = TIME_AXIS_HEIGHT, inserted = false;
            this.order.forEach(id => {
                if (id === this.dragState.id) return;
                const ind = this.indicators.get(id); if (!ind) return;
                if (!inserted && cumulativeHeight >= placeholderBottom) { newOrder.push(this.dragState.id); inserted = true; }
                newOrder.push(id); cumulativeHeight += ind.height;
            });
            if (!inserted) newOrder.push(this.dragState.id);
            this.order = newOrder;
            if (this.placeholder) { this.placeholder.remove(); this.placeholder = null; }
            document.removeEventListener('mousemove', this.handleDragMove); document.removeEventListener('mouseup', this.handleDragEnd);
            this.dragState = null; this.updateLayout();
        }
        drawAll(cssWidth) { this.indicators.forEach(ind => { if (ind.visible) { ind.draw(cssWidth); ind.render(); } }); }
    }

    const indicatorManager = new IndicatorManager();
    indicatorManager.addIndicator(new OIIndicator());

    document.getElementById('toggle-oi').addEventListener('click', function() {
        const ind = indicatorManager.getIndicator('oi');
        if (ind && ind.visible) { indicatorManager.removeIndicator('oi'); this.classList.remove('active'); }
        else { indicatorManager.addIndicator(new OIIndicator()); this.classList.add('active'); }
    });
    document.getElementById('toggle-cvd').addEventListener('click', function() {
        const ind = indicatorManager.getIndicator('cvd');
        if (ind && ind.visible) { indicatorManager.removeIndicator('cvd'); this.classList.remove('active'); }
        else { indicatorManager.addIndicator(new CVDIndicator()); this.classList.add('active'); }
    });

    // â”€â”€â”€ Drawing helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function hexToRgba(hex, alpha) {
        const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    function calculateCellOpacity(totalVolume) {
        if (totalVolume < 50000) return 0.10;
        else if (totalVolume < 250000) { const t=(totalVolume-50000)/200000; return 0.40+t*0.20; }
        else if (totalVolume < 1000000) { const t=(totalVolume-250000)/750000; return 0.60+t*0.10; }
        else if (totalVolume < 1200000) { const t=(totalVolume-1000000)/200000; return 0.70+t*0.30; }
        else return 1.0;
    }

    function createSeries(type) {
        if (mainSeries) { try { chart.removeSeries(mainSeries); } catch(e){} mainSeries = null; }
        const options = { upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', borderVisible:false, wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)', priceLineVisible:config.showPriceLine, lastValueVisible:false };
        mainSeries = (type==='candle') ? chart.addCandlestickSeries(options) : chart.addBarSeries(options);
        return mainSeries;
    }

    function updateCandleAppearance() {
        mainSeries.applyOptions({ upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)', priceLineVisible:config.showPriceLine, lastValueVisible:false });
    }

    mainSeries = createSeries(config.seriesType);

    const chartOverlayCanvas = document.getElementById('footprint-overlay');
    const ctxOverlay = chartOverlayCanvas.getContext('2d');
    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');

    function setupBuffersForSize() {
        const dpr = window.devicePixelRatio||1;
        const wrapper = document.getElementById('chart-wrapper');
        const chartW = wrapper.clientWidth, chartH = wrapper.clientHeight;
        chartOverlayCanvas.width = Math.floor(chartW*dpr); chartOverlayCanvas.height = Math.floor(chartH*dpr);
        chartOverlayCanvas.style.width = chartW+'px'; chartOverlayCanvas.style.height = chartH+'px';
        offscreenCanvas.width = chartOverlayCanvas.width; offscreenCanvas.height = chartOverlayCanvas.height;
        offscreenCtx.setTransform(dpr,0,0,dpr,0,0); ctxOverlay.setTransform(1,0,0,1,0,0);
    }

    function formatUSD(val) {
        if (val===0) return '0'; const abs=Math.abs(val);
        if (abs>=1000000) return (val/1000000).toFixed(1)+'M';
        if (abs>=1000) return (val/1000).toFixed(0)+'K';
        return Math.round(val).toString();
    }

    function upsertCandle(tsSec,o,h,l,c) {
        if (!base5mCandles) base5mCandles=[];
        const key=Math.floor(tsSec); let found=false;
        for (let i=base5mCandles.length-1; i>=0; i--) {
            if (Math.floor(base5mCandles[i].time)===key) {
                base5mCandles[i].open=o; base5mCandles[i].high=h; base5mCandles[i].low=l; base5mCandles[i].close=c; found=true; break;
            }
        }
        if (!found) {
            const prevOI = base5mCandles.length>0 ? (base5mCandles[base5mCandles.length-1].oiClose||0) : 0;
            base5mCandles.push({ time:key, open:o, high:h, low:l, close:c, oiOpen:prevOI, oiHigh:prevOI, oiLow:prevOI, oiClose:prevOI });
            base5mCandles.sort((a,b)=>a.time-b.time);
        }
    }

    function getDynamicTickSize(baseTick, minPx) {
        const y1=mainSeries.priceToCoordinate(currentPrice), y2=mainSeries.priceToCoordinate(currentPrice+baseTick);
        if (y1===null||y2===null) return baseTick*2;
        const pxPerBase=Math.abs(y1-y2);
        const multipliers=[1,2,3,4,5,6,7,8,9,10,12,14,16,18,20,25,30,40,50,60,80,100,200];
        for (let m of multipliers) { if (pxPerBase*m>=minPx) return baseTick*m; }
        return baseTick*500;
    }

    function updateCustomPriceLabel() {
        if (!config.showPriceLabel||!mainSeries||!currentPrice) { document.getElementById('custom-price-label').style.display='none'; return; }
        const yCoord=mainSeries.priceToCoordinate(currentPrice);
        if (yCoord===null) { document.getElementById('custom-price-label').style.display='none'; return; }
        const wrapper=document.getElementById('chart-wrapper');
        const marginB=chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY=wrapper.clientHeight*(1-marginB);
        if (yCoord<0||yCoord>candleBottomY) { document.getElementById('custom-price-label').style.display='none'; return; }
        const lastCandle=displayCandles[displayCandles.length-1];
        const isUp=lastCandle?(lastCandle.close>=lastCandle.open):true;
        const color=isUp?config.upColor:config.downColor;
        const labelContainer=document.getElementById('custom-price-label');
        labelContainer.style.display='flex'; labelContainer.style.top=(yCoord-13)+'px';
        labelContainer.style.fontFamily=config.statsFontFamily; labelContainer.style.fontSize=config.priceLabelFontSize+'px';
        const priceText=currentPrice.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
        labelContainer.innerHTML=`<div class="price-label-box" style="border-color:${color};color:${color};">${priceText}</div><div class="price-label-arrow" style="border-width:6px 0 6px 8px;border-color:transparent transparent transparent ${color};"></div>`;
    }

    // Cumulative cluster â€” UNCHANGED, no threshold applied here
    function drawCumulativeCluster(cssWidth, cssHeight, candleBottomY) {
        const timeScale=chart.timeScale(); const barSpacing=timeScale.options().barSpacing;
        const visibleRange=timeScale.getVisibleLogicalRange(); if (!visibleRange) return;
        const renderTickSize=getDynamicTickSize(config.baseTickSize,config.minCellHeight);
        const clusterWidth=barSpacing*2*0.92;
        let rightmostX=0, rightmostTime=0;
        for (let i=displayCandles.length-1; i>=0; i--) {
            const candle=displayCandles[i]; const x=timeScale.timeToCoordinate(candle.time);
            if (x!==null&&x>=0&&x<=cssWidth&&candle.time>rightmostTime) { rightmostTime=candle.time; rightmostX=x; }
        }
        if (rightmostX===0&&displayCandles.length>0) { const x=timeScale.timeToCoordinate(displayCandles[displayCandles.length-1].time); if (x!==null) rightmostX=x; }
        let clusterX=rightmostX+150;
        if (clusterX+clusterWidth>cssWidth-75) clusterX=cssWidth-75-clusterWidth;
        if (clusterX<0) return;
        let aggregatedData={}, totalBuy=0, totalSell=0;
        Object.keys(displayClusters).forEach(timestamp => {
            const ts=parseInt(timestamp); const x=timeScale.timeToCoordinate(ts);
            if (config.cumulativeMode==='visible' && (x===null||x<-100||x>cssWidth+100)) return;
            const rawClusters=displayClusters[timestamp];
            Object.keys(rawClusters).forEach(priceKey => {
                const price=parseFloat(priceKey); const data=rawClusters[priceKey];
                const aggPrice=Math.floor(price/renderTickSize)*renderTickSize;
                if (!aggregatedData[aggPrice]) aggregatedData[aggPrice]={buy:0,sell:0};
                aggregatedData[aggPrice].buy+=data.buy; aggregatedData[aggPrice].sell+=data.sell;
                totalBuy+=data.buy; totalSell+=data.sell;
            });
        });
        if (Object.keys(aggregatedData).length===0) return;
        let pocBucketKey=null, pocTotal=-Infinity;
        Object.keys(aggregatedData).forEach(pk => { const t=aggregatedData[pk].buy+aggregatedData[pk].sell; if (t>pocTotal){pocTotal=t;pocBucketKey=pk;} });
        let minPrice=Infinity, maxPrice=-Infinity;
        Object.keys(aggregatedData).forEach(pk => { const p=parseFloat(pk); if(p<minPrice)minPrice=p; if(p>maxPrice)maxPrice=p; });
        const yTop=mainSeries.priceToCoordinate(maxPrice+renderTickSize), yBottom=mainSeries.priceToCoordinate(minPrice);
        if (yTop===null||yBottom===null) return;
        let clippedYTop, clippedYBottom, clusterBoxHeight, clusterBoxY;
        if (config.cumulativeMode==='all') {
            clippedYTop=yTop; clippedYBottom=yBottom;
            clusterBoxHeight=Math.abs(clippedYBottom-clippedYTop); clusterBoxY=Math.min(clippedYTop,clippedYBottom);
        } else {
            clippedYTop=Math.max(0,Math.min(yTop,candleBottomY)); clippedYBottom=Math.max(0,Math.min(yBottom,candleBottomY));
            if (clippedYTop>=candleBottomY) return;
            clusterBoxHeight=Math.abs(clippedYBottom-clippedYTop); clusterBoxY=Math.min(clippedYTop,clippedYBottom);
        }
        offscreenCtx.fillStyle=hexToRgba(config.panelColor,config.clusterBgOpacity);
        offscreenCtx.fillRect(clusterX,clusterBoxY,clusterWidth,clusterBoxHeight);
        offscreenCtx.strokeStyle='#1a1f2e'; offscreenCtx.lineWidth=config.cellBorderWidth;
        offscreenCtx.strokeRect(clusterX,clusterBoxY,clusterWidth,clusterBoxHeight);
        offscreenCtx.font=`${config.cellFontWeight} ${config.cellFontSize}px ${config.statsFontFamily}`;
        offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";
        Object.keys(aggregatedData).forEach(priceKey => {
            const priceFloor=parseFloat(priceKey); const data=aggregatedData[priceKey];
            let cellYTop=mainSeries.priceToCoordinate(priceFloor+renderTickSize);
            let cellYBottom=mainSeries.priceToCoordinate(priceFloor);
            if (cellYTop===null||cellYBottom===null) return;
            if (config.cumulativeMode==='visible') {
                cellYTop=Math.max(0,Math.min(cellYTop,candleBottomY)); cellYBottom=Math.max(0,Math.min(cellYBottom,candleBottomY));
                if (cellYTop>=candleBottomY) return;
            }
            const heightCell=Math.abs(cellYBottom-cellYTop); const drawY=Math.min(cellYTop,cellYBottom);
            const delta=data.buy-data.sell; const totalVolume=data.buy+data.sell;
            const isBullish=delta>=0;
            const cellColor=isBullish?config.upColor:config.downColor;
            const cellOpacity=calculateCellOpacity(totalVolume);
            offscreenCtx.fillStyle=hexToRgba(cellColor,cellOpacity);
            offscreenCtx.fillRect(clusterX,drawY,clusterWidth,heightCell);
            if (String(priceKey)===String(pocBucketKey)) {
                offscreenCtx.strokeStyle=config.pocColor; offscreenCtx.lineWidth=config.pocBorderWidth;
                offscreenCtx.strokeRect(clusterX,drawY,clusterWidth,heightCell);
            }
            if (heightCell>14) { offscreenCtx.fillStyle='#ffffff'; offscreenCtx.fillText(formatUSD(delta),clusterX+(clusterWidth/2),drawY+(heightCell/2)); }
        });
        const totalDelta=totalBuy-totalSell, statsY=clusterBoxY-25;
        const shouldShowStats=config.cumulativeMode==='all'||(statsY>0&&statsY<candleBottomY);
        if (shouldShowStats) {
            const deltaColor=totalDelta>=0?config.upColor:config.downColor;
            const centerX=clusterX+(clusterWidth/2);
            offscreenCtx.font=`${config.statsFontWeight} ${config.statsFontSize}px ${config.statsFontFamily}`; offscreenCtx.textAlign='center';
            offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText(`V:${formatUSD(totalBuy+totalSell)}`,centerX,statsY-8);
            const deltaValue=formatUSD(totalDelta);
            const dW=offscreenCtx.measureText('D:').width, dvW=offscreenCtx.measureText(deltaValue).width;
            offscreenCtx.textAlign='left';
            offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText('D:',centerX-(dW+dvW)/2,statsY+8);
            offscreenCtx.fillStyle=deltaColor; offscreenCtx.fillText(deltaValue,centerX-(dW+dvW)/2+dW,statsY+8);
            offscreenCtx.textAlign='center';
        }
    }

    function drawFrames() {
        if (!offscreenCtx) return;
        const cssWidth=chartOverlayCanvas.clientWidth, cssHeight=chartOverlayCanvas.clientHeight;
        offscreenCtx.clearRect(0,0,cssWidth,cssHeight);
        const timeScale=chart.timeScale(), barSpacing=timeScale.options().barSpacing;
        const visibleRange=timeScale.getVisibleLogicalRange();
        if (!visibleRange) { ctxOverlay.clearRect(0,0,cssWidth,cssHeight); ctxOverlay.drawImage(offscreenCanvas,0,0); return; }

        const renderTickSize=getDynamicTickSize(config.baseTickSize,config.minCellHeight);
        document.getElementById('tick-display').innerText=`${renderTickSize}`;
        const marginB=chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY=cssHeight*(1-marginB);
        const totalWidth=barSpacing*0.92, candleWidth=totalWidth*config.candleWidthPercent, clusterWidth=totalWidth*config.clusterWidthPercent;
        const timestamps=Object.keys(displayClusters);

        // Grid lines
        offscreenCtx.lineWidth=config.gridLineWidth; offscreenCtx.strokeStyle=hexToRgba(config.gridColor,config.gridOpacity);
        offscreenCtx.beginPath();
        const approxRange=60000;
        const startPrice=Math.floor(currentPrice/config.gridSpacing)*config.gridSpacing-approxRange;
        const endPrice=Math.floor(currentPrice/config.gridSpacing)*config.gridSpacing+approxRange;
        for (let p=startPrice; p<=endPrice; p+=config.gridSpacing) {
            const y=mainSeries.priceToCoordinate?mainSeries.priceToCoordinate(p):null;
            if (y!==null&&y>=0&&y<=candleBottomY) { offscreenCtx.moveTo(0,y); offscreenCtx.lineTo(cssWidth-60,y); }
        }
        offscreenCtx.stroke();

        // Candles
        displayCandles.forEach(candle => {
            const x=timeScale.timeToCoordinate(candle.time);
            if (x===null||x<-100||x>cssWidth+100) return;
            const openY=mainSeries.priceToCoordinate(candle.open), closeY=mainSeries.priceToCoordinate(candle.close);
            const highY=mainSeries.priceToCoordinate(candle.high), lowY=mainSeries.priceToCoordinate(candle.low);
            if (openY===null||closeY===null||highY===null||lowY===null) return;
            const clippedHighY=Math.max(0,highY), clippedLowY=Math.min(candleBottomY,lowY);
            const clippedOpenY=Math.min(candleBottomY,Math.max(0,openY)), clippedCloseY=Math.min(candleBottomY,Math.max(0,closeY));
            if (clippedHighY>candleBottomY) return;
            const isUp=candle.close>=candle.open, color=isUp?config.upColor:config.downColor;
            const colorWithOpacity=hexToRgba(color,config.candleOpacity);
            const startX=x-(totalWidth/2), candleX=startX;
            offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=config.wickThickness;
            offscreenCtx.beginPath(); offscreenCtx.moveTo(candleX+candleWidth/2,clippedHighY); offscreenCtx.lineTo(candleX+candleWidth/2,clippedLowY); offscreenCtx.stroke();
            const bodyTop=Math.min(clippedOpenY,clippedCloseY), bodyHeight=Math.max(1,Math.abs(clippedCloseY-clippedOpenY));
            if (config.seriesType==='candle') {
                offscreenCtx.fillStyle=colorWithOpacity; offscreenCtx.fillRect(candleX,bodyTop,candleWidth,bodyHeight);
                if (config.borderThickness>0) { offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=config.borderThickness; offscreenCtx.strokeRect(candleX,bodyTop,candleWidth,bodyHeight); }
            } else {
                offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=2;
                offscreenCtx.beginPath(); offscreenCtx.moveTo(candleX,clippedOpenY); offscreenCtx.lineTo(candleX+candleWidth/2,clippedOpenY);
                offscreenCtx.moveTo(candleX+candleWidth/2,clippedCloseY); offscreenCtx.lineTo(candleX+candleWidth,clippedCloseY); offscreenCtx.stroke();
            }
        });

        // â”€â”€â”€ Per-candle footprint clusters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        for (let ti=0; ti<timestamps.length; ti++) {
            const timestamp=timestamps[ti], ts=parseInt(timestamp);
            const x=timeScale.timeToCoordinate(ts);
            if (x===null||x<-100||x>cssWidth+100) continue;
            const rawClusters=displayClusters[timestamp];
            if (!rawClusters||Object.keys(rawClusters).length===0) continue;

            let aggregatedData={};
            Object.keys(rawClusters).forEach(priceKey => {
                const price=parseFloat(priceKey), data=rawClusters[priceKey];
                const aggPrice=Math.floor(price/renderTickSize)*renderTickSize;
                if (!aggregatedData[aggPrice]) aggregatedData[aggPrice]={buy:0,sell:0};
                aggregatedData[aggPrice].buy+=data.buy; aggregatedData[aggPrice].sell+=data.sell;
            });

            let pocBucketKey=null, pocTotal=-Infinity;
            const aggKeys=Object.keys(aggregatedData);
            aggKeys.forEach(pk => { const t=aggregatedData[pk].buy+aggregatedData[pk].sell; if(t>pocTotal){pocTotal=t;pocBucketKey=pk;} });

            let minPrice=Infinity, maxPrice=-Infinity;
            aggKeys.forEach(pk => { const p=parseFloat(pk); if(p<minPrice)minPrice=p; if(p>maxPrice)maxPrice=p; });

            const yTop=mainSeries.priceToCoordinate(maxPrice+renderTickSize), yBottom=mainSeries.priceToCoordinate(minPrice);
            if (yTop===null||yBottom===null) continue;
            const clippedYTop=Math.max(0,Math.min(yTop,candleBottomY)), clippedYBottom=Math.max(0,Math.min(yBottom,candleBottomY));
            if (clippedYTop>=candleBottomY) continue;

            const clusterBoxH=Math.abs(clippedYBottom-clippedYTop), clusterBoxY2=Math.min(clippedYTop,clippedYBottom);
            const startX=x-(totalWidth/2), boxX=startX+candleWidth, boxWidth=clusterWidth;

            offscreenCtx.fillStyle=hexToRgba(config.panelColor,config.clusterBgOpacity);
            offscreenCtx.fillRect(boxX,clusterBoxY2,boxWidth,clusterBoxH);
            offscreenCtx.strokeStyle='#1a1f2e'; offscreenCtx.lineWidth=config.cellBorderWidth;
            offscreenCtx.strokeRect(boxX,clusterBoxY2,boxWidth,clusterBoxH);
            offscreenCtx.font=`${config.cellFontWeight} ${config.cellFontSize}px ${config.statsFontFamily}`;
            offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";

            for (let pkIdx=0; pkIdx<aggKeys.length; pkIdx++) {
                const priceKey=aggKeys[pkIdx], priceFloor=parseFloat(priceKey), data=aggregatedData[priceKey];
                let cellYTop=mainSeries.priceToCoordinate(priceFloor+renderTickSize);
                let cellYBottom=mainSeries.priceToCoordinate(priceFloor);
                if (cellYTop===null||cellYBottom===null) continue;
                cellYTop=Math.max(0,Math.min(cellYTop,candleBottomY)); cellYBottom=Math.max(0,Math.min(cellYBottom,candleBottomY));
                if (cellYTop>=candleBottomY) continue;

                const heightCell=Math.abs(cellYBottom-cellYTop), drawY=Math.min(cellYTop,cellYBottom);
                const delta=data.buy-data.sell, totalVolume=data.buy+data.sell;

                // â˜… CHANGE 3: threshold check â€” only for per-candle clusters, cumulative is untouched
                let fillColor;
                if (config.clusterVolumeThreshold > 0 && Math.abs(delta) < config.clusterVolumeThreshold) {
                    // Low-volume cell: override to muted gray at full opacity
                    fillColor = '#485060';
                    offscreenCtx.fillStyle = fillColor;
                } else {
                    // Normal coloring
                    const isBullish = delta >= 0;
                    const cellColor = isBullish ? config.upColor : config.downColor;
                    const cellOpacity = calculateCellOpacity(totalVolume);
                    offscreenCtx.fillStyle = hexToRgba(cellColor, cellOpacity);
                    fillColor = null; // used below for text color decision
                }
                offscreenCtx.fillRect(boxX,drawY,boxWidth,heightCell);

                if (String(priceKey)===String(pocBucketKey)) {
                    offscreenCtx.strokeStyle=config.pocColor; offscreenCtx.lineWidth=config.pocBorderWidth;
                    offscreenCtx.strokeRect(boxX,drawY,boxWidth,heightCell);
                }

                if (heightCell>14) {
                    offscreenCtx.fillStyle='#ffffff';
                    offscreenCtx.fillText(formatUSD(delta),boxX+(boxWidth/2),drawY+(heightCell/2));
                }
            }
        }

        drawCumulativeCluster(cssWidth,cssHeight,candleBottomY);

        // Bubble indicators
        if (displayCandles&&config.minBubbleVolume>0) {
            const currentTime=Date.now();
            const pulsePhase=(currentTime%config.bubblePulseSpeed)/config.bubblePulseSpeed;
            const pulseOpacity=0.3+(Math.sin(pulsePhase*Math.PI*2)*0.3);
            displayCandles.forEach(candle => {
                const x=timeScale.timeToCoordinate(candle.time);
                if (x===null||x<-20||x>cssWidth+20) return;
                const tsKey=String(Math.floor(candle.time)), buckets=displayClusters[tsKey];
                if (!buckets) return;
                let totalBuy=0, totalSell=0;
                Object.values(buckets).forEach(d=>{totalBuy+=d.buy;totalSell+=d.sell;});
                const delta=totalBuy-totalSell;
                if (Math.abs(delta)>=config.minBubbleVolume) {
                    const isBullishCandle=candle.close>=candle.open, isDeltaPositive=delta>=0;
                    const statsY=isBullishCandle?mainSeries.priceToCoordinate(candle.high)-45:mainSeries.priceToCoordinate(candle.low)+40;
                    if (statsY<0||statsY>candleBottomY) return;
                    const dotY=isBullishCandle?statsY-30:statsY+30;
                    const barCenterX=(x-(totalWidth/2))+(totalWidth/2);
                    const dotColor=isDeltaPositive?config.upColor:config.downColor;
                    offscreenCtx.save(); offscreenCtx.globalAlpha=pulseOpacity;
                    offscreenCtx.beginPath(); offscreenCtx.arc(barCenterX,dotY,config.bubbleOuterSize,0,Math.PI*2);
                    offscreenCtx.fillStyle=dotColor; offscreenCtx.fill(); offscreenCtx.restore();
                    offscreenCtx.save(); offscreenCtx.beginPath(); offscreenCtx.arc(barCenterX,dotY,config.bubbleInnerSize,0,Math.PI*2);
                    offscreenCtx.fillStyle=dotColor; offscreenCtx.fill(); offscreenCtx.restore();
                }
            });
        }

        // Per-candle stats + absorption dots
        if (displayCandles) {
            offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";
            displayCandles.forEach(candle => {
                const x=timeScale.timeToCoordinate(candle.time);
                if (x===null||x<-50||x>cssWidth+50) return;
                const tsKey=String(Math.floor(candle.time)), buckets=displayClusters[tsKey];
                if (!buckets) return;
                let totalBuy=0, totalSell=0;
                Object.values(buckets).forEach(d=>{totalBuy+=d.buy;totalSell+=d.sell;});
                const totalVol=totalBuy+totalSell, delta=totalBuy-totalSell;
                if (totalVol===0) return;
                const isBullishCandle=candle.close>=candle.open;
                const oiOpen=candle.oiOpen||0, oiClose=candle.oiClose||0, oiIncreasing=oiClose>oiOpen;
                let vwapNum=0, vwapDen=0;
                Object.keys(buckets).forEach(priceKey => {
                    const price=parseFloat(priceKey), vol=buckets[priceKey].buy+buckets[priceKey].sell;
                    vwapNum+=price*vol; vwapDen+=vol;
                });
                const candleVWAP=vwapDen>0?vwapNum/vwapDen:candle.open;
                const isBullishAbsorption=delta<=-config.absorptionThreshold&&candle.close>candleVWAP&&oiIncreasing;
                const isBearishAbsorption=delta>=config.absorptionThreshold&&candle.close<candleVWAP&&oiIncreasing;
                if (isBullishAbsorption||isBearishAbsorption) {
                    const dotY=isBullishAbsorption?mainSeries.priceToCoordinate(candle.low)+25:mainSeries.priceToCoordinate(candle.high)-25;
                    if (dotY>0&&dotY<candleBottomY) {
                        offscreenCtx.save(); offscreenCtx.shadowColor=config.absorptionColor; offscreenCtx.shadowBlur=config.absorptionGlow; offscreenCtx.fillStyle=config.absorptionColor;
                        offscreenCtx.beginPath(); offscreenCtx.arc(x,dotY,config.absorptionDotSize,0,Math.PI*2); offscreenCtx.fill();
                        offscreenCtx.shadowBlur=0; offscreenCtx.strokeStyle="#FFFFFF"; offscreenCtx.lineWidth=1; offscreenCtx.stroke(); offscreenCtx.restore();
                    }
                }
                const statsY=isBullishCandle?mainSeries.priceToCoordinate(candle.high)-45:mainSeries.priceToCoordinate(candle.low)+40;
                if (statsY<0||statsY>candleBottomY) return;
                const deltaColor=delta>=0?config.upColor:config.downColor;
                const barCenterX=(x-(totalWidth/2))+(totalWidth/2);
                offscreenCtx.font=`${config.statsFontWeight} ${config.statsFontSize}px ${config.statsFontFamily}`;
                offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.textAlign='center';
                offscreenCtx.fillText(`V:${formatUSD(totalVol)}`,barCenterX,statsY-8);
                const deltaValue=formatUSD(delta), dW=offscreenCtx.measureText('D:').width, dvW=offscreenCtx.measureText(deltaValue).width;
                offscreenCtx.textAlign='left';
                offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText('D:',barCenterX-(dW+dvW)/2,statsY+8);
                offscreenCtx.fillStyle=deltaColor; offscreenCtx.fillText(deltaValue,barCenterX-(dW+dvW)/2+dW,statsY+8);
                offscreenCtx.textAlign='center';
            });
        }

        indicatorManager.drawAll(cssWidth);

        // Countdown timer
        const nowSec=Math.floor(Date.now()/1000), barSeconds=getBarSeconds(config.displayTimeframe);
        const diff=(lastBarTime+barSeconds)-nowSec;
        const timerBox=document.getElementById('timer-box'), timerText=document.getElementById('timer-text');
        if (config.showCountdown&&mainSeries&&currentPrice) {
            const yChart=mainSeries.priceToCoordinate(currentPrice);
            if (yChart!==null&&yChart>=0&&yChart<=candleBottomY) {
                if (timerBox.classList.contains('hidden')) { timerBox.classList.remove('hidden'); timerBox.style.display='flex'; }
                timerBox.style.top=(yChart+HEADER_HEIGHT-14)+'px';
                timerBox.style.fontSize=config.timerFontSize+'px'; timerBox.style.fontFamily=config.statsFontFamily;
                const lastC=displayCandles[displayCandles.length-1], isUp=lastC?(lastC.close>=lastC.open):true;
                const bg=isUp?config.upColor:config.downColor;
                timerBox.style.backgroundColor=hexToRgba(bg,config.timerOpacity*0.25); timerBox.style.borderColor=hexToRgba(bg,config.timerOpacity);
                timerBox.querySelector('span').style.backgroundColor=bg;
                timerText.textContent=(diff>0)?formatTime(diff):"0:00";
            } else { if (!timerBox.classList.contains('hidden')) { timerBox.classList.add('hidden'); timerBox.style.display='none'; } }
        } else { if (!timerBox.classList.contains('hidden')) { timerBox.classList.add('hidden'); timerBox.style.display='none'; } }

        updateCustomPriceLabel();
        ctxOverlay.clearRect(0,0,chartOverlayCanvas.width,chartOverlayCanvas.height);
        ctxOverlay.drawImage(offscreenCanvas,0,0);
        needsRedraw=false;
    }

    function formatTime(seconds) {
        if (seconds>=3600) { const h=Math.floor(seconds/3600), m=Math.floor((seconds%3600)/60); return `${h}:${m.toString().padStart(2,'0')}`; }
        const m=Math.floor(seconds/60), s=seconds%60; return `${m}:${s.toString().padStart(2,'0')}`;
    }
    function getIntervalString(tf) { return {1:'1',3:'3',5:'5',15:'15',30:'30',60:'60',240:'240','D':'D'}[tf]||'5'; }
    function getOIIntervalString(tf) { return {1:'5min',3:'5min',5:'5min',15:'15min',30:'30min',60:'1h',240:'4h','D':'1d'}[tf]||'5min'; }
    function getBarSeconds(tfMinutes) { if (tfMinutes==='D') return 86400; return tfMinutes*60; }
    function getWSInterval(tf) { return {1:'1',3:'3',5:'5',15:'15',30:'30',60:'60',240:'240','D':'D'}[tf]||'5'; }

    async function changeTimeframe(newTF) {
        if (newTF < BASE_TIMEFRAME) { alert(`Footprint information will not migrate to timeframes lower than ${BASE_TIMEFRAME}m`); return; }
        applyTimeframeChange(newTF);
    }

    document.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.addEventListener('click', () => { const tf=btn.getAttribute('data-tf'); changeTimeframe(tf==='D'?1440:parseInt(tf)); });
    });

    const ctxMenuMain=document.getElementById('ctx-menu-main'), settingsPanel=document.getElementById('settings-panel');

    document.getElementById('chart-wrapper').addEventListener('contextmenu', (e) => {
        e.preventDefault(); ctxMenuMain.style.left=`${Math.min(e.clientX,window.innerWidth-200)}px`; ctxMenuMain.style.top=`${Math.min(e.clientY,window.innerHeight-100)}px`; ctxMenuMain.classList.remove('hidden');
    });
    document.addEventListener('click', (e) => { if (!e.target.closest('.context-menu')&&!e.target.closest('#settings-panel')&&!e.target.closest('#header-settings-btn')) ctxMenuMain.classList.add('hidden'); });
    document.getElementById('ctx-reset').onclick = () => { chart.timeScale().scrollToRealTime(); chart.priceScale('right').applyOptions({autoScale:true}); };

    const toggleSettings=()=>{ settingsPanel.classList.toggle('-translate-x-full'); settingsPanel.classList.toggle('translate-x-0'); };
    document.getElementById('header-settings-btn').onclick = toggleSettings;
    document.getElementById('close-settings').onclick = toggleSettings;
    document.getElementById('ctx-settings-trigger').onclick = toggleSettings;

    document.getElementById('cumulative-mode-select').onchange = (e) => { config.cumulativeMode=e.target.value; scheduleDraw(); };
    document.getElementById('series-type-select').onchange = (e) => { config.seriesType=e.target.value; mainSeries=createSeries(config.seriesType); mainSeries.setData(displayCandles); updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('up-candle-color').onchange = (e) => { config.upColor=e.target.value; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('down-candle-color').onchange = (e) => { config.downColor=e.target.value; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('candle-opacity').oninput = (e) => { config.candleOpacity=e.target.value/100; document.getElementById('opacity-val').innerText=e.target.value+'%'; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('grid-spacing-input').onchange = (e) => { config.gridSpacing=parseFloat(e.target.value); scheduleDraw(); };
    document.getElementById('grid-color-input').oninput = (e) => { config.gridColor=e.target.value; scheduleDraw(); };
    document.getElementById('bubble-threshold-input').onchange = (e) => { config.minBubbleVolume=parseFloat(e.target.value); scheduleDraw(); };

    function resizeAll() { setupBuffersForSize(); indicatorManager.updateLayout(); }
    window.addEventListener('resize', resizeAll);
    chart.timeScale().subscribeVisibleLogicalRangeChange(()=>scheduleDraw());

    async function init() {
        try {
            const interval=getIntervalString(BASE_TIMEFRAME);
            const response=await fetch(`https://api.bybit.com/v5/market/kline?category=inverse&symbol=BTCUSD&interval=${interval}&limit=1000`);
            const data=await response.json();
            if (data.result&&data.result.list) {
                base5mCandles=data.result.list.map(d=>({
                    time:parseInt(d[0])/1000, open:parseFloat(d[1]), high:parseFloat(d[2]),
                    low:parseFloat(d[3]), close:parseFloat(d[4]), oiOpen:0, oiHigh:0, oiLow:0, oiClose:0
                })).sort((a,b)=>a.time-b.time);
                displayCandles=base5mCandles.slice();
                displayClusters=aggregateClusters(base5mClusters,config.displayTimeframe);
                mainSeries.setData(displayCandles);
                lastBarTime=base5mCandles[base5mCandles.length-1].time;
                currentPrice=base5mCandles[base5mCandles.length-1].close;
                await fetchOpenInterest();
                chart.timeScale().fitContent();
            }
            startWebSockets();
            setInterval(()=>{needsRedraw=true;scheduleDraw();},config.drawDelay);
        } catch(e) { console.error(e); }
    }

    async function fetchOpenInterest() {
        try {
            const oiInterval=getOIIntervalString(BASE_TIMEFRAME);
            const resp=await fetch(`https://api.bybit.com/v5/market/open-interest?category=inverse&symbol=BTCUSD&intervalTime=${oiInterval}&limit=200`);
            const oiData=await resp.json();
            if (oiData.result&&oiData.result.list) {
                const oiMap={}, barSec=getBarSeconds(BASE_TIMEFRAME);
                oiData.result.list.forEach(item=>{ const ts=parseInt(item.timestamp)/1000; oiMap[Math.floor(ts/barSec)*barSec]=parseFloat(item.openInterest); });
                let previousOI=0;
                const firstTs=Object.keys(oiMap).sort()[0];
                if (firstTs) previousOI=oiMap[firstTs]/base5mCandles.find(c=>c.time>=firstTs)?.close||0;
                for (let i=0;i<base5mCandles.length;i++) {
                    const c=base5mCandles[i], foundRawOI=oiMap[c.time];
                    if (foundRawOI) {
                        const oiBTC=foundRawOI/c.close;
                        if (previousOI===0) previousOI=oiBTC;
                        c.oiOpen=previousOI; c.oiClose=oiBTC; c.oiHigh=Math.max(previousOI,oiBTC); c.oiLow=Math.min(previousOI,oiBTC); previousOI=oiBTC;
                    } else { c.oiOpen=previousOI; c.oiClose=previousOI; c.oiHigh=previousOI; c.oiLow=previousOI; }
                }
                displayCandles=base5mCandles.slice();
                if (previousOI>0) document.getElementById('oi-display').innerText=previousOI.toFixed(2);
            }
        } catch(e) { console.error("OI Fetch Error",e); }
    }

    function startWebSockets() {
        const wsInterval=getWSInterval(BASE_TIMEFRAME);
        ws=new WebSocket("wss://stream.bybit.com/v5/public/inverse");
        ws.onopen=()=>ws.send(JSON.stringify({op:"subscribe",args:[`kline.${wsInterval}.BTCUSD`,"publicTrade.BTCUSD","tickers.BTCUSD"]}));
        ws.onmessage=(event)=>{
            const msg=JSON.parse(event.data); if (!msg.data) return;
            if (msg.topic&&msg.topic.includes("tickers")&&msg.data.openInterest) {
                const rawOI=parseFloat(msg.data.openInterest), lastCandle=base5mCandles[base5mCandles.length-1];
                if (lastCandle&&currentPrice>0) {
                    const oiBTC=rawOI/currentPrice;
                    document.getElementById('oi-display').innerText=oiBTC.toFixed(2);
                    if (lastCandle.oiOpen===0||!lastCandle.oiOpen) lastCandle.oiOpen=(base5mCandles.length>1)?base5mCandles[base5mCandles.length-2].oiClose:oiBTC;
                    lastCandle.oiClose=oiBTC; lastCandle.oiHigh=Math.max(lastCandle.oiHigh||-Infinity,oiBTC); lastCandle.oiLow=Math.min(lastCandle.oiLow||Infinity,oiBTC);
                    displayCandles=aggregateCandles(base5mCandles,config.displayTimeframe); scheduleDraw();
                }
            }
            if (msg.topic&&msg.topic.includes("kline")) {
                const k=msg.data[0], ts=parseInt(k.start)/1000;
                if (ts>lastBarTime) {
                    const closingOI=base5mCandles[base5mCandles.length-1]?.oiClose||0;
                    base5mClusters[String(ts)]={};lastBarTime=ts;
                    upsertCandle(ts,parseFloat(k.open),parseFloat(k.high),parseFloat(k.low),parseFloat(k.close));
                    const newCandle=base5mCandles[base5mCandles.length-1];
                    newCandle.oiOpen=closingOI;newCandle.oiClose=closingOI;newCandle.oiHigh=closingOI;newCandle.oiLow=closingOI;
                } else { upsertCandle(ts,parseFloat(k.open),parseFloat(k.high),parseFloat(k.low),parseFloat(k.close)); }
                displayCandles=aggregateCandles(base5mCandles,config.displayTimeframe);
                displayClusters=aggregateClusters(base5mClusters,config.displayTimeframe);
                mainSeries.update(displayCandles[displayCandles.length-1]); scheduleDraw();
            }
            if (msg.topic&&msg.topic.includes("publicTrade")) {
                msg.data.forEach(trade=>{
                    const price=parseFloat(trade.p); currentPrice=price;
                    const valUsd=parseFloat(trade.v);
                    const bucket=Math.floor(price/config.baseTickSize)*config.baseTickSize;
                    const timeKey=String(lastBarTime), bucketKey=String(bucket);
                    if (!base5mClusters[timeKey]) base5mClusters[timeKey]={};
                    if (!base5mClusters[timeKey][bucketKey]) base5mClusters[timeKey][bucketKey]={buy:0,sell:0};
                    if (trade.S==="Buy") base5mClusters[timeKey][bucketKey].buy+=valUsd;
                    else base5mClusters[timeKey][bucketKey].sell+=valUsd;
                    displayClusters=aggregateClusters(base5mClusters,config.displayTimeframe);
                    document.getElementById('price').innerText=price.toLocaleString(); scheduleDraw();
                });
            }
        };
    }

    resizeAll();
    init();
</script>
</body>
</html>
