<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Pro Order Flow - Modular Indicators</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        trade: {
                            bg: '#0a0e1a',
                            panel: '#0f1419',
                            border: '#1a1f2e',
                            accent: '#3b82f6',
                            up: '#608feb',
                            down: '#ff4242',
                            text: '#8b92a7',
                            textLight: '#e8eaed',
                            surface: '#12161f',
                            pocGold: '#f0b90b'
                        }
                    }
                }
            }
        }
    </script>

    <style>
        body { 
            background-color: #0a0e1a; 
            overflow: hidden; 
            user-select: none;
            color: #8b92a7;
        }

        .custom-scroll::-webkit-scrollbar { width: 5px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #1a1f2e; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #2a2f3e; }

        #chart-wrapper { 
            position: relative; 
            flex: 1; 
            min-height: 0; 
            background: #0a0e1a; 
            overflow: hidden; 
        }
        
        #chart-container { 
            width: 100%; 
            height: 100%; 
            z-index: 10;
        }
        
        #footprint-overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            pointer-events: none; 
            z-index: 20;
        }
        
        .indicator-pane { 
            position: absolute; 
            left: 0; 
            right: 77px;
            background: rgba(10, 14, 26, 0.95);
            border-top: 1px solid #1a1f2e; 
            z-index: 30;
            backdrop-filter: blur(4px);
            transition: bottom 0.2s ease;
            pointer-events: none;
        }

        .indicator-pane.dragging {
            z-index: 100;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            border: 1px solid #3b82f6;
        }
        
        .pane-canvas { display: block; width: 100%; height: 100%; pointer-events: none; }
        
        .pane-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            background: transparent;
            cursor: move;
            z-index: 100;
            pointer-events: auto;
        }

        .pane-header:hover {
            background: rgba(10, 14, 26, 0.8);
            backdrop-filter: blur(4px);
        }

        .pane-header:hover .pane-label {
            color: #a6afd3;
        }

        .pane-header:hover .pane-close {
            color: #8b92a7;
        }

        .pane-label { 
            font-size: 9px; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(139, 146, 167, 0.5); 
            font-family: 'JetBrains Mono', monospace; 
            font-weight: 600;
            transition: color 0.2s;
        }

        .pane-close {
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            font-size: 11px;
            color: rgba(139, 146, 167, 0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        .pane-close:hover {
            background: rgba(255, 66, 66, 0.2);
            color: #ff4242;
        }

        .resizer-handle {
            position: absolute;
            top: -5px; 
            left: 0; 
            right: 0;
            height: 10px;
            cursor: ns-resize;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        
        .resizer-line { 
            width: 0%; 
            height: 0px; 
            background: transparent; 
        }
        
        .resizer-handle:hover .resizer-line { 
            background: transparent; 
        }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #e8eaed; border: 2px solid #3b82f6; cursor: pointer; margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #1a1f2e; border-radius: 2px; }

        select, input[type="number"], input[type="text"] {
            appearance: none; background-color: #0f1419; border: 1px solid #1a1f2e;
            color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 12px;
            border-radius: 4px; transition: all 0.2s;
        }
        select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        
        .select-wrapper { position: relative; }
        .select-wrapper::after {
            content: '▼'; font-size: 8px; color: #5a6178; position: absolute;
            right: 10px; top: 50%; transform: translateY(-50%); pointer-events: none;
        }
        
        .color-picker-wrapper {
            position: relative; height: 28px; width: 100%; border-radius: 4px;
            overflow: hidden; border: 1px solid #1a1f2e; cursor: pointer;
        }
        input[type="color"] { border: none; width: 200%; height: 200%; transform: translate(-25%, -25%); cursor: pointer; background: none; }

        .timeframe-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #1a1f2e;
            color: #8b92a7;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timeframe-btn:hover {
            background: #1a1f2e;
            color: #e8eaed;
        }
        .timeframe-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
            font-weight: 600;
        }

        #custom-price-label {
            position: absolute;
            right: 0;
            z-index: 40;
            pointer-events: none;
            font-family: 'JetBrains Mono', monospace;
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .price-label-box {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.05) 100%);
            border: 1.5px solid;
            border-radius: 4px;
            padding: 4px 10px;
            font-weight: 600;
            font-size: 10px;
            letter-spacing: 0.02em;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            position: relative;
        }

        .price-label-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            border-radius: 3px;
            pointer-events: none;
        }

        .price-label-arrow {
            width: 0;
            height: 0;
            border-style: solid;
        }

        .indicator-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid #1a1f2e;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            color: #8b92a7;
        }

        .indicator-toggle:hover {
            background: #1a1f2e;
            color: #e8eaed;
        }

        .indicator-toggle.active {
            background: rgba(59, 130, 246, 0.1);
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .indicator-checkbox {
            width: 14px;
            height: 14px;
            border: 2px solid #1a1f2e;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .indicator-toggle.active .indicator-checkbox {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .indicator-checkbox svg {
            width: 10px;
            height: 10px;
            stroke: white;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .indicator-toggle.active .indicator-checkbox svg {
            opacity: 1;
        }

        .drag-placeholder {
            position: absolute;
            left: 0;
            right: 77px;
            height: 2px;
            background: #3b82f6;
            z-index: 150;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
    </style>
</head>
<body class="font-sans text-trade-text antialiased h-screen flex flex-col">

    <header class="h-[48px] bg-trade-panel/90 backdrop-blur-md border-b border-trade-border flex items-center justify-between px-4 shrink-0 z-50 relative">
        <div class="flex items-center gap-6 font-mono">
            <div class="flex items-center gap-2.5">
                <div class="relative flex h-2 w-2">
                  <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                  <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                </div>
                <div class="flex flex-col leading-none">
                    <span class="text-white font-bold tracking-wider text-sm">BTCUSD</span>
                    <span class="text-[10px] text-gray-500 font-sans">Perpetual</span>
                </div>
                <div class="flex gap-1 ml-2">
                    <button class="timeframe-btn" data-tf="1">1m</button>
                    <button class="timeframe-btn" data-tf="3">3m</button>
                    <button class="timeframe-btn active" data-tf="5">5m</button>
                    <button class="timeframe-btn" data-tf="15">15m</button>
                    <button class="timeframe-btn" data-tf="30">30m</button>
                    <button class="timeframe-btn" data-tf="60">1h</button>
                    <button class="timeframe-btn" data-tf="240">4h</button>
                    <button class="timeframe-btn" data-tf="D">1D</button>
                </div>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-baseline gap-1.5">
                <span id="price" class="text-[#f0b90b] text-lg font-bold tracking-tight">0.00</span>
                <span class="text-[10px] text-gray-500">USD</span>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-center gap-4">
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Tick Size</span>
                    <span id="tick-display" class="text-xs font-medium text-gray-300">5</span>
                </div>
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Open Interest</span>
                    <span id="oi-display" class="text-xs text-blue-400 font-medium font-mono">Loading...</span>
                </div>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
                <span class="text-[10px] text-gray-500 uppercase tracking-wider">Indicators:</span>
                <button id="toggle-oi" class="indicator-toggle active">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="2,6 5,9 10,3"></polyline>
                        </svg>
                    </div>
                    <span>OI</span>
                </button>
                <button id="toggle-cvd" class="indicator-toggle">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="2,6 5,9 10,3"></polyline>
                        </svg>
                    </div>
                    <span>CVD</span>
                </button>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
             <button id="header-settings-btn" class="p-2 hover:bg-[#1a1f2e] rounded-md text-gray-400 hover:text-white transition-all active:scale-95 group">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:rotate-45 transition-transform duration-300"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
             </button>
        </div>
    </header>

    <div id="chart-wrapper">
        <div id="chart-container"></div>
        <canvas id="footprint-overlay"></canvas>
        <div id="custom-price-label"></div>
        
        <div id="indicators-container"></div>
        
        <div id="timer-box" class="hidden absolute right-[10px] bg-black/90 border border-trade-border/50 backdrop-blur text-white px-1 py-1 font-mono text-[11px] font-semibold z-[60] tabular-nums flex items-center gap-1.5 pointer-events-none shadow-lg rounded" style="min-width: 60px;">
            <span class="w-1.5 h-1.5 rounded-full bg-white/90 animate-pulse"></span>
            <span id="timer-text">00:00</span>
        </div>
    </div>

    <div id="settings-panel" class="absolute top-[49px] left-0 bottom-0 w-80 bg-[#0f1419]/95 backdrop-blur-xl border-r border-trade-border z-[1000] transform -translate-x-full transition-transform duration-300 ease-out shadow-2xl flex flex-col">
        <div class="flex items-center justify-between p-5 border-b border-trade-border bg-white/5">
            <h2 class="text-white font-semibold flex items-center gap-2">Chart Settings</h2>
            <button id="close-settings" class="text-gray-500 hover:text-white transition p-1 rounded hover:bg-white/10">✕</button>
        </div>
        <div class="p-6 space-y-8 overflow-y-auto flex-1 custom-scroll">
            <div class="space-y-4">
                <div class="flex items-center gap-2 pb-1 border-b border-white/5">
                    <span class="text-[10px] uppercase font-bold tracking-widest text-blue-500">Style</span>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div class="space-y-1.5">
                        <span class="text-xs text-gray-400 font-medium">Chart Type</span>
                        <div class="select-wrapper">
                            <select id="series-type-select" class="w-full px-2 py-2">
                                <option value="candle" selected>Candles</option>
                                <option value="bar">Bars</option>
                            </select>
                        </div>
                    </div>
                    <div class="space-y-1.5">
                        <span class="text-xs text-gray-400 font-medium">Grid Step ($)</span>
                        <input type="number" id="grid-spacing-input" value="1000" class="w-full px-2 py-2">
                    </div>
                </div>
                <div class="space-y-2">
                    <div class="flex justify-between items-center">
                         <span class="text-xs text-gray-400 font-medium">Opacity</span>
                         <span id="opacity-val" class="text-xs text-white font-mono bg-white/10 px-1.5 rounded">100%</span>
                    </div>
                    <input type="range" id="candle-opacity" min="0" max="100" value="100">
                </div>
            </div>
            <div class="space-y-4">
                <div class="flex items-center gap-2 pb-1 border-b border-white/5">
                    <span class="text-[10px] uppercase font-bold tracking-widest text-blue-500">Colors</span>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div class="space-y-1.5">
                        <span class="text-xs text-gray-400 font-medium">Up Candle</span>
                        <div class="color-picker-wrapper"><input type="color" id="up-candle-color" value="#608feb"></div>
                    </div>
                    <div class="space-y-1.5">
                        <span class="text-xs text-gray-400 font-medium">Down Candle</span>
                        <div class="color-picker-wrapper"><input type="color" id="down-candle-color" value="#ff4242"></div>
                    </div>
                </div>
                <div class="space-y-1.5">
                    <span class="text-xs text-gray-400 font-medium">Grid Lines</span>
                    <div class="color-picker-wrapper"><input type="color" id="grid-color-input" value="#1a1f2e"></div>
                </div>
            </div>
            <div class="space-y-4 pt-2">
                <div class="flex items-center gap-2 pb-1 border-b border-white/5">
                    <span class="text-[10px] uppercase font-bold tracking-widest text-blue-500">Delta Indicators</span>
                </div>
                <div class="space-y-1.5">
                    <span class="text-xs text-gray-400 font-medium">Min Delta (USD)</span>
                    <input type="number" id="bubble-threshold-input" value="500000" step="100000" class="w-full px-3 py-2.5">
                </div>
            </div>
            <div class="space-y-4 pt-2">
                <div class="flex items-center gap-2 pb-1 border-b border-white/5">
                    <span class="text-[10px] uppercase font-bold tracking-widest text-blue-500">Cumulative Cluster Settings</span>
                </div>
                <div class="space-y-1.5">
                    <span class="text-xs text-gray-400 font-medium">Calculation Mode</span>
                    <div class="select-wrapper">
                        <select id="cumulative-mode-select" class="w-full px-2 py-2">
                            <option value="all" selected>All Candles</option>
                            <option value="visible">Visible Candles Only</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="ctx-menu-main" class="hidden absolute w-52 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] text-sm backdrop-blur-sm">
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-reset">
            <span class="font-medium">Reset View</span><span class="text-gray-500 text-xs group-hover:text-blue-400">R</span>
        </div>
        <div class="h-px bg-trade-border mx-2 my-1"></div>
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-settings-trigger">
            <span class="font-medium">Settings</span><span class="text-gray-500 text-[10px] group-hover:text-blue-400">▶</span>
        </div>
    </div>
    <div id="ctx-menu-settings" class="hidden absolute w-48 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] text-sm backdrop-blur-sm">
        <div class="menu-item px-4 py-2 hover:bg-blue-600/10 cursor-pointer text-gray-300 transition-colors" id="toggle-price-line">
            <div class="flex items-center gap-3"><div class="menu-checkbox w-4 h-4 border border-gray-500 rounded flex items-center justify-center bg-blue-600 border-blue-600 transition-colors"><span class="text-white text-[10px] font-bold">✓</span></div>Price Line</div>
        </div>
        <div class="menu-item px-4 py-2 hover:bg-blue-600/10 cursor-pointer text-gray-300 transition-colors" id="toggle-price-label">
            <div class="flex items-center gap-3"><div class="menu-checkbox w-4 h-4 border border-gray-500 rounded flex items-center justify-center bg-blue-600 border-blue-600 transition-colors"><span class="text-white text-[10px] font-bold">✓</span></div>Price Label</div>
        </div>
        <div class="menu-item px-4 py-2 hover:bg-blue-600/10 cursor-pointer text-gray-300 transition-colors" id="toggle-countdown">
            <div class="flex items-center gap-3"><div class="menu-checkbox w-4 h-4 border border-gray-500 rounded flex items-center justify-center bg-blue-600 border-blue-600 transition-colors"><span class="text-white text-[10px] font-bold">✓</span></div>Countdown</div>
        </div>
        <div class="menu-item px-4 py-2 hover:bg-blue-600/10 cursor-pointer text-gray-300 transition-colors" id="toggle-crosshair">
            <div class="flex items-center gap-3"><div class="menu-checkbox w-4 h-4 border border-gray-500 rounded flex items-center justify-center bg-blue-600 border-blue-600 transition-colors"><span class="text-white text-[10px] font-bold">✓</span></div>Crosshair</div>
        </div>
    </div>

<script>
    const HEADER_HEIGHT = 48;
    const TIME_AXIS_HEIGHT = 28;
    const MIN_PANE_HEIGHT = 50;
    
    let config = {
        gridSpacing: 1000, gridColor: '#636363', baseTickSize: 2.5, minCellHeight: 15,
        upColor: '#608feb', downColor: '#ff4242', candleOpacity: 1.0, seriesType: 'candle',
        minBubbleVolume: 500000,
        showPriceLine: true, showPriceLabel: true, showCountdown: true, showCrosshair: true,
        pocColor: '#f0b90b',
        currentTimeframe: 5,
        candleWidthPercent: 0.20,
        clusterWidthPercent: 0.80,
        cumulativeMode: 'all'
    };
    
    let clustersHistory = {}; 
    let lastBarTime = 0;
    let currentPrice = 0;
    let mainSeries;
    let allCandles = []; 
    let ws = null;

    const chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
        layout: { background: { color: '#0a0e1a' }, textColor: '#8b92a7', fontFamily: 'Inter' },
        grid: { vertLines: { visible: false }, horzLines: { visible: false } },
        rightPriceScale: { borderColor: '#1a1f2e', width: 60, scaleMargins: { top: 0.05, bottom: 0.20 } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        timeScale: { borderColor: '#1a1f2e', timeVisible: true, barSpacing: 50, rightOffset: 5, visible: true }
    });

    // ============================================================================
    // CORE VARIABLES - Must be declared before indicator system
    // ============================================================================
    
    let rafId = null, rafRunning = false, needsRedraw = false, lastInteractionTime = 0;
    const INTERACTION_HOLD_MS = 180;

    function scheduleDraw() {
        needsRedraw = true;
        lastInteractionTime = Date.now();
        if (!rafRunning) {
            rafRunning = true;
            const loop = () => {
                const now = Date.now();
                if (now - lastInteractionTime < INTERACTION_HOLD_MS) {
                    drawFrames(); rafId = requestAnimationFrame(loop);
                } else {
                    if (needsRedraw) {
                        needsRedraw = false; drawFrames(); rafId = requestAnimationFrame(loop);
                    } else {
                        rafRunning = false; rafId = null;
                    }
                }
            };
            rafId = requestAnimationFrame(loop);
        }
    }

    function getVisibleCandles(cssWidth) {
        const visibleCandles = [];
        if (!allCandles) return visibleCandles;
        for (let i = 0; i < allCandles.length; i++) {
            const candle = allCandles[i];
            const x = chart.timeScale().timeToCoordinate(candle.time);
            if (x === null || x < -100 || x > cssWidth + 100) continue;
            visibleCandles.push({ i, x, candle });
        }
        return visibleCandles;
    }

    // ============================================================================
    // INDICATOR SYSTEM
    // ============================================================================
    
    class BaseIndicator {
        constructor(id, name, defaultHeight = 150) {
            this.id = id;
            this.name = name;
            this.height = defaultHeight;
            this.element = null;
            this.canvas = null;
            this.ctx = null;
            this.offscreenCanvas = null;
            this.offscreenCtx = null;
            this.visible = false;
        }

        createElement() {
            const div = document.createElement('div');
            div.className = 'indicator-pane';
            div.id = `indicator-${this.id}`;
            div.style.height = this.height + 'px';
            
            div.innerHTML = `
                <div class="pane-header" data-indicator="${this.id}">
                    <span class="pane-label">${this.name}</span>
                    <div class="pane-close" data-indicator="${this.id}">✕</div>
                </div>
                <div class="resizer-handle" data-indicator="${this.id}">
                    <div class="resizer-line"></div>
                </div>
                <canvas class="pane-canvas" id="canvas-${this.id}"></canvas>
            `;
            
            this.element = div;
            this.canvas = div.querySelector(`#canvas-${this.id}`);
            this.ctx = this.canvas.getContext('2d');
            
            this.offscreenCanvas = document.createElement('canvas');
            this.offscreenCtx = this.offscreenCanvas.getContext('2d');
            
            this.setupEventListeners();
            return div;
        }

        setupEventListeners() {
            // Close button
            const closeBtn = this.element.querySelector('.pane-close');
            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                indicatorManager.removeIndicator(this.id);
            });

            // Resize handle
            const resizer = this.element.querySelector('.resizer-handle');
            let dragging = false;
            let startY = 0;
            let startH = 0;

            resizer.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                dragging = true;
                startY = e.clientY;
                startH = this.height;
                document.body.style.cursor = 'ns-resize';
            });

            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                this.height = Math.max(MIN_PANE_HEIGHT, startH + (startY - e.clientY));
                indicatorManager.updateLayout();
            });

            window.addEventListener('mouseup', () => {
                if (dragging) {
                    dragging = false;
                    document.body.style.cursor = '';
                }
            });

            // Drag to reorder
            const header = this.element.querySelector('.pane-header');
            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('pane-close')) return;
                indicatorManager.startDrag(this.id, e);
            });
        }

        setupBuffers(width, height) {
            const dpr = window.devicePixelRatio || 1;
            
            this.canvas.width = Math.floor(width * dpr);
            this.canvas.height = Math.floor(height * dpr);
            this.canvas.style.width = width + 'px';
            this.canvas.style.height = height + 'px';
            
            this.offscreenCanvas.width = this.canvas.width;
            this.offscreenCanvas.height = this.canvas.height;
            
            this.offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        show() {
            this.visible = true;
        }

        hide() {
            this.visible = false;
        }

        draw(cssWidth) {
            // Override in subclass
        }

        render() {
            if (!this.visible || !this.ctx || !this.offscreenCanvas) return;
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(this.offscreenCanvas, 0, 0);
        }
    }

    class OIIndicator extends BaseIndicator {
        constructor() {
            super('oi', 'Open Interest', 200);
        }

        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            
            const ctxS = this.offscreenCtx;
            ctxS.clearRect(0, 0, cssWidth, this.height);
            ctxS.textAlign = 'center';
            
            const barSpacing = chart.timeScale().options().barSpacing;
            const visibleCandles = getVisibleCandles(cssWidth);
            
            let minOI = Infinity, maxOI = -Infinity;
            visibleCandles.forEach(item => {
                const c = item.candle;
                if (c.oiClose && c.oiClose > 0) {
                    const cHigh = c.oiHigh || Math.max(c.oiOpen, c.oiClose);
                    const cLow = c.oiLow || Math.min(c.oiOpen, c.oiClose);
                    if (cHigh > maxOI) maxOI = cHigh;
                    if (cLow < minOI && cLow > 0) minOI = cLow;
                }
            });
            
            if (maxOI === -Infinity || minOI === Infinity) { minOI = 0; maxOI = 100; }
            if (minOI === maxOI) { minOI = maxOI * 0.99; maxOI = maxOI * 1.01; }

            const padding = 10;
            const availableH = this.height - (padding * 2);
            const oiRange = maxOI - minOI;
            
            const getOIY = (val) => {
                if (val <= 0) return this.height - padding;
                const pct = (val - minOI) / oiRange;
                return padding + (availableH * (1 - pct));
            };

            visibleCandles.forEach(item => {
                const { candle, x } = item;
                if (!candle.oiClose || candle.oiClose <= 0) return;
                
                const cOpen = candle.oiOpen || candle.oiClose;
                const cClose = candle.oiClose;
                const cHigh = candle.oiHigh || Math.max(cOpen, cClose);
                const cLow = candle.oiLow || Math.min(cOpen, cClose);

                const openY = getOIY(cOpen);
                const closeY = getOIY(cClose);
                const highY = getOIY(cHigh);
                const lowY = getOIY(cLow);
                
                const isUp = cClose >= cOpen;
                const color = isUp ? config.upColor : config.downColor;
                const w = Math.max(3, barSpacing * 0.5);

                ctxS.fillStyle = color;
                ctxS.strokeStyle = color;
                ctxS.lineWidth = 1;
                ctxS.beginPath();
                ctxS.moveTo(x, highY);
                ctxS.lineTo(x, lowY);
                ctxS.stroke();
                
                let bodyTop = Math.min(openY, closeY);
                let bodyHeight = Math.abs(closeY - openY);
                if (bodyHeight < 1) bodyHeight = 1;
                ctxS.fillRect(x - w/2, bodyTop, w, bodyHeight);
                
                ctxS.strokeStyle = '#ffffff';
                ctxS.lineWidth = 1;
                ctxS.strokeRect(x - w/2, bodyTop, w, bodyHeight);
            });
        }
    }

    class CVDIndicator extends BaseIndicator {
        constructor() {
            super('cvd', 'Cumulative Volume Delta', 150);
        }

        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            
            const ctxS = this.offscreenCtx;
            ctxS.clearRect(0, 0, cssWidth, this.height);
            
            // Calculate CVD for all candles
            const cvdData = [];
            let cumulativeDelta = 0;
            
            allCandles.forEach(candle => {
                const tsKey = String(Math.floor(candle.time));
                const buckets = clustersHistory[tsKey];
                
                if (buckets) {
                    let candleDelta = 0;
                    Object.values(buckets).forEach(d => {
                        candleDelta += (d.buy - d.sell);
                    });
                    cumulativeDelta += candleDelta;
                }
                
                cvdData.push({
                    time: candle.time,
                    cvd: cumulativeDelta
                });
            });

            if (cvdData.length === 0) return;

            // Get visible range
            const visibleCandles = getVisibleCandles(cssWidth);
            if (visibleCandles.length === 0) return;

            // Find min/max CVD in visible range
            let minCVD = Infinity, maxCVD = -Infinity;
            visibleCandles.forEach(item => {
                const cvdPoint = cvdData.find(d => d.time === item.candle.time);
                if (cvdPoint) {
                    if (cvdPoint.cvd < minCVD) minCVD = cvdPoint.cvd;
                    if (cvdPoint.cvd > maxCVD) maxCVD = cvdPoint.cvd;
                }
            });

            if (minCVD === Infinity || maxCVD === -Infinity) return;
            if (minCVD === maxCVD) { minCVD -= 1000000; maxCVD += 1000000; }

            const padding = 10;
            const availableH = this.height - (padding * 2);
            const cvdRange = maxCVD - minCVD;
            
            const getCVDY = (val) => {
                const pct = (val - minCVD) / cvdRange;
                return padding + (availableH * (1 - pct));
            };

            // Draw zero line if in range
            if (minCVD <= 0 && maxCVD >= 0) {
                const zeroY = getCVDY(0);
                ctxS.strokeStyle = '#3a3f4e';
                ctxS.lineWidth = 1;
                ctxS.setLineDash([4, 4]);
                ctxS.beginPath();
                ctxS.moveTo(0, zeroY);
                ctxS.lineTo(cssWidth, zeroY);
                ctxS.stroke();
                ctxS.setLineDash([]);
            }

            // Draw CVD line
            ctxS.beginPath();
            let firstPoint = true;
            
            visibleCandles.forEach(item => {
                const cvdPoint = cvdData.find(d => d.time === item.candle.time);
                if (!cvdPoint) return;
                
                const y = getCVDY(cvdPoint.cvd);
                
                if (firstPoint) {
                    ctxS.moveTo(item.x, y);
                    firstPoint = false;
                } else {
                    ctxS.lineTo(item.x, y);
                }
            });

            const finalCVD = cvdData[cvdData.length - 1]?.cvd || 0;
            const lineColor = finalCVD >= 0 ? config.upColor : config.downColor;
            
            ctxS.strokeStyle = lineColor;
            ctxS.lineWidth = 2;
            ctxS.stroke();

            // Draw value labels
            ctxS.font = '10px "JetBrains Mono", monospace';
            ctxS.textAlign = 'right';
            ctxS.fillStyle = '#8b92a7';
            
            const maxY = getCVDY(maxCVD);
            const minY = getCVDY(minCVD);
            
            ctxS.fillText(formatUSD(maxCVD), cssWidth - 5, maxY + 12);
            ctxS.fillText(formatUSD(minCVD), cssWidth - 5, minY - 5);

            // Current value
            if (finalCVD !== undefined) {
                const currentY = getCVDY(finalCVD);
                const lastX = visibleCandles[visibleCandles.length - 1]?.x || cssWidth - 80;
                
                ctxS.fillStyle = lineColor;
                ctxS.font = 'bold 11px "JetBrains Mono", monospace';
                ctxS.textAlign = 'left';
                ctxS.fillText(formatUSD(finalCVD), lastX + 10, currentY + 4);
            }
        }
    }

    class IndicatorManager {
        constructor() {
            this.indicators = new Map();
            this.order = []; // Track order of indicators (bottom to top)
            this.container = document.getElementById('indicators-container');
            this.dragState = null;
            this.placeholder = null;
        }

        addIndicator(indicator) {
            if (this.indicators.has(indicator.id)) return;
            
            const element = indicator.createElement();
            this.container.appendChild(element);
            this.indicators.set(indicator.id, indicator);
            this.order.push(indicator.id);
            indicator.show();
            this.updateLayout();
        }

        removeIndicator(id) {
            const indicator = this.indicators.get(id);
            if (!indicator) return;
            
            indicator.hide();
            indicator.element.remove();
            this.indicators.delete(id);
            this.order = this.order.filter(i => i !== id);
            this.updateLayout();
            
            // Update toggle button
            const toggleBtn = document.getElementById(`toggle-${id}`);
            if (toggleBtn) {
                toggleBtn.classList.remove('active');
            }
        }

        getIndicator(id) {
            return this.indicators.get(id);
        }

        updateLayout() {
            const wrapper = document.getElementById('chart-wrapper');
            const totalHeight = window.innerHeight - HEADER_HEIGHT;
            
            // Calculate total indicator height
            let totalIndicatorHeight = 0;
            this.order.forEach(id => {
                const indicator = this.indicators.get(id);
                if (indicator && indicator.visible) {
                    totalIndicatorHeight += indicator.height;
                }
            });

            // Update chart margins
            const marginPct = (totalIndicatorHeight + TIME_AXIS_HEIGHT) / totalHeight;
            chart.priceScale('right').applyOptions({
                scaleMargins: { top: 0.05, bottom: marginPct }
            });

            // Position indicators from bottom up
            let currentBottom = TIME_AXIS_HEIGHT;
            
            // Iterate in order (bottom to top)
            this.order.forEach(id => {
                const indicator = this.indicators.get(id);
                if (!indicator || !indicator.visible) return;
                
                indicator.element.style.bottom = currentBottom + 'px';
                indicator.element.style.height = indicator.height + 'px';
                
                const cssWidth = wrapper.clientWidth;
                indicator.setupBuffers(cssWidth, indicator.height);
                
                currentBottom += indicator.height;
            });

            chart.applyOptions({ width: wrapper.clientWidth, height: totalHeight });
            scheduleDraw();
        }

        startDrag(id, e) {
            const indicator = this.indicators.get(id);
            if (!indicator) return;

            this.dragState = {
                id: id,
                startY: e.clientY,
                startOrder: [...this.order]
            };

            indicator.element.classList.add('dragging');
            
            // Create placeholder
            this.placeholder = document.createElement('div');
            this.placeholder.className = 'drag-placeholder';
            this.placeholder.style.height = '2px';
            document.getElementById('chart-wrapper').appendChild(this.placeholder);

            document.addEventListener('mousemove', this.handleDragMove);
            document.addEventListener('mouseup', this.handleDragEnd);
        }

        handleDragMove = (e) => {
            if (!this.dragState) return;

            const wrapper = document.getElementById('chart-wrapper');
            const wrapperRect = wrapper.getBoundingClientRect();
            const relativeY = wrapperRect.bottom - e.clientY;

            // Find insertion point
            let insertIndex = 0;
            let cumulativeHeight = TIME_AXIS_HEIGHT;

            for (let i = 0; i < this.order.length; i++) {
                const ind = this.indicators.get(this.order[i]);
                if (!ind || ind.id === this.dragState.id) continue;

                const midpoint = cumulativeHeight + (ind.height / 2);
                
                if (relativeY > midpoint) {
                    insertIndex = i + 1;
                }
                
                cumulativeHeight += ind.height;
            }

            // Update placeholder position
            let placeholderBottom = TIME_AXIS_HEIGHT;
            for (let i = 0; i < insertIndex; i++) {
                const ind = this.indicators.get(this.order[i]);
                if (ind && ind.id !== this.dragState.id) {
                    placeholderBottom += ind.height;
                }
            }

            this.placeholder.style.bottom = placeholderBottom + 'px';
        }

        handleDragEnd = () => {
            if (!this.dragState) return;

            const indicator = this.indicators.get(this.dragState.id);
            if (indicator) {
                indicator.element.classList.remove('dragging');
            }

            // Calculate new order based on placeholder position
            const placeholderBottom = parseInt(this.placeholder.style.bottom);
            let newOrder = [];
            let cumulativeHeight = TIME_AXIS_HEIGHT;
            let inserted = false;

            this.order.forEach(id => {
                if (id === this.dragState.id) return;
                
                const ind = this.indicators.get(id);
                if (!ind) return;

                if (!inserted && cumulativeHeight >= placeholderBottom) {
                    newOrder.push(this.dragState.id);
                    inserted = true;
                }
                
                newOrder.push(id);
                cumulativeHeight += ind.height;
            });

            if (!inserted) {
                newOrder.push(this.dragState.id);
            }

            this.order = newOrder;

            // Cleanup
            if (this.placeholder) {
                this.placeholder.remove();
                this.placeholder = null;
            }

            document.removeEventListener('mousemove', this.handleDragMove);
            document.removeEventListener('mouseup', this.handleDragEnd);

            this.dragState = null;
            this.updateLayout();
        }

        drawAll(cssWidth) {
            this.indicators.forEach(indicator => {
                if (indicator.visible) {
                    indicator.draw(cssWidth);
                    indicator.render();
                }
            });
        }
    }

    const indicatorManager = new IndicatorManager();

    // Initialize with OI indicator (default)
    const oiIndicator = new OIIndicator();
    indicatorManager.addIndicator(oiIndicator);

    // Indicator toggle buttons
    document.getElementById('toggle-oi').addEventListener('click', function() {
        const indicator = indicatorManager.getIndicator('oi');
        if (indicator && indicator.visible) {
            indicatorManager.removeIndicator('oi');
            this.classList.remove('active');
        } else {
            const oi = new OIIndicator();
            indicatorManager.addIndicator(oi);
            this.classList.add('active');
        }
    });

    document.getElementById('toggle-cvd').addEventListener('click', function() {
        const indicator = indicatorManager.getIndicator('cvd');
        if (indicator && indicator.visible) {
            indicatorManager.removeIndicator('cvd');
            this.classList.remove('active');
        } else {
            const cvd = new CVDIndicator();
            indicatorManager.addIndicator(cvd);
            this.classList.add('active');
        }
    });

    // ============================================================================
    // END INDICATOR SYSTEM
    // ============================================================================

    function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function calculateCellOpacity(totalVolume) {
        if (totalVolume < 50000) return 0.10; 
        else if (totalVolume < 250000) {
            const minVol = 50000, maxVol = 250000, minOp = 0.40, maxOp = 0.60;
            return minOp + ((totalVolume - minVol) / (maxVol - minVol) * (maxOp - minOp));
        } 
        else if (totalVolume < 1000000) {
            const minVol = 250000, maxVol = 1000000, minOp = 0.60, maxOp = 0.7;
            return minOp + ((totalVolume - minVol) / (maxVol - minVol) * (maxOp - minOp));
        } 
        else if (totalVolume < 1200000) {
            const minVol = 1000000, maxVol = 1200000, minOp = 0.7, maxOp = 1.0;
            return minOp + ((totalVolume - minVol) / (maxVol - minVol) * (maxOp - minOp));
        } 
        else return 1.0;
    }

    function createSeries(type) {
        if (mainSeries) { try { chart.removeSeries(mainSeries); } catch(e){ } mainSeries = null; }
        const options = { 
            upColor: 'rgba(0,0,0,0)', 
            downColor: 'rgba(0,0,0,0)', 
            borderVisible: false,
            wickUpColor: 'rgba(0,0,0,0)', 
            wickDownColor: 'rgba(0,0,0,0)', 
            priceLineVisible: config.showPriceLine, 
            lastValueVisible: false
        };
        mainSeries = (type === 'candle') ? chart.addCandlestickSeries(options) : chart.addBarSeries(options);
        return mainSeries;
    }
    
    function updateCandleAppearance() {
        mainSeries.applyOptions({
            upColor: 'rgba(0,0,0,0)', 
            downColor: 'rgba(0,0,0,0)', 
            wickUpColor: 'rgba(0,0,0,0)', 
            wickDownColor: 'rgba(0,0,0,0)',
            priceLineVisible: config.showPriceLine, 
            lastValueVisible: false
        });
    }

    mainSeries = createSeries(config.seriesType);

    const chartOverlayCanvas = document.getElementById('footprint-overlay');
    const ctxOverlay = chartOverlayCanvas.getContext('2d'); 

    const offscreenCanvas = document.createElement('canvas');
    const offscreenCtx = offscreenCanvas.getContext('2d');

    function setupBuffersForSize() {
        const dpr = window.devicePixelRatio || 1;
        const wrapper = document.getElementById('chart-wrapper');
        const chartW = wrapper.clientWidth;
        const chartH = wrapper.clientHeight;

        chartOverlayCanvas.width = Math.floor(chartW * dpr);
        chartOverlayCanvas.height = Math.floor(chartH * dpr);
        chartOverlayCanvas.style.width = chartW + 'px';
        chartOverlayCanvas.style.height = chartH + 'px';
        offscreenCanvas.width = chartOverlayCanvas.width;
        offscreenCanvas.height = chartOverlayCanvas.height;
        offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctxOverlay.setTransform(1, 0, 0, 1, 0, 0);
    }

    function formatUSD(val) {
        if (val === 0) return '0';
        const abs = Math.abs(val);
        if (abs >= 1000000) return (val / 1000000).toFixed(1) + 'M';
        if (abs >= 1000) return (val / 1000).toFixed(0) + 'K';
        return Math.round(val).toString();
    }

    function upsertCandle(tsSec, o, h, l, c) {
        if (!allCandles) allCandles = [];
        const key = Math.floor(tsSec);
        let found = false;
        for (let i = allCandles.length - 1; i >= 0; i--) {
            if (Math.floor(allCandles[i].time) === key) {
                allCandles[i].open = o; allCandles[i].high = h; allCandles[i].low = l; allCandles[i].close = c;
                found = true; break; 
            }
        }
        if(!found){
            let prevOI = allCandles.length > 0 ? (allCandles[allCandles.length-1].oiClose || 0) : 0;
            allCandles.push({ time: key, open: o, high: h, low: l, close: c, oiOpen: prevOI, oiHigh: prevOI, oiLow: prevOI, oiClose: prevOI });
            allCandles.sort((a,b) => a.time - b.time);
        }
    }

    function getDynamicTickSize(baseTick, minPx) {
        const y1 = mainSeries.priceToCoordinate(currentPrice);
        const y2 = mainSeries.priceToCoordinate(currentPrice + baseTick);
        if (y1 === null || y2 === null) return baseTick * 2; 
        const pxPerBase = Math.abs(y1 - y2);
        const multipliers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30, 40, 50, 60, 80, 100, 200];
        for (let m of multipliers) {
            if (pxPerBase * m >= minPx) return baseTick * m;
        }
        return baseTick * 500; 
    }

    function updateCustomPriceLabel() {
        if (!config.showPriceLabel || !mainSeries || !currentPrice) {
            document.getElementById('custom-price-label').style.display = 'none';
            return;
        }

        const yCoord = mainSeries.priceToCoordinate(currentPrice);
        if (yCoord === null) {
            document.getElementById('custom-price-label').style.display = 'none';
            return;
        }

        const wrapper = document.getElementById('chart-wrapper');
        const totalHeight = wrapper.clientHeight;
        const marginB = chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY = totalHeight * (1 - marginB);

        if (yCoord < 0 || yCoord > candleBottomY) {
            document.getElementById('custom-price-label').style.display = 'none';
            return;
        }

        const lastCandle = allCandles[allCandles.length - 1];
        const isUp = lastCandle ? (lastCandle.close >= lastCandle.open) : true;
        const color = isUp ? config.upColor : config.downColor;

        const labelContainer = document.getElementById('custom-price-label');
        labelContainer.style.display = 'flex';
        labelContainer.style.top = (yCoord - 13) + 'px';

        const priceText = currentPrice.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        
        labelContainer.innerHTML = `
            <div class="price-label-box" style="border-color: ${color}; color: ${color};">
                ${priceText}
            </div>
            <div class="price-label-arrow" style="
                border-width: 6px 0 6px 8px;
                border-color: transparent transparent transparent ${color};
            "></div>
        `;
    }

    function drawCumulativeCluster(cssWidth, cssHeight, candleBottomY) {
        const timeScale = chart.timeScale();
        const barSpacing = timeScale.options().barSpacing;
        const visibleRange = timeScale.getVisibleLogicalRange();
        
        if (!visibleRange) return;
        
        const renderTickSize = getDynamicTickSize(config.baseTickSize, config.minCellHeight);
        
        const clusterWidth = barSpacing * 2 * 0.92;
        
        let rightmostX = 0;
        const timestamps = Object.keys(clustersHistory);
        timestamps.forEach(timestamp => {
            const ts = parseInt(timestamp);
            const x = timeScale.timeToCoordinate(ts);
            if (x !== null && x > rightmostX && x < cssWidth) {
                rightmostX = x;
            }
        });
        
        const offsetFromCandles = barSpacing * 20;
        let clusterX = rightmostX + offsetFromCandles;
        
        if (clusterX + clusterWidth > cssWidth - 75) {
            clusterX = cssWidth - 75 - clusterWidth;
        }
        if (clusterX < 0) return;
        
        let aggregatedData = {};
        let totalBuy = 0;
        let totalSell = 0;
        
        timestamps.forEach(timestamp => {
            const ts = parseInt(timestamp);
            const x = timeScale.timeToCoordinate(ts);
            
            if (config.cumulativeMode === 'visible') {
                if (x === null || x < -100 || x > cssWidth + 100) return;
            }
            
            const rawClusters = clustersHistory[timestamp];
            
            Object.keys(rawClusters).forEach(priceKey => {
                const price = parseFloat(priceKey);
                const data = rawClusters[priceKey];
                const aggPrice = Math.floor(price / renderTickSize) * renderTickSize;
                
                if (!aggregatedData[aggPrice]) {
                    aggregatedData[aggPrice] = { buy: 0, sell: 0 };
                }
                
                aggregatedData[aggPrice].buy += data.buy;
                aggregatedData[aggPrice].sell += data.sell;
                
                totalBuy += data.buy;
                totalSell += data.sell;
            });
        });
        
        if (Object.keys(aggregatedData).length === 0) return;
        
        let pocBucketKey = null;
        let pocTotal = -Infinity;
        Object.keys(aggregatedData).forEach(pk => {
            const total = aggregatedData[pk].buy + aggregatedData[pk].sell;
            if (total > pocTotal) {
                pocTotal = total;
                pocBucketKey = pk;
            }
        });
        
        let minPrice = Infinity;
        let maxPrice = -Infinity;
        Object.keys(aggregatedData).forEach(pk => {
            const p = parseFloat(pk);
            if (p < minPrice) minPrice = p;
            if (p > maxPrice) maxPrice = p;
        });
        
        const yTop = mainSeries.priceToCoordinate(maxPrice + renderTickSize);
        const yBottom = mainSeries.priceToCoordinate(minPrice);
        
        if (yTop === null || yBottom === null) return;
        
        let clippedYTop, clippedYBottom, clusterBoxHeight, clusterBoxY;
        
        if (config.cumulativeMode === 'all') {
            clippedYTop = yTop;
            clippedYBottom = yBottom;
            clusterBoxHeight = Math.abs(clippedYBottom - clippedYTop);
            clusterBoxY = Math.min(clippedYTop, clippedYBottom);
        } else {
            clippedYTop = Math.max(0, Math.min(yTop, candleBottomY));
            clippedYBottom = Math.max(0, Math.min(yBottom, candleBottomY));
            
            if (clippedYTop >= candleBottomY) return;
            
            clusterBoxHeight = Math.abs(clippedYBottom - clippedYTop);
            clusterBoxY = Math.min(clippedYTop, clippedYBottom);
        }
        
        offscreenCtx.fillStyle = 'rgba(15, 20, 25, 0.85)';
        offscreenCtx.fillRect(clusterX, clusterBoxY, clusterWidth, clusterBoxHeight);
        
        offscreenCtx.strokeStyle = '#1a1f2e';
        offscreenCtx.lineWidth = 1;
        offscreenCtx.strokeRect(clusterX, clusterBoxY, clusterWidth, clusterBoxHeight);
        
        offscreenCtx.font = '11px "JetBrains Mono", monospace';
        offscreenCtx.textAlign = "center";
        offscreenCtx.textBaseline = "middle";
        
        Object.keys(aggregatedData).forEach(priceKey => {
            const priceFloor = parseFloat(priceKey);
            const data = aggregatedData[priceKey];
            
            let cellYTop = mainSeries.priceToCoordinate(priceFloor + renderTickSize);
            let cellYBottom = mainSeries.priceToCoordinate(priceFloor);
            
            if (cellYTop === null || cellYBottom === null) return;
            
            if (config.cumulativeMode === 'visible') {
                cellYTop = Math.max(0, Math.min(cellYTop, candleBottomY));
                cellYBottom = Math.max(0, Math.min(cellYBottom, candleBottomY));
                
                if (cellYTop >= candleBottomY) return;
            }
            
            const heightCell = Math.abs(cellYBottom - cellYTop);
            const drawY = Math.min(cellYTop, cellYBottom);
            const delta = data.buy - data.sell;
            const totalVolume = data.buy + data.sell;
            
            const isBullish = delta >= 0;
            const cellColor = isBullish ? config.upColor : config.downColor;
            const cellOpacity = calculateCellOpacity(totalVolume);
            
            offscreenCtx.fillStyle = hexToRgba(cellColor, cellOpacity);
            offscreenCtx.fillRect(clusterX, drawY, clusterWidth, heightCell);
            
            if (String(priceKey) === String(pocBucketKey)) {
                offscreenCtx.strokeStyle = config.pocColor;
                offscreenCtx.lineWidth = 1;
                offscreenCtx.strokeRect(clusterX, drawY, clusterWidth, heightCell);
            }
            
            if (heightCell > 14) {
                offscreenCtx.fillStyle = '#ffffff';
                let textStr = formatUSD(delta);
                offscreenCtx.fillText(textStr, clusterX + (clusterWidth / 2), drawY + (heightCell / 2));
            }
        });
        
        const totalDelta = totalBuy - totalSell;
        const statsY = clusterBoxY - 25;
        
        const shouldShowStats = config.cumulativeMode === 'all' || (statsY > 0 && statsY < candleBottomY);
        
        if (shouldShowStats) {
            const deltaColor = totalDelta >= 0 ? config.upColor : config.downColor;
            const centerX = clusterX + (clusterWidth / 2);
            
            offscreenCtx.font = 'bold 11px "JetBrains Mono", monospace';
            offscreenCtx.textAlign = 'center';
            
            offscreenCtx.fillStyle = '#a6afd3';
            offscreenCtx.fillText(`V:${formatUSD(totalBuy + totalSell)}`, centerX, statsY - 8);
            
            const deltaValue = formatUSD(totalDelta);
            const dLabelMetrics = offscreenCtx.measureText('D:');
            const deltaValueMetrics = offscreenCtx.measureText(deltaValue);
            const totalDeltaWidth = dLabelMetrics.width + deltaValueMetrics.width;
            
            offscreenCtx.textAlign = 'left';
            offscreenCtx.fillStyle = '#a6afd3';
            offscreenCtx.fillText('D:', centerX - (totalDeltaWidth / 2), statsY + 8);
            
            offscreenCtx.fillStyle = deltaColor;
            offscreenCtx.fillText(deltaValue, centerX - (totalDeltaWidth / 2) + dLabelMetrics.width, statsY + 8);
            
            offscreenCtx.textAlign = 'center';
        }
    }

    function drawFrames() {
        if (!offscreenCtx) return;
        const cssWidth = chartOverlayCanvas.clientWidth;
        const cssHeight = chartOverlayCanvas.clientHeight;

        offscreenCtx.clearRect(0, 0, cssWidth, cssHeight);

        const timeScale = chart.timeScale();
        const barSpacing = timeScale.options().barSpacing;
        const visibleRange = timeScale.getVisibleLogicalRange();
        
        if (!visibleRange) {
            ctxOverlay.clearRect(0, 0, cssWidth, cssHeight);
            ctxOverlay.drawImage(offscreenCanvas, 0, 0);
            return;
        }

        const renderTickSize = getDynamicTickSize(config.baseTickSize, config.minCellHeight);
        document.getElementById('tick-display').innerText = `${renderTickSize}`;

        const marginB = chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY = cssHeight * (1 - marginB);

        const totalWidth = barSpacing * 0.92;
        const candleWidth = totalWidth * config.candleWidthPercent;
        const clusterWidth = totalWidth * config.clusterWidthPercent;
        
        const timestamps = Object.keys(clustersHistory);

        offscreenCtx.lineWidth = 1; 
        offscreenCtx.strokeStyle = config.gridColor;
        offscreenCtx.beginPath();
        const approxRange = 60000;
        const startPrice = Math.floor(currentPrice / config.gridSpacing) * config.gridSpacing - approxRange;
        const endPrice = Math.floor(currentPrice / config.gridSpacing) * config.gridSpacing + approxRange;
        for (let p = startPrice; p <= endPrice; p += config.gridSpacing) {
            const y = mainSeries.priceToCoordinate ? mainSeries.priceToCoordinate(p) : null;
            if (y !== null && y >= 0 && y <= candleBottomY) {
                offscreenCtx.moveTo(0, y);
                offscreenCtx.lineTo(cssWidth - 60, y);
            }
        }
        offscreenCtx.stroke();
        
        allCandles.forEach(candle => {
            const x = timeScale.timeToCoordinate(candle.time);
            if (x === null || x < -100 || x > cssWidth + 100) return;

            const openY = mainSeries.priceToCoordinate(candle.open);
            const closeY = mainSeries.priceToCoordinate(candle.close);
            const highY = mainSeries.priceToCoordinate(candle.high);
            const lowY = mainSeries.priceToCoordinate(candle.low);
            
            if (openY === null || closeY === null || highY === null || lowY === null) return;

            const clippedHighY = Math.max(0, highY);
            const clippedLowY = Math.min(candleBottomY, lowY);
            const clippedOpenY = Math.min(candleBottomY, Math.max(0, openY));
            const clippedCloseY = Math.min(candleBottomY, Math.max(0, closeY));

            if (clippedHighY > candleBottomY) return;

            const isUp = candle.close >= candle.open;
            const color = isUp ? config.upColor : config.downColor;
            const colorWithOpacity = hexToRgba(color, config.candleOpacity);

            const startX = x - (totalWidth / 2);
            const candleX = startX;

            offscreenCtx.strokeStyle = colorWithOpacity;
            offscreenCtx.lineWidth = 1;
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(candleX + candleWidth/2, clippedHighY);
            offscreenCtx.lineTo(candleX + candleWidth/2, clippedLowY);
            offscreenCtx.stroke();

            const bodyTop = Math.min(clippedOpenY, clippedCloseY);
            const bodyHeight = Math.max(1, Math.abs(clippedCloseY - clippedOpenY));
            
            if (config.seriesType === 'candle') {
                offscreenCtx.fillStyle = colorWithOpacity;
                offscreenCtx.fillRect(candleX, bodyTop, candleWidth, bodyHeight);
            } else {
                offscreenCtx.strokeStyle = colorWithOpacity;
                offscreenCtx.lineWidth = 2;
                offscreenCtx.beginPath();
                offscreenCtx.moveTo(candleX, clippedOpenY);
                offscreenCtx.lineTo(candleX + candleWidth/2, clippedOpenY);
                offscreenCtx.moveTo(candleX + candleWidth/2, clippedCloseY);
                offscreenCtx.lineTo(candleX + candleWidth, clippedCloseY);
                offscreenCtx.stroke();
            }
        });

        for (let ti = 0; ti < timestamps.length; ti++) {
            const timestamp = timestamps[ti];
            const ts = parseInt(timestamp);
            const x = timeScale.timeToCoordinate(ts);
            if (x === null || x < -100 || x > cssWidth + 100) continue;

            const rawClusters = clustersHistory[timestamp];
            let aggregatedData = {};
            
            Object.keys(rawClusters).forEach(priceKey => {
                const price = parseFloat(priceKey);
                const data = rawClusters[priceKey];
                const aggPrice = Math.floor(price / renderTickSize) * renderTickSize;
                if (!aggregatedData[aggPrice]) aggregatedData[aggPrice] = { buy: 0, sell: 0 };
                aggregatedData[aggPrice].buy += data.buy;
                aggregatedData[aggPrice].sell += data.sell;
            });

            let pocBucketKey = null, pocTotal = -Infinity;
            const aggKeys = Object.keys(aggregatedData);
            aggKeys.forEach(pk => {
                const total = aggregatedData[pk].buy + aggregatedData[pk].sell;
                if (total > pocTotal) { pocTotal = total; pocBucketKey = pk; }
            });

            let minPrice = Infinity, maxPrice = -Infinity;
            aggKeys.forEach(pk => {
                const p = parseFloat(pk);
                if(p < minPrice) minPrice = p;
                if(p > maxPrice) maxPrice = p;
            });
            
            const yTop = mainSeries.priceToCoordinate(maxPrice + renderTickSize);
            const yBottom = mainSeries.priceToCoordinate(minPrice);
            
            if(yTop === null || yBottom === null) continue;

            const clippedYTop = Math.max(0, Math.min(yTop, candleBottomY));
            const clippedYBottom = Math.max(0, Math.min(yBottom, candleBottomY));

            if(clippedYTop >= candleBottomY) continue;

            const clusterBoxHeight = Math.abs(clippedYBottom - clippedYTop);
            const clusterBoxY = Math.min(clippedYTop, clippedYBottom);
            
            const startX = x - (totalWidth / 2);
            const boxX = startX + candleWidth;
            const boxWidth = clusterWidth;

            offscreenCtx.fillStyle = 'rgba(15, 20, 25, 0.85)';
            offscreenCtx.fillRect(boxX, clusterBoxY, boxWidth, clusterBoxHeight);
            
            offscreenCtx.strokeStyle = '#1a1f2e';
            offscreenCtx.lineWidth = 1;
            offscreenCtx.strokeRect(boxX, clusterBoxY, boxWidth, clusterBoxHeight);

            offscreenCtx.font = '11px "JetBrains Mono", monospace';
            offscreenCtx.textAlign = "center";
            offscreenCtx.textBaseline = "middle";
            
            for (let pkIdx = 0; pkIdx < aggKeys.length; pkIdx++) {
                const priceKey = aggKeys[pkIdx];
                const priceFloor = parseFloat(priceKey);
                const data = aggregatedData[priceKey];
                
                let cellYTop = mainSeries.priceToCoordinate(priceFloor + renderTickSize);
                let cellYBottom = mainSeries.priceToCoordinate(priceFloor);
                if (cellYTop === null || cellYBottom === null) continue;
                
                cellYTop = Math.max(0, Math.min(cellYTop, candleBottomY));
                cellYBottom = Math.max(0, Math.min(cellYBottom, candleBottomY));

                if(cellYTop >= candleBottomY) continue;

                const heightCell = Math.abs(cellYBottom - cellYTop); 
                const drawY = Math.min(cellYTop, cellYBottom);
                const delta = data.buy - data.sell;
                const totalVolume = data.buy + data.sell;
                
                const isBullish = delta >= 0;
                const cellColor = isBullish ? config.upColor : config.downColor;
                const cellOpacity = calculateCellOpacity(totalVolume);
                
                offscreenCtx.fillStyle = hexToRgba(cellColor, cellOpacity);
                offscreenCtx.fillRect(boxX, drawY, boxWidth, heightCell);
                
                const textColor = '#ffffff';

                if (String(priceKey) === String(pocBucketKey)) {
                    offscreenCtx.strokeStyle = config.pocColor;
                    offscreenCtx.lineWidth = 1;
                    offscreenCtx.strokeRect(boxX, drawY, boxWidth, heightCell);
                }

                if (heightCell > 14) {
                    offscreenCtx.fillStyle = textColor;
                    let textStr = formatUSD(delta);
                    offscreenCtx.fillText(textStr, boxX + (boxWidth/2), drawY + (heightCell/2));
                }
            }
        }

        drawCumulativeCluster(cssWidth, cssHeight, candleBottomY);

        if (allCandles && config.minBubbleVolume > 0) {
            const currentTime = Date.now();
            const pulsePhase = (currentTime % 1500) / 1500;
            const pulseOpacity = 0.3 + (Math.sin(pulsePhase * Math.PI * 2) * 0.3);
            
            allCandles.forEach(candle => {
                const x = timeScale.timeToCoordinate(candle.time);
                if (x === null || x < -20 || x > cssWidth + 20) return;
                const tsKey = String(Math.floor(candle.time));
                const buckets = clustersHistory[tsKey];
                if (!buckets) return;

                let totalBuy = 0, totalSell = 0;
                Object.values(buckets).forEach(d => {
                    totalBuy += d.buy; 
                    totalSell += d.sell;
                });

                const delta = totalBuy - totalSell;
                if (Math.abs(delta) >= config.minBubbleVolume) {
                    const isBullishCandle = candle.close >= candle.open;
                    const isDeltaPositive = delta >= 0;
                    
                    const statsY = isBullishCandle 
                        ? mainSeries.priceToCoordinate(candle.high) - 45 
                        : mainSeries.priceToCoordinate(candle.low) + 40;
                    
                    if(statsY < 0 || statsY > candleBottomY) return;
                    
                    const dotY = isBullishCandle 
                        ? statsY - 30
                        : statsY + 30;
                    
                    const startX = x - (totalWidth / 2);
                    const barCenterX = startX + (totalWidth / 2);
                    
                    const dotColor = isDeltaPositive ? config.upColor : config.downColor;

                    offscreenCtx.save();
                    offscreenCtx.globalAlpha = pulseOpacity;
                    offscreenCtx.beginPath();
                    offscreenCtx.arc(barCenterX, dotY, 10, 0, Math.PI * 2);
                    offscreenCtx.fillStyle = dotColor;
                    offscreenCtx.fill();
                    offscreenCtx.restore();
                    
                    offscreenCtx.save();
                    offscreenCtx.beginPath();
                    offscreenCtx.arc(barCenterX, dotY, 5, 0, Math.PI * 2);
                    offscreenCtx.fillStyle = dotColor;
                    offscreenCtx.fill();
                    offscreenCtx.restore();
                }
            });
        }

        if(allCandles) {
            offscreenCtx.textAlign = "center";
            offscreenCtx.textBaseline = "middle";

            allCandles.forEach(candle => {
                const x = timeScale.timeToCoordinate(candle.time);
                if (x === null || x < -50 || x > cssWidth + 50) return;
                
                const tsKey = String(Math.floor(candle.time));
                const buckets = clustersHistory[tsKey];
                if (!buckets) return;

                let totalBuy = 0, totalSell = 0;
                Object.values(buckets).forEach(d => {
                    totalBuy += d.buy; 
                    totalSell += d.sell;
                });

                const totalVol = totalBuy + totalSell;
                const delta = totalBuy - totalSell;
                
                if(totalVol === 0) return;

                const isBullishCandle = candle.close >= candle.open;
                
                const oiOpen = candle.oiOpen || 0;
                const oiClose = candle.oiClose || 0;
                const oiIncreasing = oiClose > oiOpen;

                let vwapNumerator = 0;
                let vwapDenominator = 0;
                
                Object.keys(buckets).forEach(priceKey => {
                    const price = parseFloat(priceKey);
                    const data = buckets[priceKey];
                    const volume = data.buy + data.sell;
                    vwapNumerator += price * volume;
                    vwapDenominator += volume;
                });
                
                const candleVWAP = vwapDenominator > 0 ? vwapNumerator / vwapDenominator : candle.open;

                const isBullishAbsorption = delta <= -100000 && candle.close > candleVWAP && oiIncreasing;
                const isBearishAbsorption = delta >= 100000 && candle.close < candleVWAP && oiIncreasing;

                if (isBullishAbsorption || isBearishAbsorption) {
                    const dotY = isBullishAbsorption 
                        ? mainSeries.priceToCoordinate(candle.low) + 25 
                        : mainSeries.priceToCoordinate(candle.high) - 25;

                    if (dotY > 0 && dotY < candleBottomY) {
                        offscreenCtx.save();
                        
                        offscreenCtx.shadowColor = "#FFD700";
                        offscreenCtx.shadowBlur = 10;
                        offscreenCtx.fillStyle = "#FFD700";
                        
                        offscreenCtx.beginPath();
                        offscreenCtx.arc(x, dotY, 4, 0, Math.PI * 2);
                        offscreenCtx.fill();

                        offscreenCtx.shadowBlur = 0;
                        offscreenCtx.strokeStyle = "#FFFFFF";
                        offscreenCtx.lineWidth = 1;
                        offscreenCtx.stroke();
                        
                        offscreenCtx.restore();
                    }
                }

                const statsY = isBullishCandle 
                    ? mainSeries.priceToCoordinate(candle.high) - 45
                    : mainSeries.priceToCoordinate(candle.low)  + 40;

                if(statsY < 0 || statsY > candleBottomY) return;

                const deltaColor = delta >= 0 ? config.upColor : config.downColor;
                
                const startX = x - (totalWidth / 2);
                const barCenterX = startX + (totalWidth / 2);
                
                const baseFontSize = Math.max(9, Math.min(14, totalWidth * 0.18));
                const fontWeight = baseFontSize >= 11 ? 'bold' : '600';
                offscreenCtx.font = `${fontWeight} ${baseFontSize}px "JetBrains Mono", monospace`;
                
                const volText = `V:${formatUSD(totalVol)}`;
                const deltaValue = formatUSD(delta);
                const deltaText = `D:${deltaValue}`;
                
                let volMetrics = offscreenCtx.measureText(volText);
                let deltaMetrics = offscreenCtx.measureText(deltaText);
                const maxWidth = totalWidth * 0.95;
                
                let finalFontSize = baseFontSize;
                if (volMetrics.width > maxWidth || deltaMetrics.width > maxWidth) {
                    const scaleFactor = maxWidth / Math.max(volMetrics.width, deltaMetrics.width);
                    finalFontSize = Math.max(7, baseFontSize * scaleFactor);
                    offscreenCtx.font = `${fontWeight} ${finalFontSize}px "JetBrains Mono", monospace`;
                }
                
                offscreenCtx.fillStyle = '#a6afd3';
                offscreenCtx.textAlign = 'center';
                offscreenCtx.fillText(volText, barCenterX, statsY - 8);
                
                const dLabelMetrics = offscreenCtx.measureText('D:');
                const deltaValueMetrics = offscreenCtx.measureText(deltaValue);
                const totalDeltaWidth = dLabelMetrics.width + deltaValueMetrics.width;
                
                offscreenCtx.textAlign = 'left';
                offscreenCtx.fillStyle = '#a6afd3';
                offscreenCtx.fillText('D:', barCenterX - (totalDeltaWidth / 2), statsY + 8);

                offscreenCtx.fillStyle = deltaColor;
                offscreenCtx.fillText(deltaValue, barCenterX - (totalDeltaWidth / 2) + dLabelMetrics.width, statsY + 8);

                offscreenCtx.textAlign = 'center';
            });
        }

        // Draw indicators
        indicatorManager.drawAll(cssWidth);

        const nowSec = Math.floor(Date.now() / 1000);
        const barSeconds = getBarSeconds(config.currentTimeframe);
        const nextBarTime = lastBarTime + barSeconds;
        const diff = nextBarTime - nowSec;
        const timerBox = document.getElementById('timer-box');
        const timerText = document.getElementById('timer-text');
        
        if (config.showCountdown && mainSeries && currentPrice) {
            const yChart = mainSeries.priceToCoordinate(currentPrice);
            
            if (yChart !== null && yChart >= 0 && yChart <= candleBottomY) {
                const yViewport = yChart + HEADER_HEIGHT;
                
                if (timerBox.classList.contains('hidden')) {
                    timerBox.classList.remove('hidden');
                    timerBox.style.display = 'flex';
                }
                
                const timerHeight = 28;
                timerBox.style.top = (yViewport - timerHeight/2) + 'px';

                const lastC = allCandles[allCandles.length - 1];
                const isUp = lastC ? (lastC.close >= lastC.open) : true;
                const bg = isUp ? config.upColor : config.downColor;
                
                timerBox.style.backgroundColor = hexToRgba(bg, 0.25); 
                timerBox.style.borderColor = hexToRgba(bg, 0.8);
                timerBox.querySelector('span').style.backgroundColor = bg; 
                timerText.textContent = (diff > 0) ? formatTime(diff) : "0:00";
            } else {
                if (!timerBox.classList.contains('hidden')) {
                    timerBox.classList.add('hidden');
                    timerBox.style.display = 'none';
                }
            }
        } else {
            if (!timerBox.classList.contains('hidden')) {
                timerBox.classList.add('hidden');
                timerBox.style.display = 'none';
            }
        }

        updateCustomPriceLabel();

        ctxOverlay.clearRect(0, 0, chartOverlayCanvas.width, chartOverlayCanvas.height);
        ctxOverlay.drawImage(offscreenCanvas, 0, 0);

        needsRedraw = false;
    }

    function formatTime(seconds) {
        if (seconds >= 3600) {
            const hours = Math.floor(seconds / 3600);
            const mins = Math.floor((seconds % 3600) / 60);
            return `${hours}:${mins.toString().padStart(2, '0')}`;
        }
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    function getIntervalString(tf) {
        const map = {
            1: '1', 3: '3', 5: '5', 15: '15', 30: '30',
            60: '60', 240: '240', 'D': 'D'
        };
        return map[tf] || '5';
    }

    function getOIIntervalString(tf) {
        const map = {
            1: '5min', 3: '5min', 5: '5min', 15: '15min', 30: '30min',
            60: '1h', 240: '4h', 'D': '1d'
        };
        return map[tf] || '5min';
    }

    function getBarSeconds(tf) {
        if (tf === 'D') return 86400;
        return tf * 60;
    }

    function getWSInterval(tf) {
        const map = {
            1: '1', 3: '3', 5: '5', 15: '15', 30: '30',
            60: '60', 240: '240', 'D': 'D'
        };
        return map[tf] || '5';
    }

    async function changeTimeframe(newTF) {
        config.currentTimeframe = newTF;
        
        if (ws) {
            ws.close();
            ws = null;
        }
        
        clustersHistory = {};
        allCandles = [];
        lastBarTime = 0;
        
        document.querySelectorAll('.timeframe-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-tf="${newTF}"]`).classList.add('active');
        
        await init();
    }

    document.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const tf = btn.getAttribute('data-tf');
            changeTimeframe(tf === 'D' ? 'D' : parseInt(tf));
        });
    });

    const ctxMenuMain = document.getElementById('ctx-menu-main');
    const ctxMenuSettings = document.getElementById('ctx-menu-settings');
    const settingsPanel = document.getElementById('settings-panel');

    document.getElementById('chart-wrapper').addEventListener('contextmenu', (e) => {
        e.preventDefault();
        ctxMenuMain.style.left = `${Math.min(e.clientX, window.innerWidth - 200)}px`;
        ctxMenuMain.style.top = `${Math.min(e.clientY, window.innerHeight - 100)}px`;
        ctxMenuMain.classList.remove('hidden');
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('.context-menu') && !e.target.closest('#settings-panel') && !e.target.closest('#header-settings-btn')) {
            ctxMenuMain.classList.add('hidden'); 
            ctxMenuSettings.classList.add('hidden');
        }
    });

    document.getElementById('ctx-reset').onclick = () => { 
        chart.timeScale().scrollToRealTime(); 
        chart.priceScale('right').applyOptions({ autoScale: true }); 
    };
    
    document.getElementById('ctx-settings-trigger').onmouseenter = () => {
        const rect = ctxMenuMain.getBoundingClientRect();
        ctxMenuSettings.style.left = `${rect.right + 2}px`;
        ctxMenuSettings.style.top = `${rect.top}px`;
        ctxMenuSettings.classList.remove('hidden');
    };

    function toggleCheckboxUI(id, isChecked) {
        const checkbox = document.getElementById(id).querySelector('.menu-checkbox');
        if (isChecked) {
            checkbox.classList.add('bg-blue-600', 'border-blue-600'); 
            checkbox.classList.remove('bg-transparent', 'border-gray-500');
            checkbox.innerHTML = '<span class="text-white text-[10px] font-bold">✓</span>';
        } else {
            checkbox.classList.remove('bg-blue-600', 'border-blue-600'); 
            checkbox.classList.add('bg-transparent', 'border-gray-500');
            checkbox.innerHTML = '';
        }
    }
    
    document.getElementById('toggle-price-line').onclick = () => { 
        config.showPriceLine = !config.showPriceLine; 
        mainSeries.applyOptions({ priceLineVisible: config.showPriceLine }); 
        toggleCheckboxUI('toggle-price-line', config.showPriceLine); 
    };
    
    document.getElementById('toggle-price-label').onclick = () => { 
        config.showPriceLabel = !config.showPriceLabel; 
        toggleCheckboxUI('toggle-price-label', config.showPriceLabel);
        scheduleDraw();
    };
    
    document.getElementById('toggle-countdown').onclick = () => { 
        config.showCountdown = !config.showCountdown; 
        toggleCheckboxUI('toggle-countdown', config.showCountdown); 
        scheduleDraw(); 
    };
    
    document.getElementById('toggle-crosshair').onclick = () => { 
        config.showCrosshair = !config.showCrosshair; 
        chart.applyOptions({ 
            crosshair: { 
                vertLine: { visible: config.showCrosshair }, 
                horzLine: { visible: config.showCrosshair } 
            } 
        }); 
        toggleCheckboxUI('toggle-crosshair', config.showCrosshair); 
    };

    const toggleSettings = () => { 
        settingsPanel.classList.toggle('-translate-x-full'); 
        settingsPanel.classList.toggle('translate-x-0'); 
    };
    
    document.getElementById('header-settings-btn').onclick = toggleSettings;
    document.getElementById('close-settings').onclick = toggleSettings;

    document.getElementById('cumulative-mode-select').onchange = (e) => {
        config.cumulativeMode = e.target.value;
        scheduleDraw();
    };

    function resizeAll() {
        setupBuffersForSize();
        indicatorManager.updateLayout();
    }

    window.addEventListener('resize', resizeAll);
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => scheduleDraw());
    
    document.getElementById('grid-spacing-input').onchange = (e) => { 
        config.gridSpacing = parseFloat(e.target.value); 
        scheduleDraw(); 
    };
    
    document.getElementById('grid-color-input').oninput = (e) => { 
        config.gridColor = e.target.value; 
        scheduleDraw(); 
    };
    
    document.getElementById('bubble-threshold-input').onchange = (e) => { 
        config.minBubbleVolume = parseFloat(e.target.value); 
        scheduleDraw(); 
    };
    
    document.getElementById('series-type-select').onchange = (e) => { 
        config.seriesType = e.target.value; 
        mainSeries = createSeries(config.seriesType); 
        mainSeries.setData(allCandles); 
        updateCandleAppearance(); 
        scheduleDraw(); 
    };
    
    document.getElementById('up-candle-color').onchange = (e) => { 
        config.upColor = e.target.value; 
        updateCandleAppearance(); 
        scheduleDraw(); 
    };
    
    document.getElementById('down-candle-color').onchange = (e) => { 
        config.downColor = e.target.value; 
        updateCandleAppearance(); 
        scheduleDraw(); 
    };
    
    document.getElementById('candle-opacity').oninput = (e) => { 
        config.candleOpacity = e.target.value / 100; 
        document.getElementById('opacity-val').innerText = e.target.value + '%'; 
        updateCandleAppearance(); 
    };

    async function init() {
        try {
            const interval = getIntervalString(config.currentTimeframe);
            const response = await fetch(`https://api.bybit.com/v5/market/kline?category=inverse&symbol=BTCUSD&interval=${interval}&limit=200`);
            const data = await response.json();
            if(data.result && data.result.list){
                allCandles = data.result.list.map(d => ({ 
                    time: parseInt(d[0]) / 1000, 
                    open: parseFloat(d[1]), 
                    high: parseFloat(d[2]), 
                    low: parseFloat(d[3]), 
                    close: parseFloat(d[4]), 
                    oiOpen: 0, 
                    oiHigh: 0, 
                    oiLow: 0, 
                    oiClose: 0
                })).sort((a, b) => a.time - b.time);
                
                mainSeries.setData(allCandles);
                lastBarTime = allCandles[allCandles.length - 1].time;
                currentPrice = allCandles[allCandles.length - 1].close;
                await fetchOpenInterest();
                chart.timeScale().fitContent();
            }
            startWebSockets();
            setInterval(() => { needsRedraw = true; scheduleDraw(); }, 100); 
        } catch(e) { 
            console.error(e); 
        }
    }

    async function fetchOpenInterest() {
        try {
            const oiInterval = getOIIntervalString(config.currentTimeframe);
            const resp = await fetch(`https://api.bybit.com/v5/market/open-interest?category=inverse&symbol=BTCUSD&intervalTime=${oiInterval}&limit=200`);
            const oiData = await resp.json();
            if(oiData.result && oiData.result.list) {
                const oiMap = {};
                const barSec = getBarSeconds(config.currentTimeframe);
                oiData.result.list.forEach(item => { 
                    const ts = parseInt(item.timestamp) / 1000;
                    const normalizedTs = Math.floor(ts / barSec) * barSec;
                    oiMap[normalizedTs] = parseFloat(item.openInterest); 
                });
                
                let previousOI = 0;
                const firstTs = Object.keys(oiMap).sort()[0];
                if(firstTs) previousOI = oiMap[firstTs] / allCandles.find(c => c.time >= firstTs)?.close || 0;
                
                for(let i=0; i<allCandles.length; i++) {
                    const c = allCandles[i];
                    let foundRawOI = oiMap[c.time];
                    if(foundRawOI) {
                        const oiBTC = foundRawOI / c.close;
                        if(previousOI === 0) previousOI = oiBTC;
                        c.oiOpen = previousOI; 
                        c.oiClose = oiBTC; 
                        c.oiHigh = Math.max(previousOI, oiBTC); 
                        c.oiLow = Math.min(previousOI, oiBTC);
                        previousOI = oiBTC;
                    } else { 
                        c.oiOpen = previousOI; 
                        c.oiClose = previousOI; 
                        c.oiHigh = previousOI; 
                        c.oiLow = previousOI; 
                    }
                }
                if(previousOI > 0) document.getElementById('oi-display').innerText = previousOI.toFixed(2);
            }
        } catch(e) { 
            console.error("OI Fetch Error", e); 
        }
    }

    function startWebSockets() {
        const wsInterval = getWSInterval(config.currentTimeframe);
        ws = new WebSocket("wss://stream.bybit.com/v5/public/inverse");
        ws.onopen = () => ws.send(JSON.stringify({ 
            op: "subscribe", 
            args: [`kline.${wsInterval}.BTCUSD`, "publicTrade.BTCUSD", "tickers.BTCUSD"] 
        }));
        
        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            if (!msg.data) return;
            
            if (msg.topic && msg.topic.includes("tickers") && msg.data.openInterest) {
                const rawOI = parseFloat(msg.data.openInterest);
                const lastCandle = allCandles[allCandles.length - 1];
                if(lastCandle && currentPrice > 0) {
                    const oiBTC = rawOI / currentPrice;
                    document.getElementById('oi-display').innerText = oiBTC.toFixed(2);
                    if(lastCandle.oiOpen === 0 || !lastCandle.oiOpen) {
                        lastCandle.oiOpen = (allCandles.length > 1) ? allCandles[allCandles.length-2].oiClose : oiBTC;
                    }
                    lastCandle.oiClose = oiBTC;
                    lastCandle.oiHigh = Math.max(lastCandle.oiHigh||-Infinity, oiBTC);
                    lastCandle.oiLow = Math.min(lastCandle.oiLow||Infinity, oiBTC);
                    scheduleDraw();
                }
            }
            
            if (msg.topic && msg.topic.includes("kline")) {
                const k = msg.data[0];
                const ts = parseInt(k.start) / 1000;
                if (ts > lastBarTime) {
                    const closingOI = allCandles[allCandles.length - 1]?.oiClose || 0;
                    clustersHistory[ts] = {}; 
                    lastBarTime = ts; 
                    upsertCandle(ts, parseFloat(k.open), parseFloat(k.high), parseFloat(k.low), parseFloat(k.close));
                    const newCandle = allCandles[allCandles.length - 1];
                    newCandle.oiOpen = closingOI; 
                    newCandle.oiClose = closingOI; 
                    newCandle.oiHigh = closingOI; 
                    newCandle.oiLow = closingOI;
                } else {
                    upsertCandle(ts, parseFloat(k.open), parseFloat(k.high), parseFloat(k.low), parseFloat(k.close));
                }
                mainSeries.update({ 
                    time: ts, 
                    open: parseFloat(k.open), 
                    high: parseFloat(k.high), 
                    low: parseFloat(k.low), 
                    close: parseFloat(k.close) 
                });
                scheduleDraw();
            }
            
            if (msg.topic && msg.topic.includes("publicTrade")) {
                msg.data.forEach(trade => {
                    const price = parseFloat(trade.p); 
                    currentPrice = price;
                    const valUsd = parseFloat(trade.v);
                    const bucket = Math.floor(price / config.baseTickSize) * config.baseTickSize;
                    
                    if (!clustersHistory[lastBarTime]) clustersHistory[lastBarTime] = {};
                    if (!clustersHistory[lastBarTime][bucket]) clustersHistory[lastBarTime][bucket] = { buy: 0, sell: 0 };
                    
                    if (trade.S === "Buy") clustersHistory[lastBarTime][bucket].buy += valUsd;
                    else clustersHistory[lastBarTime][bucket].sell += valUsd;
                    
                    document.getElementById('price').innerText = price.toLocaleString();
                    scheduleDraw();
                });
            }
        };
    }

    resizeAll();
    init();
</script>
</body>
</html>
