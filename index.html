<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BTC Pro Order Flow - Enhanced Settings</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>ðŸ“Š</text></svg>">
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lightweight-charts@4.1.1/dist/lightweight-charts.standalone.production.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;600;700&family=Fira+Code:wght@400;500;600;700&display=swap" rel="stylesheet">

    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        trade: {
                            bg: '#0a0e1a',
                            panel: '#0f1419',
                            border: '#1a1f2e',
                            accent: '#3b82f6',
                            up: '#608feb',
                            down: '#ff4242',
                            text: '#8b92a7',
                            textLight: '#e8eaed',
                            surface: '#12161f',
                            pocGold: '#f0b90b'
                        }
                    }
                }
            }
        }
    </script>
    <style>

         #layouts-dropdown.open {
            display: block !important;
            opacity: 1;
            transform: scaleY(1);
        }
        #layouts-dropdown {
            transform-origin: top;
        }

        body { 
            background-color: #0a0e1a; 
            overflow: hidden; 
            user-select: none;
            color: #8b92a7;
        }

        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: transparent; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #1a1f2e; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #2a2f3e; }

        #panel-wrapper-0 { 
            position: relative; 
            flex: 1; 
            min-height: 0; 
            background: #0a0e1a; 
            overflow: hidden; 
        }
        
        #chart-container { 
            width: 100%; 
            height: 100%; 
            z-index: 10;
        }
        
        #footprint-overlay { 
            position: absolute; 
            top: 0; 
            left: 0; 
            pointer-events: none; 
            z-index: 20;
        }
        
    .indicator-pane { 
    position: absolute; 
    left: 0; 
    right: 54;
    background: rgba(10, 14, 26, 0.95);
    border-top: 1px solid #1a1f2e; 
    z-index: 30;
    backdrop-filter: blur(4px);
    transition: bottom 0.2s ease;
    pointer-events: none;
    }
        .indicator-pane.dragging {
            z-index: 100;
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            border: 1px solid #3b82f6;
        }
        
        .pane-canvas { display: block; width: 100%; height: 100%; pointer-events: none; }
        
        .pane-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 8px;
            background: transparent;
            cursor: move;
            z-index: 100;
            pointer-events: auto;
        }

        .pane-header:hover {
            background: rgba(10, 14, 26, 0.8);
            backdrop-filter: blur(4px);
        }

        .pane-header:hover .pane-label { color: #a6afd3; }
        .pane-header:hover .pane-close { color: #8b92a7; }

        .pane-label { 
            font-size: 9px; 
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: rgba(139, 146, 167, 0.5); 
            font-family: 'JetBrains Mono', monospace; 
            font-weight: 600;
            transition: color 0.2s;
        }

        .pane-close {
            width: 14px;
            height: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            font-size: 11px;
            color: rgba(139, 146, 167, 0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        .pane-close:hover {
            background: rgba(255, 66, 66, 0.2);
            color: #ff4242;
        }

        .resizer-handle {
            position: absolute;
            top: -5px; 
            left: 0; 
            right: 0;
            height: 10px;
            cursor: ns-resize;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        
        .resizer-line { width: 0%; height: 0px; background: transparent; }
        .resizer-handle:hover .resizer-line { background: transparent; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: #e8eaed; border: 2px solid #3b82f6; cursor: pointer; margin-top: -5px;
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #1a1f2e; border-radius: 2px; }

        select, input[type="number"], input[type="text"] {
            appearance: none; background-color: #0f1419; border: 1px solid #1a1f2e;
            color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 12px;
            border-radius: 4px; transition: all 0.2s;
        }
        select:focus, input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        
        .select-wrapper { position: relative; }
        .select-wrapper::after {
            content: 'â–¼'; font-size: 8px; color: #5a6178; position: absolute;
            right: 10px; top: 50%; transform: translateY(-50%); pointer-events: none;
        }
        
        .color-picker-wrapper {
            position: relative; height: 28px; width: 100%; border-radius: 4px;
            overflow: hidden; border: 1px solid #1a1f2e; cursor: pointer;
            transition: all 0.2s;
        }
        .color-picker-wrapper:hover { border-color: #3b82f6; box-shadow: 0 0 0 1px #3b82f6; }
        input[type="color"] { border: none; width: 200%; height: 200%; transform: translate(-25%, -25%); cursor: pointer; background: none; }

        .timeframe-btn {
            padding: 4px 10px;
            background: transparent;
            border: 1px solid #1a1f2e;
            color: #8b92a7;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timeframe-btn:hover { background: #1a1f2e; color: #e8eaed; }
        .timeframe-btn.active { background: #3b82f6; border-color: #3b82f6; color: white; font-weight: 600; }

        .timeframe-btn-plus {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid #1a1f2e;
            color: #8b92a7;
            font-size: 14px;
            font-family: 'JetBrains Mono', monospace;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .timeframe-btn-plus:hover { background: #1a1f2e; color: #3b82f6; border-color: #3b82f6; transform: rotate(90deg); }

        #custom-price-label {
            position: absolute;
            right: 0;
            z-index: 40;
            pointer-events: none;
            display: flex;
            align-items: center;
            gap: 1px;
        }

        .price-label-box {
            border-radius: 4px;
            padding: 5px 10px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            min-width: 68px;
            gap: 2px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .price-label-box::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            border-radius: 3px;
            pointer-events: none;
        }

            .price-label-arrow {display: none !important;}

        .indicator-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid #1a1f2e;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            color: #8b92a7;
        }
        .indicator-toggle:hover { background: #1a1f2e; color: #e8eaed; }
        .indicator-toggle.active { background: rgba(59, 130, 246, 0.1); border-color: #3b82f6; color: #3b82f6; }

        .indicator-checkbox {
            width: 14px; height: 14px;
            border: 2px solid #1a1f2e;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        .indicator-toggle.active .indicator-checkbox { background: #3b82f6; border-color: #3b82f6; }
        .indicator-checkbox svg { width: 10px; height: 10px; stroke: white; opacity: 0; transition: opacity 0.2s; }
        .indicator-toggle.active .indicator-checkbox svg { opacity: 1; }

        .drag-placeholder {
            position: absolute;
            left: 0; right: 77px;
            height: 2px;
            background: #3b82f6;
            z-index: 150;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }

        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .modal-overlay.active { opacity: 1; pointer-events: all; }

        .modal-content {
            background: linear-gradient(135deg, #0d1117 0%, #0f1419 100%);
            border: 1px solid #1a1f2e;
            border-radius: 12px;
            padding: 32px;
            min-width: 400px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .modal-overlay.active .modal-content { transform: scale(1); }

        .modal-title { font-family: 'JetBrains Mono', monospace; font-size: 18px; font-weight: 600; color: #e8eaed; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-description { font-size: 13px; color: #8b92a7; margin-bottom: 24px; line-height: 1.5; }
        .modal-input { width: 100%; padding: 12px 16px; background: #0a0e1a; border: 2px solid #1a1f2e; border-radius: 8px; color: #e8eaed; font-family: 'JetBrains Mono', monospace; font-size: 16px; transition: all 0.2s; margin-bottom: 24px; }
        .modal-input:focus { outline: none; border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1); }
        .modal-buttons { display: flex; gap: 12px; justify-content: flex-end; }
        .modal-btn { padding: 10px 24px; border-radius: 6px; font-family: 'JetBrains Mono', monospace; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 0.05em; }
        .modal-btn-cancel { background: transparent; border: 1px solid #1a1f2e; color: #8b92a7; }
        .modal-btn-cancel:hover { background: #1a1f2e; color: #e8eaed; }
        .modal-btn-confirm { background: #3b82f6; border: 1px solid #3b82f6; color: white; }
        .modal-btn-confirm:hover { background: #2563eb; border-color: #2563eb; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3); }

        #settings-panel { background: linear-gradient(135deg, #0d1117 0%, #0f1419 100%); }

        .settings-section { border-bottom: 1px solid rgba(26, 31, 46, 0.5); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section:last-child { border-bottom: none; }

        .section-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 16px 20px; cursor: pointer; transition: all 0.2s ease;
            background: transparent; position: relative; overflow: hidden;
        }
        .section-header::before {
            content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
            background: #3b82f6; transform: scaleY(0); transition: transform 0.3s ease;
        }
        .section-header:hover { background: rgba(59, 130, 246, 0.05); }
        .section-header:hover::before { transform: scaleY(1); }

        .section-title-wrapper { display: flex; align-items: center; gap: 12px; }
        .section-icon { width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: #3b82f6; opacity: 0.8; transition: all 0.3s ease; }
        .section-header:hover .section-icon { opacity: 1; transform: scale(1.1); }
        .section-title { font-family: 'JetBrains Mono', monospace; font-size: 13px; font-weight: 600; color: #e8eaed; text-transform: uppercase; letter-spacing: 0.05em; }

        .section-chevron { width: 16px; height: 16px; color: #5a6178; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section.expanded .section-chevron { transform: rotate(180deg); color: #3b82f6; }

        .section-content { max-height: 0; overflow: hidden; transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1); }
        .settings-section.expanded .section-content { max-height: 2000px; }

        .section-body { padding: 0 20px 20px 20px; display: grid; gap: 16px; }
        .setting-group { display: grid; gap: 12px; }
        .setting-row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
        .setting-item { display: flex; flex-direction: column; gap: 6px; }
        .setting-item.full-width { grid-column: 1 / -1; }

        .setting-label { font-size: 11px; font-weight: 500; color: #a6afd3; text-transform: uppercase; letter-spacing: 0.05em; font-family: 'JetBrains Mono', monospace; }
        .setting-description { font-size: 10px; color: #5a6178; margin-top: -2px; font-family: 'Inter', sans-serif; }

        .slider-container { display: flex; flex-direction: column; gap: 8px; }
        .slider-header { display: flex; justify-content: space-between; align-items: center; }
        .slider-value { font-family: 'JetBrains Mono', monospace; font-size: 11px; font-weight: 600; color: #3b82f6; background: rgba(59, 130, 246, 0.1); padding: 2px 8px; border-radius: 3px; min-width: 50px; text-align: center; }

        .setting-divider { height: 1px; background: linear-gradient(90deg, transparent 0%, rgba(26, 31, 46, 0.5) 50%, transparent 100%); margin: 8px 0; }

        .font-preview { padding: 8px 12px; background: rgba(10, 14, 26, 0.5); border: 1px solid #1a1f2e; border-radius: 4px; font-size: 12px; color: #8b92a7; text-align: center; transition: all 0.2s; }
        .font-preview:hover { border-color: #3b82f6; color: #e8eaed; }

        .toggle-switch {
            position: relative; width: 44px; height: 24px;
            background: #1a1f2e; border-radius: 12px; cursor: pointer;
            transition: all 0.3s ease; border: 1px solid #1a1f2e;
        }
        .toggle-switch.active { background: #3b82f6; border-color: #3b82f6; }
        .toggle-switch::after {
            content: ''; position: absolute; top: 2px; left: 2px;
            width: 18px; height: 18px; background: white; border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .toggle-switch.active::after { transform: translateX(20px); }

        .reset-button {
            padding: 8px 16px; background: rgba(255, 66, 66, 0.1); border: 1px solid rgba(255, 66, 66, 0.3);
            color: #ff4242; border-radius: 4px; font-family: 'JetBrains Mono', monospace;
            font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.05em;
        }
        .reset-button:hover { background: rgba(255, 66, 66, 0.2); border-color: #ff4242; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(255, 66, 66, 0.2); }
        .reset-button:active { transform: translateY(0); }

        /* â”€â”€ TPO Legend badge â”€â”€ */
        .tpo-legend {
            display: inline-flex; align-items: center; gap: 5px;
            font-family: 'JetBrains Mono', monospace; font-size: 10px;
            padding: 3px 8px; border-radius: 3px;
            border: 1px solid rgba(255,255,255,0.08);
        }
        .tpo-swatch { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }

        /* â”€â”€ Multi-panel layout â”€â”€ */
        #charts-container { display:flex; flex-direction:row; flex:1; min-height:0; overflow:hidden; }
        .chart-panel-wrapper { position:relative; display:flex; flex-direction:column; min-width:150px; overflow:hidden; }
        .vertical-resizer {
            width:5px; background:#1a1f2e; cursor:col-resize; flex-shrink:0;
            z-index:100; transition:background 0.15s;
            display:flex; align-items:center; justify-content:center;
        }
        .vertical-resizer::after { content:''; width:1px; height:30px; background:rgba(139,146,167,0.18); border-radius:1px; }
        .vertical-resizer:hover, .vertical-resizer.resizing { background:rgba(59,130,246,0.2); }
        .vertical-resizer:hover::after, .vertical-resizer.resizing::after { background:#3b82f6; box-shadow:0 0 6px rgba(59,130,246,0.5); }
        .panel-close-btn {
            position:absolute; top:6px; right:84px; z-index:200;
            background:rgba(255,66,66,0.15); border:1px solid rgba(255,66,66,0.3);
            color:#ff4242; border-radius:4px; width:22px; height:22px;
            display:flex; align-items:center; justify-content:center;
            cursor:pointer; font-size:11px; opacity:0; pointer-events:none; transition:all 0.2s;
        }
        .chart-panel-wrapper:hover .panel-close-btn { opacity:1; pointer-events:all; }
        .panel-close-btn:hover { background:rgba(255,66,66,0.4); border-color:#ff4242; }
        .panel-tf-bar {
            position:absolute; top:6px; left:6px; z-index:200;
            display:flex; gap:3px; opacity:0; pointer-events:none; transition:opacity 0.2s;
            background:rgba(10,14,26,0.88); border:1px solid #1a1f2e;
            border-radius:5px; padding:3px 4px; backdrop-filter:blur(4px);
        }
        .chart-panel-wrapper:hover .panel-tf-bar { opacity:1; pointer-events:all; }

        .chart-panel-wrapper.selected {
    box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.4);
    
}

    </style>
</head>
<body class="font-sans text-trade-text antialiased h-screen flex flex-col">

    <header class="h-[48px] bg-trade-panel/90 backdrop-blur-md border-b border-trade-border flex items-center justify-between px-4 shrink-0 z-50 relative">
        <div class="flex items-center gap-6 font-mono">
            <div class="flex items-center gap-2.5">
                <div class="relative flex h-2 w-2">
                  <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                  <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                </div>
                <div class="flex flex-col leading-none">
                    <span class="text-white font-bold tracking-wider text-sm">BTCUSD</span>
                    <span class="text-[10px] text-gray-500 font-sans">Perpetual</span>
                </div>
                <div class="flex gap-1 ml-2">
                    <button class="timeframe-btn" data-tf="1">1m</button>
                    <button class="timeframe-btn" data-tf="3">3m</button>
                    <button class="timeframe-btn active" data-tf="5">5m</button>
                    <button class="timeframe-btn" data-tf="15">15m</button>
                    <button class="timeframe-btn" data-tf="30">30m</button>
                    <button class="timeframe-btn" data-tf="60">1h</button>
                    <button class="timeframe-btn" data-tf="240">4h</button>
                    <button class="timeframe-btn" data-tf="D">1D</button>
                    <button class="timeframe-btn-plus" id="custom-tf-btn">+</button>
                </div>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-baseline gap-1.5">
                <span id="price" class="text-[#f0b90b] text-lg font-bold tracking-tight">0.00</span>
                <span class="text-[10px] text-gray-500">USD</span>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="flex items-center gap-4">
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Tick Size</span>
                    <span id="tick-display" class="text-xs font-medium text-gray-300">5</span>
                </div>
                <div class="flex flex-col items-start leading-none gap-0.5">
                    <span class="text-[9px] text-gray-500 uppercase tracking-wider font-sans">Open Interest</span>
                    <span id="oi-display" class="text-xs text-blue-400 font-medium font-mono">Loading...</span>
                </div>
            </div>
        </div>
        <div class="flex items-center gap-3">
            <div class="flex items-center gap-2">
                <span class="text-[10px] text-gray-500 uppercase tracking-wider">Indicators:</span>
                <button id="toggle-oi" class="indicator-toggle active">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>OI</span>
                </button>
                <button id="toggle-cvd" class="indicator-toggle">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>CVD</span>
                </button>
                <button id="toggle-barstats" class="indicator-toggle">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>Bar Stats</span>
                </button>
                <!-- â˜… TPO Toggle Button -->
                <button id="toggle-tpo" class="indicator-toggle">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>TPO</span>
                </button>
                <!-- â˜… VWAP Toggle Button -->
                <button id="toggle-vwap" class="indicator-toggle">
                    <div class="indicator-checkbox">
                        <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                    </div>
                    <span>VWAP</span>
                </button>
                <button id="toggle-dailylevels" class="indicator-toggle">
                <!-- â˜… key levels Toggle Button -->
                <div class="indicator-checkbox">
                    <svg viewBox="0 0 12 12" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="2,6 5,9 10,3"></polyline></svg>
                </div>
                <span>Levels</span>
            </button>
            </div>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <div class="relative" id="layouts-wrapper">
                <button id="layouts-btn" class="px-3 py-1.5 text-[11px] font-mono font-semibold bg-transparent border border-trade-border hover:border-blue-500 text-gray-400 hover:text-blue-400 rounded-md transition-all active:scale-95" title="Manage layouts">Layouts</button>
                <div id="layouts-dropdown" class="hidden absolute right-0 top-[calc(100%+6px)] w-56 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] backdrop-blur-sm
                    origin-top scale-y-95 opacity-0 transition-all duration-200">
                    <div class="px-4 py-2 text-[11px] font-mono font-semibold text-gray-400 uppercase tracking-wider">Layouts</div>
                    <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex items-center gap-2 text-gray-300 transition-colors" id="save-layout-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                        <span class="font-medium text-[11px]">Save Current Layout</span>
                    </div>
                    <div class="h-px bg-trade-border mx-2 my-1"></div>
                    <div id="saved-layouts-list" class="max-h-48 overflow-y-auto custom-scroll">
                        <div class="px-4 py-2 text-[10px] text-gray-600 font-mono italic">No saved layouts yet</div>
                    </div>
                </div>
            </div>
            <button id="add-chart-btn" class="px-3 py-1.5 text-[11px] font-mono font-semibold bg-transparent border border-trade-border hover:border-blue-500 text-gray-400 hover:text-blue-400 rounded-md transition-all active:scale-95" title="Add chart panel">+ Chart</button>
            <div class="h-6 w-px bg-trade-border/50"></div>
            <button id="header-settings-btn" class="p-2 hover:bg-[#1a1f2e] rounded-md text-gray-400 hover:text-white transition-all active:scale-95 group">
            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="group-hover:rotate-45 transition-transform duration-300"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
            </button>
        </div>
    </header>

<div id="charts-container">
        <div class="chart-panel-wrapper" id="panel-wrapper-0" style="flex:1;">
            <div id="chart-container" style="width:100%;height:100%;"></div>
            <canvas id="footprint-overlay" style="position:absolute;top:0;left:0;pointer-events:none;z-index:20;"></canvas>
            <div id="custom-price-label" style="position:absolute;right:0;z-index:40;pointer-events:none;display:flex;align-items:center;gap:1px;"></div>
            <div id="indicators-container"></div>
<div id="timer-box"
     class="hidden absolute
            right-[22px] top-1/2
            translate-x-1/2 -translate-y-1/2
            z-[60] pointer-events-none
            font-mono text-[16px] font-semibold
            tabular-nums text-white opacity-80 tracking-wide">
    <span id="timer-text">00:00</span>
</div>
    </div>

<!-- Indicator Settings Context Menu -->
<div id="indicator-ctx-menu"
     style="display:none;position:fixed;z-index:10000;width:252px;
            background:linear-gradient(135deg,#0d1117 0%,#0f1419 100%);
            border:1px solid #1a1f2e;border-radius:10px;
            box-shadow:0 12px 40px rgba(0,0,0,0.65);overflow:hidden;
            font-family:'JetBrains Mono',monospace;">
    <div style="display:flex;align-items:center;justify-content:space-between;
                padding:9px 14px 9px 14px;border-bottom:1px solid #1a1f2e;
                background:linear-gradient(90deg,rgba(59,130,246,0.09) 0%,transparent 100%);">
        <span id="ind-ctx-title"
              style="font-size:11px;font-weight:600;color:#e8eaed;
                     text-transform:uppercase;letter-spacing:0.06em;"></span>
        <button id="ind-ctx-close"
                style="background:none;border:none;color:#5a6178;cursor:pointer;
                       font-size:13px;padding:1px 4px;border-radius:3px;line-height:1;
                       transition:color 0.15s;"
                onmouseover="this.style.color='#ff4242'"
                onmouseout="this.style.color='#5a6178'">âœ•</button>
    </div>
    <div id="ind-ctx-body" style="padding:10px 14px;display:grid;gap:8px;"></div>

</div>
    <!-- Custom Timeframe Modal -->
    <div id="custom-tf-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title">Custom Timeframe</h2>
            <p class="modal-description">
                Enter a timeframe: Numbers for minutes (e.g., "15", "45")<br>
                Add suffix for periods: "d" = days, "w" = weeks, "M" = months
            </p>
            <input type="text" id="custom-tf-input" class="modal-input" placeholder="e.g., 15, 1h, 1d, 1w" autocomplete="off">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-cancel" id="custom-tf-cancel">Cancel</button>
                <button class="modal-btn modal-btn-confirm" id="custom-tf-confirm">Apply</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Settings Panel -->
    <div id="settings-panel" class="absolute top-[49px] left-0 bottom-0 w-96 backdrop-blur-xl border-r border-trade-border z-[1000] transform -translate-x-full transition-transform duration-300 ease-out shadow-2xl flex flex-col">
        
        <div class="flex items-center justify-between p-5 border-b border-trade-border/50 bg-gradient-to-r from-blue-600/10 to-transparent">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 rounded-lg bg-blue-600/20 flex items-center justify-content-center">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-blue-400"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                </div>
                <h2 class="text-white font-semibold text-base">Chart Settings</h2>
            </div>
            <button id="close-settings" class="text-gray-500 hover:text-white transition p-2 rounded-lg hover:bg-white/10 active:scale-95">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
        </div>
        <div class="flex-1 overflow-y-auto custom-scroll">
            
<!-- Chart Appearance -->
<div class="settings-section">
    <div class="section-header" onclick="toggleSection(this)">
        <div class="section-title-wrapper">
            <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg></div>
            <span class="section-title">Chart Appearance</span>
        </div>
        <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
    </div>
    <div class="section-content">
        <div class="section-body">
            <div class="setting-row">
                <div class="setting-item">
                    <label class="setting-label">Chart Type</label>
                    <div class="select-wrapper">
                        <select id="series-type-select" class="w-full px-3 py-2">
                            <option value="candle" selected>Candles</option>
                            <option value="bar">Bars</option>
                        </select>
                    </div>
                </div>
                <div class="setting-item">
                    <label class="setting-label">Bar Spacing</label>
                    <input type="number" id="bar-spacing-input" value="50" min="10" max="200" step="5" class="w-full px-3 py-2">
                </div>
            </div>
            <div class="setting-item">
                <div class="slider-container">
                    <div class="slider-header">
                        <label class="setting-label">Candle Opacity</label>
                        <span id="opacity-val" class="slider-value">100%</span>
                    </div>
                    <input type="range" id="candle-opacity" min="0" max="100" value="100" step="5">
                </div>
            </div>
            <div class="setting-divider"></div>
            <div class="setting-row">
                <div class="setting-item">
                    <label class="setting-label">Candle Width %</label>
                    <input type="number" id="candle-width-input" value="20" min="5" max="80" step="5" class="w-full px-3 py-2">
                </div>
                <div class="setting-item">
                    <label class="setting-label">Cluster Width %</label>
                    <input type="number" id="cluster-width-input" value="80" min="20" max="95" step="5" class="w-full px-3 py-2">
                </div>
            </div>
            <div class="setting-item">
                <div class="slider-container">
                    <div class="slider-header">
                        <label class="setting-label">Wick Thickness</label>
                        <span id="wick-thickness-val" class="slider-value">1px</span>
                    </div>
                    <input type="range" id="wick-thickness" min="1" max="5" value="1" step="0.5">
                </div>
            </div>
            <div class="setting-item">
                <div class="slider-container">
                    <div class="slider-header">
                        <label class="setting-label">Border Thickness</label>
                        <span id="border-thickness-val" class="slider-value">1px</span>
                    </div>
                    <input type="range" id="border-thickness" min="0" max="5" value="1" step="0.5">
                </div>
            </div>
            <div class="setting-divider"></div>
            <div class="setting-row">
                <div class="setting-item">
                    <label class="setting-label">Price Scale Font</label>
                    <input type="number" id="price-scale-font-input" value="10" min="8" max="16" step="1" class="w-full px-3 py-2">
                </div>
            </div>
        </div>
    </div>
</div>

            <!-- Colors -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="13.5" cy="6.5" r=".5"></circle><circle cx="17.5" cy="10.5" r=".5"></circle><circle cx="8.5" cy="7.5" r=".5"></circle><circle cx="6.5" cy="12.5" r=".5"></circle><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"></path></svg></div>
                        <span class="section-title">Colors & Theme</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Bullish Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="up-candle-color" value="#608feb"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bearish Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="down-candle-color" value="#ff4242"></div>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Grid Lines</label>
                            <div class="color-picker-wrapper"><input type="color" id="grid-color-input" value="#636363"></div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">POC Highlight</label>
                            <div class="color-picker-wrapper"><input type="color" id="poc-color-input" value="#f0b90b"></div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Background</label>
                                <div class="color-picker-wrapper"><input type="color" id="bg-color-input" value="#0a0e1a"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Panel Color</label>
                                <div class="color-picker-wrapper"><input type="color" id="panel-color-input" value="#0f1419"></div>
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Accent Color</label>
                            <div class="color-picker-wrapper"><input type="color" id="accent-color-input" value="#3b82f6"></div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Absorption Dot Color</label>
                            <div class="color-picker-wrapper"><input type="color" id="absorption-color-input" value="#FFD700"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Typography -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg></div>
                        <span class="section-title">Typography</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Stats Font Family</label>
                            <div class="select-wrapper">
                                <select id="stats-font-family" class="w-full px-3 py-2">
                                    <option value="'JetBrains Mono', monospace" selected>JetBrains Mono</option>
                                    <option value="'IBM Plex Mono', monospace">IBM Plex Mono</option>
                                    <option value="'Fira Code', monospace">Fira Code</option>
                                    <option value="monospace">System Mono</option>
                                </select>
                            </div>
                            <div class="font-preview" id="stats-font-preview" style="font-family: 'JetBrains Mono', monospace;">V:1.2M D:+250K</div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Stats Font Size</label>
                                    <span id="stats-font-size-val" class="slider-value">Auto</span>
                                </div>
                                <input type="range" id="stats-font-size" min="7" max="16" value="9" step="1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Stats Font Weight</label>
                            <div class="select-wrapper">
                                <select id="stats-font-weight" class="w-full px-3 py-2">
                                    <option value="400" selected>Regular (400)</option>
                                    <option value="500">Medium (500)</option>
                                    <option value="600">Semi-Bold (600)</option>
                                    <option value="700">Bold (700)</option>
                                </select>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cell Font Size</label>
                                    <span id="cell-font-size-val" class="slider-value">11px</span>
                                </div>
                                <input type="range" id="cell-font-size" min="8" max="16" value="9" step="1">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Cell Font Weight</label>
                            <div class="select-wrapper">
                                <select id="cell-font-weight" class="w-full px-3 py-2">
                                    <option value="400" selected>Regular (400)</option>
                                    <option value="500">Medium (500)</option>
                                    <option value="600">Semi-Bold (600)</option>
                                    <option value="700">Bold (700)</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Grid & Scale -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18"/><path d="M3 15h18"/><path d="M9 3v18"/><path d="M15 3v18"/></svg></div>
                        <span class="section-title">Grid & Scale</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Grid Spacing ($)</label>
                            <input type="number" id="grid-spacing-input" value="1000" step="100" min="100" max="10000" class="w-full px-3 py-2">
                            <span class="setting-description">Price interval between horizontal grid lines</span>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Grid Opacity</label>
                                    <span id="grid-opacity-val" class="slider-value">100%</span>
                                </div>
                                <input type="range" id="grid-opacity" min="0" max="100" value="100" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Grid Line Width</label>
                                    <span id="grid-line-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="grid-line-width" min="0.5" max="3" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Base Tick Size</label>
                            <input type="number" id="base-tick-input" value="2.5" step="0.5" min="0.5" max="50" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum price level grouping</span>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Min Cell Height (px)</label>
                            <input type="number" id="min-cell-height-input" value="15" step="1" min="8" max="40" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum height before auto-scaling kicks in</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Footprint Clusters -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg></div>
                        <span class="section-title">Footprint Clusters</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Calculation Mode</label>
                            <div class="select-wrapper">
                                <select id="cumulative-mode-select" class="w-full px-3 py-2">
                                    <option value="all" selected>All Candles</option>
                                    <option value="visible">Visible Candles Only</option>
                                </select>
                            </div>
                            <span class="setting-description">Cumulative cluster aggregation range</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Low-Volume Cell Threshold (USD)</label>
                            <input type="number" id="cluster-volume-threshold" value="25000" min="0" step="10000" class="w-full px-3 py-2">
                            <span class="setting-description">Cells below this total volume are shown in muted gray. Set to 0 to disable.</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cluster BG Opacity</label>
                                    <span id="cluster-bg-opacity-val" class="slider-value">0%</span>
                                </div>
                                <input type="range" id="cluster-bg-opacity" min="0" max="100" value="0" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">POC Border Width</label>
                                    <span id="poc-border-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="poc-border-width" min="1" max="5" value="1.5" step="0.5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Cell Border Width</label>
                                    <span id="cell-border-width-val" class="slider-value">1px</span>
                                </div>
                                <input type="range" id="cell-border-width" min="0" max="3" value="1" step="0.5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Volume Analysis -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg></div>
                        <span class="section-title">Volume Analysis</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Min Delta for Bubbles (USD)</label>
                            <input type="number" id="bubble-threshold-input" value="500000" step="100000" min="0" max="10000000" class="w-full px-3 py-2">
                            <span class="setting-description">Show pulsing indicator when delta exceeds this threshold</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Bubble Inner Size</label>
                                <input type="number" id="bubble-inner-size" value="5" min="2" max="15" step="1" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Bubble Outer Size</label>
                                <input type="number" id="bubble-outer-size" value="10" min="5" max="25" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Bubble Pulse Speed</label>
                                    <span id="bubble-pulse-speed-val" class="slider-value">1.5s</span>
                                </div>
                                <input type="range" id="bubble-pulse-speed" min="500" max="3000" value="1500" step="100">
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Absorption Dot Size</label>
                                <input type="number" id="absorption-dot-size" value="4" min="2" max="12" step="1" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Absorption Glow</label>
                                <input type="number" id="absorption-glow" value="10" min="0" max="30" step="1" class="w-full px-3 py-2">
                            </div>
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Absorption Threshold (USD)</label>
                            <input type="number" id="absorption-threshold" value="1000000" step="10000" min="0" max="10000000" class="w-full px-3 py-2">
                            <span class="setting-description">Minimum delta for absorption detection</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- UI Elements -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M12 1v6m0 6v6m0 0"></path><circle cx="12" cy="12" r="10"></circle></svg></div>
                        <span class="section-title">UI Elements</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Price Line</label>
                                <div class="toggle-switch active" id="toggle-price-line-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Price Label</label>
                                <div class="toggle-switch active" id="toggle-price-label-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Countdown Timer</label>
                                <div class="toggle-switch active" id="toggle-countdown-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Crosshair</label>
                                <div class="toggle-switch active" id="toggle-crosshair-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <label class="setting-label">Price Label Font Size</label>
                            <input type="number" id="price-label-font-size" value="9" min="5" max="20" step="1" class="w-full px-3 py-2">
                        </div>
                        <div class="setting-item">
                            <label class="setting-label">Timer Font Size</label>
                            <input type="number" id="timer-font-size" value="8" min="5" max="20" step="1" class="w-full px-3 py-2">
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Timer Opacity</label>
                                    <span id="timer-opacity-val" class="slider-value">90%</span>
                                </div>
                                <input type="range" id="timer-opacity" min="0" max="100" value="90" step="5">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Indicators -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg></div>
                        <span class="section-title">Indicators</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <label class="setting-label">Default Indicator Height</label>
                            <input type="number" id="default-indicator-height" value="150" min="50" max="500" step="10" class="w-full px-3 py-2">
                            <span class="setting-description">Initial height for new indicators (px)</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">OI Candle Width</label>
                                    <span id="oi-candle-width-val" class="slider-value">50%</span>
                                </div>
                                <input type="range" id="oi-candle-width" min="20" max="100" value="50" step="5">
                            </div>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">CVD Line Thickness</label>
                                    <span id="cvd-line-thickness-val" class="slider-value">2px</span>
                                </div>
                                <input type="range" id="cvd-line-thickness" min="1" max="5" value="1" step="0.5">
                            </div>
                        </div>
                        <div class="setting-row">
                            <div class="setting-item">
                                <label class="setting-label">Indicator Padding</label>
                                <input type="number" id="indicator-padding" value="10" min="0" max="30" step="2" class="w-full px-3 py-2">
                            </div>
                            <div class="setting-item">
                                <label class="setting-label">Indicator BG Opacity</label>
                                <input type="number" id="indicator-bg-opacity" value="95" min="0" max="100" step="5" class="w-full px-3 py-2">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Advanced -->
            <div class="settings-section">
                <div class="section-header" onclick="toggleSection(this)">
                    <div class="section-title-wrapper">
                        <div class="section-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg></div>
                        <span class="section-title">Advanced</span>
                    </div>
                    <svg class="section-chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
                <div class="section-content">
                    <div class="section-body">
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Draw Frame Delay</label>
                                    <span id="draw-delay-val" class="slider-value">50ms</span>
                                </div>
                                <input type="range" id="draw-delay" min="50" max="500" value="50" step="50">
                            </div>
                            <span class="setting-description">Lower = more responsive, higher = better performance</span>
                        </div>
                        <div class="setting-item">
                            <div class="slider-container">
                                <div class="slider-header">
                                    <label class="setting-label">Interaction Hold Time</label>
                                    <span id="interaction-hold-val" class="slider-value">180ms</span>
                                </div>
                                <input type="range" id="interaction-hold" min="50" max="500" value="180" step="10">
                            </div>
                            <span class="setting-description">Duration to keep drawing after user interaction</span>
                        </div>
                        <div class="setting-divider"></div>
                        <div class="setting-item full-width">
                            <button class="reset-button w-full" onclick="resetToDefaults()">
                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; vertical-align: middle; margin-right: 6px;"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>
                                Reset All Settings to Defaults
                            </button>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="ctx-menu-main" class="hidden absolute w-52 bg-[#12161f] border border-trade-border rounded-lg shadow-2xl py-1.5 z-[5000] text-sm backdrop-blur-sm">
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-reset">
            <span class="font-medium">Reset View</span><span class="text-gray-500 text-xs group-hover:text-blue-400">R</span>
        </div>
        <div class="h-px bg-trade-border mx-2 my-1"></div>
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-hide-footprints">
            <span class="font-medium">Hide Footprints</span>
            <span id="ctx-hide-footprints-indicator" class="text-[10px] text-gray-500 group-hover:text-blue-400">â—‹</span>
        </div>
        <div class="h-px bg-trade-border mx-2 my-1"></div>
        <div class="menu-item px-4 py-2.5 hover:bg-blue-600/10 hover:text-blue-400 cursor-pointer flex justify-between items-center text-gray-300 transition-colors group" id="ctx-settings-trigger">
            <span class="font-medium">Settings</span><span class="text-gray-500 text-[10px] group-hover:text-blue-400">â–¶</span>
        </div>
    </div>

<script>
    const HEADER_HEIGHT = 48;
    const TIME_AXIS_HEIGHT = 28;
    const MIN_PANE_HEIGHT = 50;
    const BASE_TIMEFRAME = 5;

    let config = {
        gridSpacing: 1000, gridColor: '#636363', gridOpacity: 1.0, gridLineWidth: 1,
        baseTickSize: 2.5, minCellHeight: 15, upColor: '#608feb', downColor: '#ff4242',
        candleOpacity: 1.0, seriesType: 'candle', minBubbleVolume: 500000,
        showPriceLine: true, showPriceLabel: true, showCountdown: true, showCrosshair: true,
        pocColor: '#f0b90b', currentTimeframe: 5, displayTimeframe: 5,
        candleWidthPercent: 0.20, clusterWidthPercent: 0.80, cumulativeMode: 'all',
        wickThickness: 1, borderThickness: 1, bgColor: '#0a0e1a', panelColor: '#0f1419',
        accentColor: '#3b82f6', absorptionColor: '#FFD700',
        statsFontFamily: "'JetBrains Mono', monospace", statsFontSize: 9,
        statsFontWeight: '400', cellFontSize: 9, cellFontWeight: '400', barSpacing: 50,
        clusterBgOpacity: 0, pocBorderWidth: 1.5, cellBorderWidth: 1,
        bubbleInnerSize: 5, bubbleOuterSize: 10, bubblePulseSpeed: 1500,
        absorptionDotSize: 4, absorptionGlow: 10, absorptionThreshold: 1000000,
        priceLabelFontSize: 9, timerFontSize: 8, timerOpacity: 0.9,
        defaultIndicatorHeight: 150, oiCandleWidth: 0.5, cvdLineThickness: 1,
        indicatorPadding: 10, indicatorBgOpacity: 0.95, drawDelay: 100, interactionHold: 180,
        clusterVolumeThreshold: 25000, showDailyLevels: false, hideFootprints: false ,priceScaleWidth: 44,
        priceScaleFontSize: 10,
        //vwap
        vwapVisible: false,
        // â”€â”€ TPO / Market Profile â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        showTPO: false,
        tpoTickSize: 50,
        tpoBlockWidth: 8,
        tpoOpacityVA: 0.65,
        tpoOpacityNonVA: 0.70,
        tpoColorSingle: '#ff6ec7',
        tpoColorVA: '#3b82f6',
        tpoColorNonVA: '#ffffff',
        tpoColorPOC: '#ffffff',
        // OI
        oiUpColor: '#608feb',
        oiDownColor: '#ff4242',
        oiOpacity: 1.0,
        oiBorderColor: '#ffffff',
        // CVD
        cvdLineColor: 'auto',   // 'auto' = follows up/down color, or any hex like '#3b82f6'
        // Bar Stats
        barStatsUpColor: '#608feb',
        barStatsDownColor: '#ff4242',
        // VWAP
        vwapColor: '#ffffff',
        vwapLineStyle: 'solid',  // 'solid' | 'dashed' | 'dotted'
        vwapShowLabel: false,
        vwapShowPrice: false,
        // Key Levels
        levelsColor: '#ff8c00',
        levelsLineStyle: 'dashed',  // 'solid' | 'dashed' | 'dotted'
        levelsEnabled: { dOpen: true, dHigh: true, dLow: true, dEQ: true, pdHigh: true, pdLow: true, pdEQ: true },

    };

    let base5mClusters = {};
    let base5mCandles = [];
    let displayCandles = [];
    let displayClusters = {};
    let lastBarTime = 0;
    let currentPrice = 0;
    let mainSeries;
    let ws = null;
    let measuredPriceScaleWidth = 54;

// â”€â”€ TPO Cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let tpoProfilesCache = null;
    let tpoCacheKey = '';

    // â”€â”€ Active-panel context globals (swapped when drawing extra panels) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // For panel 0 these always equal the original variables.
    // They are set by activateExtraPanel() / deactivateExtraPanel().
    let activePriceLabelEl = null;   // set after DOM ready
    let activeTimerBox     = null;   // set after DOM ready
    let activeWrapperEl    = null;   // set after DOM ready

    // â”€â”€ Stub indicator manager (used by extra panels which have no indicator panes)
    const stubIndicatorManager = {
        indicators: new Map(), order: [],
        getIndicator: () => null,
        drawAll: () => {},
        updateLayout: () => {},
        addIndicator: () => {},
        removeIndicator: () => {},
    };

    // â”€â”€ Extra panels array â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const extraPanels = [];
    let extraPanelCounter = 0;
    let selectedPanelId = 0; // 0 = main panel, >0 = extra panel ID

function _saveP0() {
    const indSettings = {};
    IND_SETTING_KEYS.forEach(k => { indSettings[k] = config[k]; });
    indSettings.levelsEnabled = { ...config.levelsEnabled };
    return { chart, mainSeries, chartOverlayCanvas, ctxOverlay,
             offscreenCanvas, offscreenCtx, displayCandles, displayClusters,
             tpoProfilesCache, tpoCacheKey, indicatorManager: indicatorManager,
             activePriceLabelEl, activeTimerBox, activeWrapperEl,
             showTPO: config.showTPO, vwapVisible: config.vwapVisible,
             showDailyLevels: config.showDailyLevels, hideFootprints: config.hideFootprints,
             indSettings };
}
function _restoreP0(s) {
    chart = s.chart; mainSeries = s.mainSeries;
    chartOverlayCanvas = s.chartOverlayCanvas; ctxOverlay = s.ctxOverlay;
    offscreenCanvas = s.offscreenCanvas; offscreenCtx = s.offscreenCtx;
    displayCandles = s.displayCandles; displayClusters = s.displayClusters;
    tpoProfilesCache = s.tpoProfilesCache; tpoCacheKey = s.tpoCacheKey;
    indicatorManager = s.indicatorManager;
    activePriceLabelEl = s.activePriceLabelEl;
    activeTimerBox = s.activeTimerBox;
    activeWrapperEl = s.activeWrapperEl;
    config.showTPO = s.showTPO;
    config.vwapVisible = s.vwapVisible;
    config.showDailyLevels = s.showDailyLevels;
    config.hideFootprints = s.hideFootprints;
    if (s.indSettings) {
        IND_SETTING_KEYS.forEach(k => { config[k] = s.indSettings[k]; });
        config.levelsEnabled = { ...s.indSettings.levelsEnabled };
    }
}
    function _activatePanel(panel) {
        chart = panel.chart; mainSeries = panel.mainSeries;
        chartOverlayCanvas = panel.overlayCanvas; ctxOverlay = panel.ctxOverlay;
        offscreenCanvas = panel.offscreenCanvas; offscreenCtx = panel.offscreenCtx;
        displayCandles = panel.displayCandles; displayClusters = panel.displayClusters;
        tpoProfilesCache = panel.tpoProfilesCache; tpoCacheKey = panel.tpoCacheKey;
        indicatorManager = panel.indicatorManager;
        activePriceLabelEl = panel.priceLabelEl;
        activeTimerBox = panel.timerBoxEl;
        activeWrapperEl = panel.wrapperEl;
        config.showTPO = panel.showTPO;
        config.vwapVisible = panel.vwapVisible;
        config.showDailyLevels = panel.showDailyLevels;
        config.hideFootprints = panel.hideFootprints;
        IND_SETTING_KEYS.forEach(k => { if (panel[k] !== undefined) config[k] = panel[k]; });
        if (panel.levelsEnabled) config.levelsEnabled = { ...panel.levelsEnabled };
    }
    function _deactivatePanel(panel) {
        panel.tpoProfilesCache = tpoProfilesCache;
        panel.tpoCacheKey = tpoCacheKey;
        panel.showTPO = config.showTPO;
        panel.vwapVisible = config.vwapVisible;
        panel.showDailyLevels = config.showDailyLevels;
        panel.hideFootprints = config.hideFootprints;
        IND_SETTING_KEYS.forEach(k => { panel[k] = config[k]; });
        panel.levelsEnabled = { ...config.levelsEnabled };
    }

    function schedulePanelDraw(panel) {
        panel.needsRedraw = true;
        panel.lastInteractionTime = Date.now();
        if (!panel.rafRunning) {
            panel.rafRunning = true;
            const loop = () => {
                const saved = _saveP0();
                _activatePanel(panel);
                const now = Date.now();
                if (now - panel.lastInteractionTime < config.interactionHold) {
                    drawFrames(); _deactivatePanel(panel);
                    _restoreP0(saved);
                    panel.rafId = requestAnimationFrame(loop);
                } else {
                    if (panel.needsRedraw) {
                        panel.needsRedraw = false;
                        drawFrames(); _deactivatePanel(panel);
                        _restoreP0(saved);
                        panel.rafId = requestAnimationFrame(loop);
                    } else {
                        _restoreP0(saved);
                        panel.rafRunning = false;
                        panel.rafId = null;
                    }
                }
            };
            panel.rafId = requestAnimationFrame(loop);
        }
    }

    function setupPanelBuffers(panel) {
        const dpr = window.devicePixelRatio || 1;
        const w = panel.wrapperEl.clientWidth;
        const h = panel.wrapperEl.clientHeight;
        panel.overlayCanvas.width  = Math.floor(w * dpr);
        panel.overlayCanvas.height = Math.floor(h * dpr);
        panel.overlayCanvas.style.width  = w + 'px';
        panel.overlayCanvas.style.height = h + 'px';
        panel.offscreenCanvas.width  = panel.overlayCanvas.width;
        panel.offscreenCanvas.height = panel.overlayCanvas.height;
        panel.offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        panel.ctxOverlay.setTransform(1, 0, 0, 1, 0, 0);
        panel.chart.applyOptions({ width: w, height: h });
    }

    function createExtraPanel() {
        extraPanelCounter++;
        const pid = extraPanelCounter;

        // â”€â”€ DOM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const wrapperEl = document.createElement('div');
        wrapperEl.className = 'chart-panel-wrapper';
        wrapperEl.id = `panel-wrapper-${pid}`;
        wrapperEl.style.flex = '1';

        const chartContEl = document.createElement('div');
        chartContEl.style.cssText = 'width:100%;height:100%;';

        const overlayEl = document.createElement('canvas');
        overlayEl.style.cssText = 'position:absolute;top:0;left:0;pointer-events:none;z-index:20;';

        const priceLabelEl = document.createElement('div');
        priceLabelEl.style.cssText = 'position:absolute;right:0;z-index:40;pointer-events:none;display:flex;align-items:center;gap:1px;';

        const timerEl = document.createElement('div');
        timerEl.className = 'hidden absolute bg-black/90 border border-trade-border/50 backdrop-blur text-white px-1 py-1 font-mono text-[11px] font-semibold z-[60] tabular-nums flex items-center gap-1.5 pointer-events-none shadow-lg rounded';
        timerEl.style.cssText = 'min-width:60px;right:10px;';
        timerEl.innerHTML = '<span class="w-1.5 h-1.5 rounded-full bg-white/90 animate-pulse"></span><span class="timer-text-extra">00:00</span>';

        wrapperEl.appendChild(chartContEl);
        wrapperEl.appendChild(overlayEl);
        wrapperEl.appendChild(priceLabelEl);
        wrapperEl.appendChild(timerEl);

        // â”€â”€ Per-panel TF bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const tfBar = document.createElement('div');
        tfBar.className = 'panel-tf-bar';
        const tfs = [5, 15, 30, 60, 240, 1440];
        const tfLabels = { 5:'5m', 15:'15m', 30:'30m', 60:'1h', 240:'4h', 1440:'1D' };
        tfs.forEach(tf => {
            const btn = document.createElement('button');
            btn.className = 'timeframe-btn' + (tf === 5 ? ' active' : '');
            btn.style.cssText = 'padding:2px 7px;font-size:10px;';
            btn.textContent = tfLabels[tf];
            btn.onclick = () => {
                tfBar.querySelectorAll('.timeframe-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                panel.displayTimeframe = tf;
                panel.displayCandles = aggregateCandles(base5mCandles, tf);
                panel.displayClusters = aggregateClusters(base5mClusters, tf);
                panel.mainSeries.setData(panel.displayCandles);
                panel.tpoCacheKey = '';
                setTimeout(() => { panel.chart.timeScale().fitContent(); schedulePanelDraw(panel); }, 80);
            };
            tfBar.appendChild(btn);
        });
        wrapperEl.appendChild(tfBar);

// â”€â”€ Click to select panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        wrapperEl.addEventListener('click', () => {
            selectedPanelId = pid;
            document.querySelectorAll('.chart-panel-wrapper').forEach(w => w.classList.remove('selected'));
            wrapperEl.classList.add('selected');
            syncHeaderButtons();
        });

        wrapperEl.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            // Select this panel first so ctx menu actions apply to it
            selectedPanelId = pid;
            document.querySelectorAll('.chart-panel-wrapper').forEach(w => w.classList.remove('selected'));
            wrapperEl.classList.add('selected');
            syncHeaderButtons();
            // Position and show the menu
            ctxMenuMain.style.left = `${Math.min(e.clientX, window.innerWidth - 200)}px`;
            ctxMenuMain.style.top  = `${Math.min(e.clientY, window.innerHeight - 100)}px`;
            ctxMenuMain.classList.remove('hidden');
            // Sync the footprints dot to this panel's state
            const active = extraPanels.find(p => p.id === pid)?.hideFootprints ?? false;
            document.getElementById('ctx-hide-footprints-indicator').textContent = active ? 'â—' : 'â—‹';
            document.getElementById('ctx-hide-footprints-indicator').style.color = active ? '#3b82f6' : '';
        });

        // â”€â”€ Close button â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const closeBtn = document.createElement('div');
        closeBtn.className = 'panel-close-btn';
        closeBtn.innerHTML = 'âœ•';
        closeBtn.onclick = () => removeExtraPanel(pid);
        wrapperEl.appendChild(closeBtn);

        // â”€â”€ Resizer + insert into container â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const container = document.getElementById('charts-container');
        const resizer = document.createElement('div');
        resizer.className = 'vertical-resizer';
        resizer.dataset.resizerId = pid;
        container.appendChild(resizer);
        container.appendChild(wrapperEl);

        // â”€â”€ LW Chart â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const newChart = LightweightCharts.createChart(chartContEl, {
     localization: {
        timeFormatter: (timestamp) => {
            return new Date(timestamp * 1000).toLocaleString('ro-RO', {
                timeZone: 'Europe/Bucharest',
                hour: '2-digit', minute: '2-digit',
            });
        }
    },
            layout: { background: { color: config.bgColor }, textColor: '#8b92a7', fontFamily: 'Inter', fontSize: config.priceScaleFontSize },
            grid: { vertLines: { visible: false }, horzLines: { visible: false } },
            rightPriceScale: { borderColor: '#1a1f2e', scaleMargins: { top: 0.05, bottom: 0.20 } },
            crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
            timeScale: { borderColor: '#1a1f2e', timeVisible: true, barSpacing: config.barSpacing, rightOffset: 5 }
        });
        const newSeries = newChart.addCandlestickSeries({
            upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', borderVisible:false,
            wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)',
            priceLineVisible: config.showPriceLine,
            priceLineColor: config.upColor,
            priceLineWidth: 1,
            priceLineStyle: 2,
            lastValueVisible:false
        });
        const offscreenC = document.createElement('canvas');

        // â”€â”€ Create indicators container for this panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const indicatorsContainer = document.createElement('div');
        indicatorsContainer.id = `indicators-container-${pid}`;
        indicatorsContainer.style.cssText = 'position:absolute;left:0;right:0;bottom:0;pointer-events:none;';
        wrapperEl.appendChild(indicatorsContainer);

        const panelIndicatorManager = new IndicatorManager();
        panelIndicatorManager.container = indicatorsContainer;
        panelIndicatorManager.chart = newChart;
        panelIndicatorManager.wrapper = wrapperEl;

        const panel = {
            id: pid,
            indicatorManager: panelIndicatorManager,
            wrapperEl,
            chart: newChart,
            mainSeries: newSeries,
            overlayCanvas: overlayEl,
            ctxOverlay: overlayEl.getContext('2d'),
            offscreenCanvas: offscreenC,
            offscreenCtx: offscreenC.getContext('2d'),
            priceLabelEl,
            timerBoxEl: timerEl,
            displayTimeframe: 5,
            displayCandles: displayCandles.slice(),
            displayClusters: structuredClone(displayClusters),
            tpoProfilesCache: null,
            tpoCacheKey: '',
            rafRunning: false,
            needsRedraw: false,
            lastInteractionTime: 0,
            rafId: null,
            showTPO: false,
            vwapVisible: false,
            showDailyLevels: false,
            hideFootprints: false,
            ...makeDefaultIndSettings(), // per-panel indicator colors/styles
    };
        panelIndicatorManager.onLayout = () => schedulePanelDraw(panel);
        newSeries.setData(panel.displayCandles);
        setupPanelBuffers(panel);
        newChart.timeScale().fitContent();
        newChart.timeScale().subscribeVisibleLogicalRangeChange(() => { if (typeof schedulePanelDraw === 'function') schedulePanelDraw(panel); });

        setupVerticalResizer(resizer, pid);
        extraPanels.push(panel);
        schedulePanelDraw(panel);
        return panel;
    }

function removeExtraPanel(pid) {
        const idx = extraPanels.findIndex(p => p.id === pid);
        if (idx === -1) return;
        const panel = extraPanels[idx];
        if (panel.rafId) cancelAnimationFrame(panel.rafId);
        const container = document.getElementById('charts-container');
        const resizer = container.querySelector(`[data-resizer-id="${pid}"]`);
        if (resizer) resizer.remove();
        panel.wrapperEl.remove();
        extraPanels.splice(idx, 1);

        // Count remaining panels (main + extras)
        const remainingCount = 1 + extraPanels.length;
        // Calculate each panel's share from the container total width
        const containerW = container.clientWidth;
        const resizerCount = extraPanels.length; // one resizer between each pair
        const resizerTotalW = resizerCount * 5;
        const panelW = Math.floor((containerW - resizerTotalW) / remainingCount);
        const panelH = container.clientHeight;

        // Force explicit pixel widths so no panel keeps a stale locked size
        const wrapper0 = document.getElementById('panel-wrapper-0');
        wrapper0.style.flex = `0 0 ${panelW}px`;
        extraPanels.forEach(p => {
            p.wrapperEl.style.flex = `0 0 ${panelW}px`;
        });

        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                // Now resize all charts to their new explicit widths
                chart.applyOptions({ width: panelW, height: panelH });
                setupBuffersForSize();
                indicatorManager.updateLayout();

                extraPanels.forEach(p => {
                    p.chart.applyOptions({ width: panelW, height: panelH });
                    const dpr = window.devicePixelRatio || 1;
                    p.overlayCanvas.width  = Math.floor(panelW * dpr);
                    p.overlayCanvas.height = Math.floor(panelH * dpr);
                    p.overlayCanvas.style.width  = panelW + 'px';
                    p.overlayCanvas.style.height = panelH + 'px';
                    p.offscreenCanvas.width  = p.overlayCanvas.width;
                    p.offscreenCanvas.height = p.overlayCanvas.height;
                    p.offscreenCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    p.indicatorManager.updateLayout();
                    schedulePanelDraw(p);
                });

                // After charts are sized, switch back to flex:1 for natural resizing
                wrapper0.style.flex = '1';
                extraPanels.forEach(p => {
                    p.wrapperEl.style.flex = '1';
                });

                scheduleDraw();
            });
        });
    }

function setupVerticalResizer(resizerEl, panelId) {
        const container = document.getElementById('charts-container');
        let dragging = false, startX = 0;
        let leftEl = null, rightEl = null, leftStart = 0, rightStart = 0;

        resizerEl.addEventListener('mousedown', e => {
            e.preventDefault();
            dragging = true;
            startX = e.clientX;
            resizerEl.classList.add('resizing');
            // left sibling = previous panel wrapper; right = this panel wrapper
            leftEl  = resizerEl.previousElementSibling;
            rightEl = resizerEl.nextElementSibling;
            leftStart  = leftEl  ? leftEl.getBoundingClientRect().width  : 0;
            rightStart = rightEl ? rightEl.getBoundingClientRect().width : 0;
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        });

        const handleMouseMove = e => {
            if (!dragging) return;
            const dx = e.clientX - startX;
            const newLeft  = Math.max(150, leftStart  + dx);
            const newRight = Math.max(150, rightStart - dx);
            if (leftEl)  leftEl.style.flex  = `0 0 ${newLeft}px`;
            if (rightEl) rightEl.style.flex = `0 0 ${newRight}px`;
        };

        const handleMouseUp = () => {
            if (!dragging) return;
            dragging = false;
            resizerEl.classList.remove('resizing');
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            // Force browser reflow before reading dimensions
            requestAnimationFrame(() => {
                // Save current context if we're on an extra panel
                const wasOnExtraPanel = extraPanels.some(p => p.id === selectedPanelId);
                let savedState = null;
                if (wasOnExtraPanel) {
                    savedState = _saveP0();
                }

                // Resize main chart (panel 0)
                const wrapper0 = document.getElementById('panel-wrapper-0');
                if (wrapper0) {
                    const w = wrapper0.clientWidth;
                    const h = wrapper0.clientHeight;
                    chart.applyOptions({ width: w, height: h });
                    setupBuffersForSize();
                    // Force indicator manager to recalculate layout for panel 0
                    if (!wasOnExtraPanel) {
                        indicatorManager.updateLayout();
                    }
                }
                
                // Resize extra panels
                extraPanels.forEach(p => {
                    const tempSaved = _saveP0();
                    _activatePanel(p);
                    setupPanelBuffers(p);
                    p.indicatorManager.updateLayout();
                    _deactivatePanel(p);
                    _restoreP0(tempSaved);
                    schedulePanelDraw(p);
                });
                
                // Restore context if needed
                if (savedState) {
                    _restoreP0(savedState);
                }
                
                scheduleDraw();
            });
        };

        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
    }

 // â”€â”€ Draw loop (must be defined before chart + indicators) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let rafId = null, rafRunning = false, needsRedraw = false, lastInteractionTime = 0;
let clustersDirty = false;

function updatePaneRight() {
    const chartEl = document.getElementById('chart-container');
    let right = 54;
    if (chartEl) {
        const lastTd = chartEl.querySelector('tr td:last-child');
        if (lastTd) {
            const w = Math.round(lastTd.getBoundingClientRect().width);
            if (w > 10) right = w;
        }
    }
    measuredPriceScaleWidth = right;
    document.querySelectorAll('.indicator-pane').forEach(el => {
        el.style.right = right + 'px';
    });
    const ph = document.querySelector('.drag-placeholder');
    if (ph) ph.style.right = right + 'px';
}

function scheduleDraw() {
    needsRedraw = true;
    lastInteractionTime = Date.now();
    extraPanels.forEach(p => schedulePanelDraw(p));
    if (!rafRunning) {
        rafRunning = true;
        const loop = () => {
            const now = Date.now();
            if (now - lastInteractionTime < config.interactionHold) {
                drawFrames(); rafId = requestAnimationFrame(loop);
            } else {
                if (needsRedraw) { needsRedraw = false; drawFrames(); rafId = requestAnimationFrame(loop); }
                else { rafRunning = false; rafId = null; }
            }
        };
        rafId = requestAnimationFrame(loop);
    }
}

    let chart;
    chart = LightweightCharts.createChart(document.getElementById('chart-container'), {
    localization: {
        timeFormatter: (timestamp) => {
            return new Date(timestamp * 1000).toLocaleString('ro-RO', {
                timeZone: 'Europe/Bucharest',
                hour: '2-digit', minute: '2-digit',
                //day: '2-digit', month: '2-digit'
            });
        }
    },
        layout: { background: { color: config.bgColor }, textColor: '#8b92a7', fontFamily: 'Inter', fontSize: config.priceScaleFontSize },
        grid: { vertLines: { visible: false }, horzLines: { visible: false } },
        rightPriceScale: { borderColor: '#1a1f2e', scaleMargins: { top: 0.05, bottom: 0.20 } },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
        timeScale: { borderColor: '#1a1f2e', timeVisible: true, barSpacing: config.barSpacing, rightOffset: 5, visible: true }
    });

    function parseCustomTimeframe(input) {
        input = input.trim().toLowerCase();
        if (input.endsWith('h')) { const h = parseFloat(input.slice(0,-1)); return (isNaN(h)||h<=0)?null:h*60; }
        if (input.endsWith('d')) { const d = parseFloat(input.slice(0,-1)); return (isNaN(d)||d<=0)?null:d*1440; }
        if (input.endsWith('w')) { const w = parseFloat(input.slice(0,-1)); return (isNaN(w)||w<=0)?null:w*10080; }
        if (input.endsWith('m') && input.length > 1) {
            const char = input[input.length-2];
            if (!isNaN(char)) { const m = parseFloat(input.slice(0,-1)); return (isNaN(m)||m<=0)?null:m; }
        }
        const mins = parseFloat(input);
        return (isNaN(mins)||mins<=0) ? null : mins;
    }

    function validateTimeframe(minutes) {
        if (minutes < BASE_TIMEFRAME) { alert(`Footprint information will not migrate to timeframes lower than ${BASE_TIMEFRAME}m`); return false; }
        if (minutes % BASE_TIMEFRAME !== 0) { alert(`Please use timeframes divisible by ${BASE_TIMEFRAME}m`); return false; }
        return true;
    }

    function aggregateCandles(source5mCandles, targetTFMinutes) {
        if (targetTFMinutes === BASE_TIMEFRAME) return source5mCandles.slice();
        const aggregated = [];
        const targetBarSeconds = targetTFMinutes * 60;
        const grouped = {};
        source5mCandles.forEach(candle => {
            const alignedTime = Math.floor(candle.time / targetBarSeconds) * targetBarSeconds;
            if (!grouped[alignedTime]) grouped[alignedTime] = [];
            grouped[alignedTime].push(candle);
        });
        const alignedTimes = Object.keys(grouped).map(Number).sort((a,b)=>a-b);
        alignedTimes.forEach(alignedTime => {
            const chunk = grouped[alignedTime];
            if (chunk.length === 0) return;
            const first = chunk[0], last = chunk[chunk.length-1];
            aggregated.push({
                time: alignedTime, open: first.open,
                high: Math.max(...chunk.map(c=>c.high)), low: Math.min(...chunk.map(c=>c.low)),
                close: last.close, oiOpen: first.oiOpen,
                volume: chunk.reduce((sum, c) => sum + (c.volume || 0), 0),
                oiHigh: Math.max(...chunk.map(c=>c.oiHigh||0)),
                oiLow: Math.min(...chunk.map(c=>c.oiLow||Infinity)),
                oiClose: last.oiClose
            });
        });
        return aggregated;
    }

    function aggregateClusters(source5mClusters, targetTFMinutes) {
        if (targetTFMinutes === BASE_TIMEFRAME) return structuredClone(source5mClusters);
        const aggregated = {};
        const targetBarSeconds = targetTFMinutes * 60;
        const timestamps = Object.keys(source5mClusters).map(Number).sort((a,b)=>a-b);
        const grouped = {};
        timestamps.forEach(ts => {
            const alignedTime = Math.floor(ts / targetBarSeconds) * targetBarSeconds;
            if (!grouped[alignedTime]) grouped[alignedTime] = [];
            grouped[alignedTime].push(ts);
        });
        Object.keys(grouped).forEach(alignedTime => {
            const timeKey = String(alignedTime);
            const tsList = grouped[alignedTime];
            let hasData = false;
            tsList.forEach(ts => { const b = source5mClusters[String(ts)]; if (b && Object.keys(b).length > 0) hasData = true; });
            if (!hasData) return;
            aggregated[timeKey] = {};
            tsList.forEach(ts => {
                const buckets = source5mClusters[String(ts)];
                if (!buckets) return;
                Object.keys(buckets).forEach(priceKey => {
                    const price = parseFloat(priceKey);
                    const data = buckets[priceKey];
                    if (data.buy === 0 && data.sell === 0) return;
                    if (!aggregated[timeKey][price]) aggregated[timeKey][price] = { buy: 0, sell: 0 };
                    aggregated[timeKey][price].buy += data.buy;
                    aggregated[timeKey][price].sell += data.sell;
                });
            });
            if (Object.keys(aggregated[timeKey]).length === 0) delete aggregated[timeKey];
        });
        return aggregated;
    }

    function applyTimeframeChange(newTFMinutes) {
        config.displayTimeframe = newTFMinutes;
        displayCandles = aggregateCandles(base5mCandles, newTFMinutes);
        displayClusters = aggregateClusters(base5mClusters, newTFMinutes);
        mainSeries.setData(displayCandles);
        // Invalidate TPO cache on timeframe change
        tpoCacheKey = '';
        document.querySelectorAll('.timeframe-btn').forEach(btn => btn.classList.remove('active'));
        const tfMap = { 1:1, 3:3, 5:5, 15:15, 30:30, 60:60, 240:240, 1440:'D' };
        const btnValue = tfMap[newTFMinutes];
        if (btnValue) { const btn = document.querySelector(`[data-tf="${btnValue}"]`); if (btn) btn.classList.add('active'); }
        setTimeout(() => { chart.timeScale().fitContent(); needsRedraw = true; scheduleDraw(); }, 100);
    }

    document.getElementById('custom-tf-btn').onclick = () => {
        const modal = document.getElementById('custom-tf-modal');
        modal.classList.add('active');
        document.getElementById('custom-tf-input').value = '';
        document.getElementById('custom-tf-input').focus();
    };
    document.getElementById('custom-tf-cancel').onclick = () => document.getElementById('custom-tf-modal').classList.remove('active');
    document.getElementById('custom-tf-modal').onclick = (e) => { if (e.target.id==='custom-tf-modal') document.getElementById('custom-tf-modal').classList.remove('active'); };
    document.getElementById('custom-tf-input').onkeypress = (e) => { if (e.key==='Enter') document.getElementById('custom-tf-confirm').click(); };
    document.getElementById('custom-tf-confirm').onclick = () => {
        const input = document.getElementById('custom-tf-input').value;
        const minutes = parseCustomTimeframe(input);
        if (minutes === null) { alert('Invalid timeframe format. Examples: 15, 1h, 4h, 1d, 1w'); return; }
        if (!validateTimeframe(minutes)) return;
        document.getElementById('custom-tf-modal').classList.remove('active');
        applyTimeframeChange(minutes);
    };

    function toggleSection(header) { header.parentElement.classList.toggle('expanded'); }

    function toggleSwitch(element) {
        element.classList.toggle('active');
        const switchId = element.id;
        if (switchId === 'toggle-price-line-switch') {
    config.showPriceLine = element.classList.contains('active');
    const lastCandle = displayCandles[displayCandles.length - 1];
    const lineColor = (lastCandle && lastCandle.close >= lastCandle.open) ? config.upColor : config.downColor;
    mainSeries.applyOptions({
        priceLineVisible: config.showPriceLine,
        priceLineColor: lineColor,
        priceLineWidth: 1,
        priceLineStyle: 2
    });
}
        else if (switchId === 'toggle-price-label-switch') { config.showPriceLabel = element.classList.contains('active'); scheduleDraw(); }
        else if (switchId === 'toggle-countdown-switch') { config.showCountdown = element.classList.contains('active'); scheduleDraw(); }
        else if (switchId === 'toggle-crosshair-switch') {
            config.showCrosshair = element.classList.contains('active');
            chart.applyOptions({ crosshair: { vertLine: { visible: config.showCrosshair }, horzLine: { visible: config.showCrosshair } } });
        }
    }

    function resetToDefaults() {
        if (!confirm('Reset all settings to default values? This cannot be undone.')) return;
        config = {
            gridSpacing: 1000, gridColor: '#636363', gridOpacity: 1.0, gridLineWidth: 1,
            baseTickSize: 2.5, minCellHeight: 15, upColor: '#608feb', downColor: '#ff4242',
            candleOpacity: 1.0, seriesType: 'candle', minBubbleVolume: 500000,
            showPriceLine: true, showPriceLabel: true, showCountdown: true, showCrosshair: true,
            pocColor: '#f0b90b', currentTimeframe: 5, displayTimeframe: 5, candleWidthPercent: 0.20,
            clusterWidthPercent: 0.80, cumulativeMode: 'all', wickThickness: 1, borderThickness: 1,
            bgColor: '#0a0e1a', panelColor: '#0f1419', accentColor: '#3b82f6',
            absorptionColor: '#FFD700', statsFontFamily: "'JetBrains Mono', monospace",
            statsFontSize: 11, statsFontWeight: '600', cellFontSize: 11, cellFontWeight: '400',
            barSpacing: 50, clusterBgOpacity: 0, pocBorderWidth: 1.5, cellBorderWidth: 1,
            bubbleInnerSize: 5, bubbleOuterSize: 10, bubblePulseSpeed: 1500,
            absorptionDotSize: 4, absorptionGlow: 10, absorptionThreshold: 1000000,
            priceLabelFontSize: 9, timerFontSize: 8, timerOpacity: 0.9,
            defaultIndicatorHeight: 150, oiCandleWidth: 0.5, cvdLineThickness: 1,
            indicatorPadding: 10, indicatorBgOpacity: 0.95, drawDelay: 100, interactionHold: 180,
            clusterVolumeThreshold: 25000,
            showTPO: false, tpoTickSize: 50, tpoBlockWidth: 8,
            tpoOpacityVA: 0.65, tpoOpacityNonVA: 0.70,
            tpoColorSingle: '#ff6ec7', tpoColorVA: '#3b82f6',
            tpoColorNonVA: '#ffffff', tpoColorPOC: '#ffffff',
            priceScaleWidth: 44, priceScaleFontSize: 10,
        };
        tpoCacheKey = '';
        // Reset UI controls (existing ones)
        document.getElementById('series-type-select').value = 'candle';
        document.getElementById('bar-spacing-input').value = 50;
        document.getElementById('candle-opacity').value = 100; document.getElementById('opacity-val').textContent = '100%';
        document.getElementById('candle-width-input').value = 20; document.getElementById('cluster-width-input').value = 80;
        document.getElementById('wick-thickness').value = 1; document.getElementById('wick-thickness-val').textContent = '1px';
        document.getElementById('border-thickness').value = 1; document.getElementById('border-thickness-val').textContent = '1px';
        document.getElementById('up-candle-color').value = '#608feb'; document.getElementById('down-candle-color').value = '#ff4242';
        document.getElementById('grid-color-input').value = '#636363'; document.getElementById('poc-color-input').value = '#f0b90b';
        document.getElementById('bg-color-input').value = '#0a0e1a'; document.getElementById('panel-color-input').value = '#0f1419';
        document.getElementById('accent-color-input').value = '#3b82f6'; document.getElementById('absorption-color-input').value = '#FFD700';
        document.getElementById('stats-font-family').value = "'JetBrains Mono', monospace";
        document.getElementById('stats-font-size').value = 9; document.getElementById('stats-font-size-val').textContent = '9px';
        document.getElementById('stats-font-weight').value = '400';
        document.getElementById('cell-font-size').value = 9; document.getElementById('cell-font-size-val').textContent = '9px';
        document.getElementById('cell-font-weight').value = '400';
        document.getElementById('grid-spacing-input').value = 1000;
        document.getElementById('grid-opacity').value = 100; document.getElementById('grid-opacity-val').textContent = '100%';
        document.getElementById('grid-line-width').value = 1; document.getElementById('grid-line-width-val').textContent = '1px';
        document.getElementById('base-tick-input').value = 2.5; document.getElementById('min-cell-height-input').value = 15;
        document.getElementById('cumulative-mode-select').value = 'all';
        document.getElementById('cluster-volume-threshold').value = 50000;
        document.getElementById('cluster-bg-opacity').value = 0; document.getElementById('cluster-bg-opacity-val').textContent = '0%';
        document.getElementById('poc-border-width').value = 1.5; document.getElementById('poc-border-width-val').textContent = '1.5px';
        document.getElementById('cell-border-width').value = 1; document.getElementById('cell-border-width-val').textContent = '1px';
        document.getElementById('bubble-threshold-input').value = 500000;
        document.getElementById('bubble-inner-size').value = 5; document.getElementById('bubble-outer-size').value = 10;
        document.getElementById('bubble-pulse-speed').value = 1500; document.getElementById('bubble-pulse-speed-val').textContent = '1.5s';
        document.getElementById('absorption-dot-size').value = 4; document.getElementById('absorption-glow').value = 10;
        document.getElementById('absorption-threshold').value = 100000;
        document.getElementById('toggle-price-line-switch').classList.remove('active');
        document.getElementById('toggle-price-label-switch').classList.add('active');
        document.getElementById('toggle-countdown-switch').classList.add('active');
        document.getElementById('toggle-crosshair-switch').classList.add('active');
        document.getElementById('price-label-font-size').value = 10; document.getElementById('timer-font-size').value = 11;
        document.getElementById('timer-opacity').value = 90; document.getElementById('timer-opacity-val').textContent = '90%';
        document.getElementById('default-indicator-height').value = 150;
        document.getElementById('oi-candle-width').value = 50; document.getElementById('oi-candle-width-val').textContent = '50%';
        document.getElementById('cvd-line-thickness').value = 1; document.getElementById('cvd-line-thickness-val').textContent = '1px';
        document.getElementById('indicator-padding').value = 10; document.getElementById('indicator-bg-opacity').value = 95;
        document.getElementById('draw-delay').value = 50; document.getElementById('draw-delay-val').textContent = '50ms';
        document.getElementById('interaction-hold').value = 180; document.getElementById('interaction-hold-val').textContent = '180ms';
        updateCandleAppearance();
        document.getElementById('price-scale-width-input').value = 44;
        document.getElementById('price-scale-font-input').value = 10;
        chart.applyOptions({ rightPriceScale: { width: 44 }, layout: { background: { color: config.bgColor }, fontSize: 10 }, timeScale: { barSpacing: config.barSpacing } });
        mainSeries.applyOptions({ priceLineVisible: config.showPriceLine });
        chart.applyOptions({ crosshair: { vertLine: { visible: config.showCrosshair }, horzLine: { visible: config.showCrosshair } } });
        applyTimeframeChange(5); 
    }       
    // Settings event listeners
    document.getElementById('bar-spacing-input').addEventListener('input', (e) => { config.barSpacing = parseInt(e.target.value); chart.timeScale().applyOptions({ barSpacing: config.barSpacing }); scheduleDraw(); });
    document.getElementById('candle-width-input').addEventListener('input', (e) => { config.candleWidthPercent = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('cluster-width-input').addEventListener('input', (e) => { config.clusterWidthPercent = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('wick-thickness').addEventListener('input', (e) => { config.wickThickness = parseFloat(e.target.value); document.getElementById('wick-thickness-val').textContent = config.wickThickness+'px'; scheduleDraw(); });
    document.getElementById('border-thickness').addEventListener('input', (e) => { config.borderThickness = parseFloat(e.target.value); document.getElementById('border-thickness-val').textContent = config.borderThickness+'px'; scheduleDraw(); });
    document.getElementById('bg-color-input').addEventListener('change', (e) => { config.bgColor = e.target.value; chart.applyOptions({ layout: { background: { color: config.bgColor } } }); });
    document.getElementById('panel-color-input').addEventListener('change', (e) => { config.panelColor = e.target.value; });
    document.getElementById('accent-color-input').addEventListener('change', (e) => { config.accentColor = e.target.value; });
    document.getElementById('poc-color-input').addEventListener('change', (e) => { config.pocColor = e.target.value; scheduleDraw(); });
    document.getElementById('absorption-color-input').addEventListener('change', (e) => { config.absorptionColor = e.target.value; scheduleDraw(); });
    document.getElementById('stats-font-family').addEventListener('change', (e) => { config.statsFontFamily = e.target.value; document.getElementById('stats-font-preview').style.fontFamily = e.target.value; scheduleDraw(); });
    document.getElementById('stats-font-size').addEventListener('input', (e) => { config.statsFontSize = parseInt(e.target.value); document.getElementById('stats-font-size-val').textContent = config.statsFontSize+'px'; scheduleDraw(); });
    document.getElementById('stats-font-weight').addEventListener('change', (e) => { config.statsFontWeight = e.target.value; scheduleDraw(); });
    document.getElementById('cell-font-size').addEventListener('input', (e) => { config.cellFontSize = parseInt(e.target.value); document.getElementById('cell-font-size-val').textContent = config.cellFontSize+'px'; scheduleDraw(); });
    document.getElementById('cell-font-weight').addEventListener('change', (e) => { config.cellFontWeight = e.target.value; scheduleDraw(); });
    document.getElementById('grid-opacity').addEventListener('input', (e) => { config.gridOpacity = parseInt(e.target.value)/100; document.getElementById('grid-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('grid-line-width').addEventListener('input', (e) => { config.gridLineWidth = parseFloat(e.target.value); document.getElementById('grid-line-width-val').textContent = config.gridLineWidth+'px'; scheduleDraw(); });
    document.getElementById('base-tick-input').addEventListener('change', (e) => { config.baseTickSize = parseFloat(e.target.value); scheduleDraw(); });
    document.getElementById('min-cell-height-input').addEventListener('change', (e) => { config.minCellHeight = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('cluster-bg-opacity').addEventListener('input', (e) => { config.clusterBgOpacity = parseInt(e.target.value)/100; document.getElementById('cluster-bg-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('poc-border-width').addEventListener('input', (e) => { config.pocBorderWidth = parseFloat(e.target.value); document.getElementById('poc-border-width-val').textContent = config.pocBorderWidth+'px'; scheduleDraw(); });
    document.getElementById('cell-border-width').addEventListener('input', (e) => { config.cellBorderWidth = parseFloat(e.target.value); document.getElementById('cell-border-width-val').textContent = config.cellBorderWidth+'px'; scheduleDraw(); });
    document.getElementById('cluster-volume-threshold').addEventListener('input', (e) => { config.clusterVolumeThreshold = parseFloat(e.target.value) || 0; scheduleDraw(); });
    document.getElementById('bubble-inner-size').addEventListener('input', (e) => { config.bubbleInnerSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('bubble-outer-size').addEventListener('input', (e) => { config.bubbleOuterSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('bubble-pulse-speed').addEventListener('input', (e) => { config.bubblePulseSpeed = parseInt(e.target.value); document.getElementById('bubble-pulse-speed-val').textContent = (config.bubblePulseSpeed/1000).toFixed(1)+'s'; scheduleDraw(); });
    document.getElementById('absorption-dot-size').addEventListener('input', (e) => { config.absorptionDotSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('absorption-glow').addEventListener('input', (e) => { config.absorptionGlow = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('absorption-threshold').addEventListener('input', (e) => { config.absorptionThreshold = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('price-label-font-size').addEventListener('input', (e) => { config.priceLabelFontSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('timer-font-size').addEventListener('input', (e) => { config.timerFontSize = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('timer-opacity').addEventListener('input', (e) => { config.timerOpacity = parseInt(e.target.value)/100; document.getElementById('timer-opacity-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('default-indicator-height').addEventListener('input', (e) => { config.defaultIndicatorHeight = parseInt(e.target.value); });
    document.getElementById('oi-candle-width').addEventListener('input', (e) => { config.oiCandleWidth = parseInt(e.target.value)/100; document.getElementById('oi-candle-width-val').textContent = e.target.value+'%'; scheduleDraw(); });
    document.getElementById('cvd-line-thickness').addEventListener('input', (e) => { config.cvdLineThickness = parseFloat(e.target.value); document.getElementById('cvd-line-thickness-val').textContent = config.cvdLineThickness+'px'; scheduleDraw(); });
    document.getElementById('indicator-padding').addEventListener('input', (e) => { config.indicatorPadding = parseInt(e.target.value); scheduleDraw(); });
    document.getElementById('indicator-bg-opacity').addEventListener('input', (e) => { config.indicatorBgOpacity = parseInt(e.target.value)/100; scheduleDraw(); });
    document.getElementById('draw-delay').addEventListener('input', (e) => { config.drawDelay = parseInt(e.target.value); document.getElementById('draw-delay-val').textContent = config.drawDelay+'ms'; });
    document.getElementById('interaction-hold').addEventListener('input', (e) => { config.interactionHold = parseInt(e.target.value); document.getElementById('interaction-hold-val').textContent = config.interactionHold+'ms'; });
    document.getElementById('price-scale-font-input').addEventListener('input', (e) => {
    config.priceScaleFontSize = parseInt(e.target.value);
    chart.applyOptions({ layout: { fontSize: config.priceScaleFontSize } });
    extraPanels.forEach(p => p.chart.applyOptions({ layout: { fontSize: config.priceScaleFontSize } }));
    scheduleDraw();
});

    function getVisibleCandles(cssWidth) {
        const visibleCandles = [];
        if (!displayCandles) return visibleCandles;
        for (let i = 0; i < displayCandles.length; i++) {
            const candle = displayCandles[i];
            const x = chart.timeScale().timeToCoordinate(candle.time);
            if (x === null || x < -100 || x > cssWidth + 100) continue;
            visibleCandles.push({ i, x, candle });
        }
        return visibleCandles;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  TPO / Market Profile Engine
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    /**
     * buildTPOProfiles()
     * Processes displayCandles (base-5m granularity) to construct a full
     * Market Profile (TPO) for every UTC day present in the dataset.
     *
     * Returns an array of profile objects, one per session day, sorted oldest-first.
     */
    function buildTPOProfiles() {
        if (!displayCandles || displayCandles.length === 0) return [];

        const tickSize = Math.max(1, config.tpoTickSize); // guard against 0

        // â”€â”€ 1. Group candles by UTC calendar day â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const dayGroups = {};
        for (let i = 0; i < displayCandles.length; i++) {
            const c = displayCandles[i];
            const dayStart = Math.floor(c.time / 86400) * 86400; // 00:00 UTC
            if (!dayGroups[dayStart]) dayGroups[dayStart] = [];
            dayGroups[dayStart].push(c);
        }

        const profiles = [];
        const PERIOD_SECONDS = 1800; // 30-minute TPO periods

        const sortedDays = Object.keys(dayGroups).map(Number).sort((a, b) => a - b);

        sortedDays.forEach(dayStart => {
            const candles = dayGroups[dayStart];
            if (!candles || candles.length === 0) return;

            // â”€â”€ 2. Assign each candle to its 30-minute period â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const periodGroups = {}; // periodIndex -> [candles]
            candles.forEach(c => {
                const offset = c.time - dayStart;
                const periodIdx = Math.floor(offset / PERIOD_SECONDS);
                if (!periodGroups[periodIdx]) periodGroups[periodIdx] = [];
                periodGroups[periodIdx].push(c);
            });

            // â”€â”€ 3. Build rowMap: priceRowKey (integer) -> TPO block count â”€â”€â”€â”€â”€â”€
            //    Constraint: each row receives AT MOST 1 block per period.
            const rowMap = {}; // { priceRowInt: count }

            Object.values(periodGroups).forEach(pCandles => {
                // Determine the period's absolute High and Low
                let pH = -Infinity, pL = Infinity;
                pCandles.forEach(c => {
                    if (c.high > pH) pH = c.high;
                    if (c.low  < pL) pL = c.low;
                });

                // Floor both to the nearest tick boundary
                const rowLow  = Math.floor(pL / tickSize) * tickSize;
                const rowHigh = Math.floor(pH / tickSize) * tickSize;

                // Use a Set to enforce "one block per period per row" (idempotency)
                const hitThisPeriod = new Set();
                for (let p = rowLow; p <= rowHigh + tickSize * 0.001; p += tickSize) {
                    const key = Math.round(p); // integer key avoids float drift
                    if (!hitThisPeriod.has(key)) {
                        hitThisPeriod.add(key);
                        rowMap[key] = (rowMap[key] || 0) + 1;
                    }
                }
            });

            const rowKeys = Object.keys(rowMap);
            if (rowKeys.length === 0) return;

            // â”€â”€ 4. Compute total TPO count â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let totalTPO = 0;
            rowKeys.forEach(k => { totalTPO += rowMap[k]; });

            // â”€â”€ 5. Find POC (maximum blocks in any single row) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let pocPrice = null, pocCount = 0;
            rowKeys.forEach(k => {
                if (rowMap[k] > pocCount) {
                    pocCount = rowMap[k];
                    pocPrice = parseFloat(k);
                }
            });

            // â”€â”€ 6. Value Area calculation (70% of totalTPO) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            //    Classic algorithm: start at POC, expand the higher of
            //    {1 row up vs 1 row down} until â‰¥70% is accumulated.
            const sortedPrices = rowKeys.map(Number).sort((a, b) => a - b);
            const pocIdx = sortedPrices.findIndex(p => Math.abs(p - pocPrice) < 0.5);

            const vaTarget = totalTPO * 0.70;
            let vaCount = pocCount;
            let vaLow = pocPrice, vaHigh = pocPrice;
            let upIdx = pocIdx + 1, downIdx = pocIdx - 1;

            while (vaCount < vaTarget) {
                const hasUp   = upIdx   <  sortedPrices.length;
                const hasDown = downIdx >= 0;
                if (!hasUp && !hasDown) break;

                const upAdd   = hasUp   ? rowMap[sortedPrices[upIdx]]   : 0;
                const downAdd = hasDown ? rowMap[sortedPrices[downIdx]] : 0;

                // Tie-break: expand upward first (standard convention)
                if (hasUp && upAdd >= downAdd) {
                    vaCount += upAdd;
                    vaHigh = sortedPrices[upIdx];
                    upIdx++;
                } else if (hasDown) {
                    vaCount += downAdd;
                    vaLow = sortedPrices[downIdx];
                    downIdx--;
                } else {
                    vaCount += upAdd;
                    vaHigh = sortedPrices[upIdx];
                    upIdx++;
                }
            }

            // â”€â”€ 7. Identify single prints (count === 1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const singlePrints = new Set();
            rowKeys.forEach(k => {
                if (rowMap[k] === 1) singlePrints.add(parseFloat(k));
            });

            // â”€â”€ 8. Session extremes + max blocks (for potential width scaling) â”€
            const maxBlocks = Math.max(...Object.values(rowMap));
            const sessionHigh = Math.max(...candles.map(c => c.high));
            const sessionLow  = Math.min(...candles.map(c => c.low));

// â”€â”€ 9. First candle time (used for X-anchor) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const firstCandleTime = candles[0].time;

        // â”€â”€ 10. Extreme rows: top/bottom consecutive rows with â‰¤ 2 blocks â”€â”€
        const topExtremes = new Set();
        const bottomExtremes = new Set();
        for (let i = sortedPrices.length - 1; i >= 0; i--) {
            if (rowMap[sortedPrices[i]] === 2) topExtremes.add(sortedPrices[i]);
            else break;
        }
        for (let i = 0; i < sortedPrices.length; i++) {
            if (rowMap[sortedPrices[i]] === 2) bottomExtremes.add(sortedPrices[i]);
            else break;
        }
            profiles.push({
                dayStart,
                firstCandleTime,
                rowMap,        // { priceRowInt: tpoCount }
                sortedPrices,  // sorted numeric array of rowMap keys
                pocPrice,
                pocCount,
                vaLow,
                vaHigh,
                totalTPO,
                singlePrints,
                maxBlocks,
                sessionHigh,
                sessionLow,
                tickSize, // snapshot of tickSize used (in case user changes it)
                topExtremes,
                bottomExtremes,
                sessionEndTime: candles[candles.length - 1].time,   
            });
        });

        return profiles;
    }

    /**
     * drawTPO(cssWidth, candleBottomY)
     * Renders all cached TPO profiles onto the offscreenCtx.
     * Must be called from within drawFrames() AFTER the main canvas is cleared.
     */
    function drawTPO(cssWidth, candleBottomY) {
        if (!config.showTPO) return;

        // â”€â”€ Cache invalidation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Rebuild only when candle data or tick size changes.
        const lastC = displayCandles[displayCandles.length - 1];
        const newCacheKey = `${displayCandles.length}_${lastC?.time ?? 0}_${Math.round(lastC?.high ?? 0)}_${Math.round(lastC?.low ?? 0)}_${config.tpoTickSize}`;
        if (newCacheKey !== tpoCacheKey || !tpoProfilesCache) {
            tpoProfilesCache = buildTPOProfiles();
            tpoCacheKey = newCacheKey;
        }

        if (!tpoProfilesCache || tpoProfilesCache.length === 0) return;

        const timeScale  = chart.timeScale();
        const blockW     = Math.max(2, config.tpoBlockWidth);

        tpoProfilesCache.forEach(profile => {
            // â”€â”€ Determine X anchor (left edge of session) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const anchorX = timeScale.timeToCoordinate(profile.firstCandleTime);
            if (anchorX === null) return;

            // Rough frustum cull: skip if entire profile is off-screen
            // (max profile width = maxBlocks * blockW)
            const profileMaxWidth = profile.maxBlocks * blockW;
            if (anchorX + profileMaxWidth < -50 || anchorX > cssWidth + 50) return;

            const { rowMap, sortedPrices, pocPrice, vaLow, vaHigh, singlePrints, tickSize } = profile;

            // â”€â”€ Draw each price row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            sortedPrices.forEach(price => {
                const count = rowMap[price];

                // â”€â”€ Y coordinates for this row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // A row spans [price, price + tickSize]
                const yTop    = mainSeries.priceToCoordinate(price + tickSize);
                const yBottom = mainSeries.priceToCoordinate(price);
                if (yTop === null || yBottom === null) return;

                const rowY = Math.min(yTop, yBottom);
                const rowH = Math.max(1, Math.abs(yBottom - yTop) - 1);

                // Skip rows fully outside the price-chart area
                if (rowY > candleBottomY || rowY + rowH < 0) return;

            // â”€â”€ Classify row type â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                const isSingle  = singlePrints.has(price);
                const isInVA    = price >= vaLow && price <= vaHigh;
                const isPOC     = Math.abs(price - pocPrice) < 0.5;

                let fillColor, fillAlpha;
                if (isSingle) {
                    fillColor = config.tpoColorSingle;
                    fillAlpha = Math.min(1, config.tpoOpacityVA + 0.20); // singles/extremes always vivid
                } else if (isInVA) {
                    fillColor = config.tpoColorVA;
                    fillAlpha = config.tpoOpacityVA;
                } else {
                    fillColor = config.tpoColorNonVA;
                    fillAlpha = config.tpoOpacityNonVA;
                }

                // â”€â”€ Draw individual TPO blocks for this row â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                // Each block is one 30-min period "letter" represented as a rect.
                const totalRowWidth = count * blockW;

                // Clip to canvas width (don't draw past price scale)
                const drawableBlocks = Math.min(count, Math.ceil((cssWidth - anchorX) / blockW));

                for (let b = 0; b < drawableBlocks; b++) {
                    const bx = anchorX + b * blockW;
                    if (bx > cssWidth - 2) break;
                    const bw = Math.min(blockW - 1, cssWidth - bx - 1); // 1px gap between blocks
                    offscreenCtx.fillStyle = hexToRgba(fillColor, fillAlpha);
                    offscreenCtx.fillRect(bx, rowY, bw, rowH);
                }

                // â”€â”€ POC gold border drawn around the full row extent â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                if (isPOC && count > 0) {
                    offscreenCtx.save();
                    offscreenCtx.strokeStyle  = config.tpoColorPOC;
                    offscreenCtx.lineWidth    = 1.5;
                    offscreenCtx.shadowColor  = config.tpoColorPOC;
                    offscreenCtx.shadowBlur   = 4;
                    const clippedW = Math.min(totalRowWidth, cssWidth - anchorX - 2);
                    offscreenCtx.strokeRect(anchorX, rowY, clippedW, rowH);
                    offscreenCtx.restore();
                }
            });

            // â”€â”€ Session boundary separator (thin vertical line at anchor) â”€â”€â”€â”€â”€â”€
            offscreenCtx.save();
            offscreenCtx.strokeStyle = 'rgba(255,255,255,0.06)';
            offscreenCtx.lineWidth   = 1;
            offscreenCtx.setLineDash([3, 5]);
            offscreenCtx.beginPath();
            offscreenCtx.moveTo(anchorX, 0);
            offscreenCtx.lineTo(anchorX, candleBottomY);
            offscreenCtx.stroke();
            offscreenCtx.setLineDash([]);
            offscreenCtx.restore();

// â”€â”€ VA High / VA Low reference labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const vaHighY = mainSeries.priceToCoordinate(vaHigh + tickSize);
            const vaLowY  = mainSeries.priceToCoordinate(vaLow);
            const labelX  = anchorX + profile.maxBlocks * blockW + 4;
            if (labelX < cssWidth - 10) {
                offscreenCtx.save();
                offscreenCtx.font      = `600 9px 'JetBrains Mono', monospace`;
                offscreenCtx.fillStyle = hexToRgba(config.tpoColorVA, 0.75);
                offscreenCtx.textAlign = 'left';
                if (vaHighY !== null && vaHighY > 0 && vaHighY < candleBottomY) {
                    offscreenCtx.fillText('', labelX, vaHighY - 2);
                }
                if (vaLowY !== null && vaLowY > 0 && vaLowY < candleBottomY) {
                    offscreenCtx.fillText('', labelX, vaLowY + 10);
                }
                const pocY = mainSeries.priceToCoordinate(pocPrice + tickSize / 2);
                if (pocY !== null && pocY > 0 && pocY < candleBottomY) {
                    offscreenCtx.fillStyle = hexToRgba(config.tpoColorPOC, 0.90);
                    offscreenCtx.fillText('', labelX, pocY + 4);
                }
                offscreenCtx.restore();
            }

            // â”€â”€ Dotted lines for unresolved extreme rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // "Taken out" = any candle AFTER this session has traded through the row.
            // We scan displayCandles for candles with time > last candle of this session.
            const sessionEndTime = profile.sessionEndTime;

            // Pre-compute post-session high/low from all subsequent candles
            let postSessionHigh = -Infinity;
            let postSessionLow  =  Infinity;
            for (let ci = displayCandles.length - 1; ci >= 0; ci--) {
                const c = displayCandles[ci];
                if (c.time <= sessionEndTime) break;
                if (c.high > postSessionHigh) postSessionHigh = c.high;
                if (c.low  < postSessionLow)  postSessionLow  = c.low;
            }
            // Also include the live tick (current price) for the active session
            if (postSessionHigh === -Infinity) postSessionHigh = currentPrice;
            if (postSessionLow  ===  Infinity) postSessionLow  = currentPrice;

            const lastCandleInData = displayCandles[displayCandles.length - 1];
            const currentCandleX = lastCandleInData
                ? (timeScale.timeToCoordinate(lastCandleInData.time) ?? cssWidth - 80)
                : cssWidth - 80;
            const extremeLineEndX   = Math.min(currentCandleX + 20, cssWidth - 80);
            const extremeLineStartX = anchorX + profile.maxBlocks * blockW;

            if (extremeLineStartX < extremeLineEndX) {
                // Top extremes: hide if any post-session candle high reached the row
                profile.topExtremes.forEach(price => {
                    // Row spans [price, price + tickSize]. Taken out if high >= price.
                    if (postSessionHigh >= price) return;
                    const rowMidY = mainSeries.priceToCoordinate(price + tickSize * 0.5);
                    if (rowMidY === null || rowMidY < 0 || rowMidY > candleBottomY) return;
                    offscreenCtx.save();
                    offscreenCtx.strokeStyle = config.tpoColorSingle;
                    offscreenCtx.lineWidth   = 1.2;
                    offscreenCtx.globalAlpha = 0.70;
                    offscreenCtx.setLineDash([4, 5]);
                    offscreenCtx.beginPath();
                    offscreenCtx.moveTo(extremeLineStartX, rowMidY);
                    offscreenCtx.lineTo(extremeLineEndX,   rowMidY);
                    offscreenCtx.stroke();
                    offscreenCtx.setLineDash([]);
                    offscreenCtx.restore();
                });

                // Bottom extremes: hide if any post-session candle low reached the row
                profile.bottomExtremes.forEach(price => {
                    // Row spans [price, price + tickSize]. Taken out if low <= price + tickSize.
                    if (postSessionLow <= price + tickSize) return;
                    const rowMidY = mainSeries.priceToCoordinate(price + tickSize * 0.5);
                    if (rowMidY === null || rowMidY < 0 || rowMidY > candleBottomY) return;
                    offscreenCtx.save();
                    offscreenCtx.strokeStyle = config.tpoColorSingle;
                    offscreenCtx.lineWidth   = 1.2;
                    offscreenCtx.globalAlpha = 0.70;
                    offscreenCtx.setLineDash([4, 5]);
                    offscreenCtx.beginPath();
                    offscreenCtx.moveTo(extremeLineStartX, rowMidY);
                    offscreenCtx.lineTo(extremeLineEndX,   rowMidY);
                    offscreenCtx.stroke();
                    offscreenCtx.setLineDash([]);
                    offscreenCtx.restore();
});
            }
        }); // <--- ADD THIS (Closes tpoProfilesCache.forEach)
    } // <--- ADD THIS (Closes drawTPO function)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Indicator System
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BaseIndicator {
    constructor(id, name, defaultHeight = config.defaultIndicatorHeight) {
        this.id = id; this.name = name; this.height = defaultHeight;
        this.element = null; this.canvas = null; this.ctx = null;
        this.offscreenCanvas = null; this.offscreenCtx = null; this.visible = false;
    }
    createElement() {
        const div = document.createElement('div');
        div.className = 'indicator-pane'; div.id = `indicator-${this.id}`; div.style.height = this.height+'px';
        div.innerHTML = `
            <div class="pane-header" data-indicator="${this.id}">
                <span class="pane-label">${this.name}</span>
                <div class="pane-close" data-indicator="${this.id}">âœ•</div>
            </div>
            <div class="resizer-handle" data-indicator="${this.id}"><div class="resizer-line"></div></div>
            <canvas class="pane-canvas" id="canvas-${this.id}"></canvas>`;
        this.element = div;
        this.canvas = div.querySelector(`#canvas-${this.id}`);
        this.ctx = this.canvas.getContext('2d');
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        this.setupEventListeners();
        return div;
    }
setupEventListeners() {
    this.element.querySelector('.pane-close').addEventListener('click', (e) => {
        e.stopPropagation();
        const mgr = findManagerForIndicator(this.id, this.element);
        mgr.removeIndicator(this.id);
    });
    const resizer = this.element.querySelector('.resizer-handle');
    let dragging = false, startY = 0, startH = 0;
    resizer.addEventListener('mousedown', (e) => {
        e.stopPropagation(); dragging = true; startY = e.clientY; startH = this.height;
        document.body.style.cursor = 'ns-resize';
    });
    window.addEventListener('mousemove', (e) => {
        if (!dragging) return;
        this.height = Math.max(MIN_PANE_HEIGHT, startH + (startY - e.clientY));
        const mgr = findManagerForIndicator(this.id, this.element);
        mgr.updateLayout();
    });
    window.addEventListener('mouseup', () => {
        if (dragging) { dragging = false; document.body.style.cursor = ''; }
    });
    this.element.querySelector('.pane-header').addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('pane-close')) return;
        const mgr = findManagerForIndicator(this.id, this.element);
        mgr.startDrag(this.id, e);
    });
}
    setupBuffers(width, height) {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = Math.floor(width*dpr); this.canvas.height = Math.floor(height*dpr);
        this.canvas.style.width = width+'px'; this.canvas.style.height = height+'px';
        this.offscreenCanvas.width = this.canvas.width; this.offscreenCanvas.height = this.canvas.height;
        this.offscreenCtx.setTransform(dpr,0,0,dpr,0,0); this.ctx.setTransform(1,0,0,1,0,0);
    }
    show() { this.visible = true; }
    hide() { this.visible = false; }
    draw(cssWidth) {}
    render() {
        if (!this.visible || !this.ctx || !this.offscreenCanvas) return;
        this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
        this.ctx.drawImage(this.offscreenCanvas,0,0);
    }
}

class OIIndicator extends BaseIndicator {
        constructor() { super('oi', 'Open Interest', 200); }
        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;
            const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
            const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
            ctxS.clearRect(0, 0, cssWidth, this.height);
            const barSpacing = chart.timeScale().options().barSpacing;
            const visibleCandles = getVisibleCandles(cssWidth);

            let minOI = Infinity, maxOI = -Infinity;
            visibleCandles.forEach(({ candle, x }) => {
                if (x > drawWidth) return;
                if (candle.oiClose && candle.oiClose > 0) {
                    const cHigh = candle.oiHigh || Math.max(candle.oiOpen, candle.oiClose);
                    const cLow  = candle.oiLow  || Math.min(candle.oiOpen, candle.oiClose);
                    if (cHigh > maxOI) maxOI = cHigh;
                    if (cLow < minOI && cLow > 0) minOI = cLow;
                }
            });
            if (maxOI === -Infinity || minOI === Infinity) { minOI = 0; maxOI = 100; }
            if (minOI === maxOI) { minOI = maxOI * 0.99; maxOI = maxOI * 1.01; }

            const oPadding   = config.indicatorPadding;
            const availableH = this.height - oPadding * 2;
            const oiRange    = maxOI - minOI;
            const getOIY = val => val <= 0
                ? this.height - oPadding
                : oPadding + availableH * (1 - (val - minOI) / oiRange);

            visibleCandles.forEach(({ candle, x }) => {
                if (x > drawWidth) return;
                if (!candle.oiClose || candle.oiClose <= 0) return;
                const cOpen  = candle.oiOpen || candle.oiClose;
                const cClose = candle.oiClose;
                const cHigh  = candle.oiHigh || Math.max(cOpen, cClose);
                const cLow   = candle.oiLow  || Math.min(cOpen, cClose);
                const openY  = getOIY(cOpen);
                const closeY = getOIY(cClose);
                const highY  = getOIY(cHigh);
                const lowY   = getOIY(cLow);
                const isUp   = cClose >= cOpen;
                const color  = hexToRgba(isUp ? config.oiUpColor : config.oiDownColor, config.oiOpacity);
                const w      = Math.max(3, barSpacing * config.oiCandleWidth);

                // Wick
                ctxS.strokeStyle = color;
                ctxS.lineWidth   = 1;
                ctxS.beginPath();
                ctxS.moveTo(x, highY);
                ctxS.lineTo(x, lowY);
                ctxS.stroke();

                // Body
                const bodyTop = Math.min(openY, closeY);
                const bodyH   = Math.max(1, Math.abs(closeY - openY));
                ctxS.fillStyle = color;
                ctxS.fillRect(x - w / 2, bodyTop, w, bodyH);

                // Border
                ctxS.strokeStyle = config.oiBorderColor;
                ctxS.lineWidth   = 1;
                ctxS.strokeRect(x - w / 2, bodyTop, w, bodyH);
            });
        }
    }

class CVDIndicator extends BaseIndicator {
        constructor() { super('cvd','Cumulative Volume Delta',150); }
        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;
            const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
            const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
            ctxS.clearRect(0,0,cssWidth,this.height);
            
            const cvdData = []; 
            let cumulativeDelta = 0;
            displayCandles.forEach(candle => {
                const tsKey = String(Math.floor(candle.time));
                const buckets = displayClusters[tsKey];
                if (buckets) { 
                    let d=0; 
                    Object.values(buckets).forEach(b => d+=(b.buy-b.sell)); 
                    cumulativeDelta+=d; 
                }
                cvdData.push({ time: candle.time, cvd: cumulativeDelta });
            });
            
            if (cvdData.length === 0) return;
            const visibleCandles = getVisibleCandles(cssWidth);
            if (visibleCandles.length === 0) return;

            // â”€â”€ Build Map once instead of find() on every iteration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            const cvdMap = new Map(cvdData.map(d => [d.time, d.cvd]));
            
            // â”€â”€ First loop: calculate min/max â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            let minCVD = Infinity, maxCVD = -Infinity;
            visibleCandles.forEach(item => {
                const cvd = cvdMap.get(item.candle.time);  // â† was cvdData.find(...)
                if (cvd !== undefined) { 
                    if (cvd < minCVD) minCVD = cvd; 
                    if (cvd > maxCVD) maxCVD = cvd; 
                }
            });
            
            if (minCVD===Infinity||maxCVD===-Infinity) return;
            if (minCVD===maxCVD) { minCVD-=1000000; maxCVD+=1000000; }
            
            const padding=config.indicatorPadding;
            const availableH=this.height-(padding*2);
            const cvdRange=maxCVD-minCVD;
            const getCVDY = (val) => padding+(availableH*(1-(val-minCVD)/cvdRange));
            
            // Zero line
            if (minCVD<=0 && maxCVD>=0) {
                const zeroY = getCVDY(0);
                ctxS.strokeStyle='#3a3f4e'; ctxS.lineWidth=1; ctxS.setLineDash([4,4]);
                ctxS.beginPath(); ctxS.moveTo(0,zeroY); ctxS.lineTo(drawWidth,zeroY); ctxS.stroke(); 
                ctxS.setLineDash([]);
            }
            
            // â”€â”€ Second loop: draw the line â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            ctxS.beginPath(); 
            let firstPoint=true;
            visibleCandles.forEach(item => {
                const cvd = cvdMap.get(item.candle.time);  // â† was cvdData.find(...)
                if (cvd === undefined || item.x > drawWidth) return;
                const y = getCVDY(cvd);
                if (firstPoint) { ctxS.moveTo(item.x,y); firstPoint=false; } 
                else ctxS.lineTo(item.x,y);
            });
            
            const finalCVD = cvdData[cvdData.length-1]?.cvd||0;
            const lineColor = (config.cvdLineColor && config.cvdLineColor !== 'auto') ? config.cvdLineColor : (finalCVD >= 0 ? config.upColor : config.downColor);
            ctxS.strokeStyle=lineColor; ctxS.lineWidth=config.cvdLineThickness; ctxS.stroke();
            
            // Labels
            ctxS.font=`10px ${config.statsFontFamily}`; ctxS.textAlign='right'; ctxS.fillStyle='#8b92a7';
            ctxS.fillText(formatUSD(maxCVD),drawWidth-5,getCVDY(maxCVD)+12);
            ctxS.fillText(formatUSD(minCVD),drawWidth-5,getCVDY(minCVD)-5);
            
            if (finalCVD!==undefined) {
                const lastVisible = visibleCandles[visibleCandles.length-1];
                const lastX = lastVisible && lastVisible.x < drawWidth ? lastVisible.x : drawWidth-80;
                ctxS.fillStyle=lineColor; ctxS.font=`bold 11px ${config.statsFontFamily}`;
                ctxS.textAlign='left'; ctxS.fillText(formatUSD(finalCVD),lastX+10,getCVDY(finalCVD)+4);
            }
        }
    }

    class BarStatsIndicator extends BaseIndicator {
        constructor() { super('barstats', 'Bar Statistics', 72); }

        draw(cssWidth) {
            if (!this.visible || !this.offscreenCtx) return;
            const ctxS = this.offscreenCtx;

            const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
            const drawWidth = cssWidth - PRICE_SCALE_WIDTH;

            ctxS.clearRect(0, 0, cssWidth, this.height);
            ctxS.save();
            ctxS.beginPath();
            ctxS.rect(0, 0, drawWidth, this.height);
            ctxS.clip();


            const visibleCandles = getVisibleCandles(cssWidth);
            if (visibleCandles.length === 0) return;

            const barSpacing = chart.timeScale().options().barSpacing;
            const cellWidth = Math.max(barSpacing * 0.92, 6);

            const stats = visibleCandles.map(({ candle, x }) => {
                const tsKey = String(Math.floor(candle.time));
                const buckets = displayClusters[tsKey];
                let buy = 0, sell = 0;
                if (buckets) Object.values(buckets).forEach(d => { buy += d.buy; sell += d.sell; });
                return { x, totalVol: buy + sell, delta: buy - sell };
            });

            const maxVol = Math.max(...stats.map(s => s.totalVol), 1);
            const maxDelta = Math.max(...stats.map(s => Math.abs(s.delta)), 1);

            const HEADER_H = 0;
            const ROW_H = this.height / 2;

            ctxS.fillStyle = config.bgColor;
            ctxS.fillRect(0, 0, drawWidth, this.height);

            let lineEndX = 0;

            const fontSize = Math.max(8, Math.min(config.cellFontSize, Math.floor(cellWidth * 0.32)));

            stats.forEach(({ x, totalVol, delta }) => {
                if (x > drawWidth) return;

                const currentRightEdge = x + cellWidth / 2;
                lineEndX = Math.min(currentRightEdge, drawWidth);

                const volRatio = totalVol / maxVol;
                const deltaRatio = Math.abs(delta) / maxDelta;
                const isDeltaPos = delta >= 0;
                const colLeft = x - cellWidth / 2;

                const volAlpha = 0.08 + volRatio * 0.65;
                ctxS.fillStyle = hexToRgba(config.barStatsUpColor, volAlpha);
                ctxS.fillRect(colLeft, 0, cellWidth, ROW_H);

                const deltaAlpha = 0.08 + deltaRatio * 0.78;
                ctxS.fillStyle = hexToRgba(isDeltaPos ? config.barStatsUpColor : config.barStatsDownColor, deltaAlpha);
                ctxS.fillRect(colLeft, ROW_H, cellWidth, ROW_H);

                ctxS.strokeStyle = 'rgba(26,31,46,0.35)';
                ctxS.lineWidth = 0.5;
                ctxS.beginPath();
                ctxS.moveTo(colLeft, 0);
                ctxS.lineTo(colLeft, this.height);
                ctxS.stroke();

                if (cellWidth >= 28) {
                    ctxS.textAlign = 'center';
                    ctxS.textBaseline = 'middle';
                    ctxS.font = `${config.cellFontWeight} ${fontSize}px ${config.statsFontFamily}`;
                    ctxS.fillStyle = 'rgba(232,234,237,0.92)';
                    ctxS.fillText(formatUSD(totalVol), x, ROW_H / 2);
                    ctxS.fillText(formatUSD(delta), x, ROW_H * 1.5);
                }
            });

            if (lineEndX > 0) {
                ctxS.strokeStyle = 'rgba(26,31,46,0.7)';
                ctxS.lineWidth = 1;
                ctxS.beginPath();
                ctxS.moveTo(0, ROW_H);
                ctxS.lineTo(lineEndX, ROW_H);
                ctxS.stroke();
        }
    ctxS.restore();
        }
    }
    class VWAPIndicator extends BaseIndicator {
        constructor() { super('vwap', 'VWAP', 0); } // Height 0 = overlay on main chart
        
        draw(cssWidth) {
            if (!this.visible) return;
            // VWAP is drawn as overlay on main chart canvas, not in separate pane
            // We'll draw it in drawFrames instead
        }
    }

    let vwapData = [];
    let vwapCacheKey = '';

function calculateVWAP() {
        vwapData = [];
        const now = new Date();
        const todayStart = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0));
        const sessionStartTime = Math.floor(todayStart.getTime() / 1000);
        let cumulativePV = 0, cumulativeVolume = 0;
        for (let i = 0; i < displayCandles.length; i++) {
            const candle = displayCandles[i];
            if (candle.time < sessionStartTime) continue;
            const barVolume = candle.volume || 0;
            if (barVolume === 0) continue;
            const typicalPrice = (candle.high + candle.low + candle.close) / 3;
            cumulativePV += typicalPrice * barVolume;
            cumulativeVolume += barVolume;
            vwapData.push({ time: candle.time, vwap: cumulativeVolume > 0 ? cumulativePV / cumulativeVolume : typicalPrice });
        }
    }

 function drawVWAP(cssWidth, candleBottomY) {
    if (!config.vwapVisible) return;

    const lastCandle = displayCandles[displayCandles.length - 1];
    const cacheKey = `${displayCandles.length}_${lastCandle?.time ?? 0}_${lastCandle?.volume ?? 0}_${lastCandle?.high ?? 0}_${lastCandle?.low ?? 0}`;
    if (cacheKey !== vwapCacheKey) { calculateVWAP(); vwapCacheKey = cacheKey; }
    if (vwapData.length === 0) return;

    const timeScale        = chart.timeScale();
    const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
    const drawWidth        = cssWidth - PRICE_SCALE_WIDTH;

    offscreenCtx.save();
    offscreenCtx.strokeStyle = config.vwapColor;
    offscreenCtx.lineWidth   = 1;
    offscreenCtx.setLineDash(getLineDash(config.vwapLineStyle));
    offscreenCtx.globalAlpha = 0.85;

    offscreenCtx.beginPath();
    let firstPoint = true;
    vwapData.forEach(point => {
        const x = timeScale.timeToCoordinate(point.time);
        if (x === null || x < -100 || x > drawWidth) return;
        const y = mainSeries.priceToCoordinate(point.vwap);
        if (y === null || y < 0 || y > candleBottomY) return;
        if (firstPoint) { offscreenCtx.moveTo(x, y); firstPoint = false; }
        else offscreenCtx.lineTo(x, y);
    });
    offscreenCtx.stroke();
    offscreenCtx.setLineDash([]);

    // Label next to the last visible VWAP point
    if (vwapData.length > 0 && (config.vwapShowLabel || config.vwapShowPrice)) {
        const last = vwapData[vwapData.length - 1];
        const lastX = timeScale.timeToCoordinate(last.time);
        const lastY = mainSeries.priceToCoordinate(last.vwap);
        if (lastX !== null && lastY !== null && lastY >= 0 && lastY <= candleBottomY) {
            let text = '';
            if (config.vwapShowLabel) text += 'VWAP';
            if (config.vwapShowLabel && config.vwapShowPrice) text += ' ';
            if (config.vwapShowPrice) text += last.vwap.toFixed(2);
            if (text) {
                offscreenCtx.font      = "bold 10px 'JetBrains Mono', monospace";
                offscreenCtx.fillStyle = config.vwapColor;
                offscreenCtx.textAlign = 'left';
                offscreenCtx.globalAlpha = 0.9;
                offscreenCtx.fillText(text, lastX + 8, lastY + 4);
            }
        }
    }

    offscreenCtx.restore();
}

function findManagerForIndicator(id, element) {
    if (element) {
        if (indicatorManager.container.contains(element)) return indicatorManager;
        for (const p of extraPanels) {
            if (p.indicatorManager.container.contains(element)) return p.indicatorManager;
        }
    }
    if (indicatorManager.indicators.has(id)) return indicatorManager;
    for (const p of extraPanels) {
        if (p.indicatorManager.indicators.has(id)) return p.indicatorManager;
    }
    return indicatorManager;
}
    class IndicatorManager {
        constructor() { this.indicators = new Map(); this.order = []; this.container = document.getElementById('indicators-container'); this.dragState = null; this.placeholder = null; this.chart = null; this.wrapper = null; this.onLayout = null; }
        addIndicator(indicator) {
            if (this.indicators.has(indicator.id)) return;
            this.container.appendChild(indicator.createElement());
            this.indicators.set(indicator.id, indicator); this.order.push(indicator.id); indicator.show(); this.updateLayout();
        }
        removeIndicator(id) {
            const indicator = this.indicators.get(id); if (!indicator) return;
            indicator.hide(); indicator.element.remove(); this.indicators.delete(id); this.order = this.order.filter(i=>i!==id); this.updateLayout();
            const toggleBtn = document.getElementById(`toggle-${id}`); if (toggleBtn) toggleBtn.classList.remove('active');
        }
        getIndicator(id) { return this.indicators.get(id); }
    updateLayout() {
            const activeChart = this.chart || chart;
            const wrapper = this.wrapper || activeWrapperEl || document.getElementById('panel-wrapper-0');
            const totalHeight = window.innerHeight - HEADER_HEIGHT;
            let totalIndicatorHeight = 0;
            this.order.forEach(id => { const ind = this.indicators.get(id); if (ind && ind.visible) totalIndicatorHeight += ind.height; });
            const marginPct = Math.min(0.92, (totalIndicatorHeight + TIME_AXIS_HEIGHT) / totalHeight);
            activeChart.priceScale('right').applyOptions({ scaleMargins: { top: 0.05, bottom: marginPct } });
            let currentBottom = TIME_AXIS_HEIGHT;
            this.order.forEach(id => {
                const indicator = this.indicators.get(id); if (!indicator || !indicator.visible) return;
                indicator.element.style.bottom = currentBottom+'px'; indicator.element.style.height = indicator.height+'px';
                indicator.setupBuffers(wrapper.clientWidth, indicator.height); currentBottom += indicator.height;
            });
            activeChart.applyOptions({ width: wrapper.clientWidth, height: totalHeight });
            updatePaneRight();
            if (this.onLayout) this.onLayout();
            else if (typeof scheduleDraw === 'function') scheduleDraw();
        }
        startDrag(id, e) {
            const indicator = this.indicators.get(id); if (!indicator) return;
            this.dragState = { id, startY: e.clientY, startOrder: [...this.order] };
            indicator.element.classList.add('dragging');
            this.placeholder = document.createElement('div'); this.placeholder.className = 'drag-placeholder'; this.placeholder.style.height = '2px';
            document.getElementById('panel-wrapper-0').appendChild(this.placeholder);
            document.addEventListener('mousemove', this.handleDragMove); document.addEventListener('mouseup', this.handleDragEnd);
        }
        handleDragMove = (e) => {
            if (!this.dragState) return;
            const wrapper = document.getElementById('panel-wrapper-0');
            const relativeY = wrapper.getBoundingClientRect().bottom - e.clientY;
            let insertIndex = 0, cumulativeHeight = TIME_AXIS_HEIGHT;
            for (let i=0; i<this.order.length; i++) {
                const ind = this.indicators.get(this.order[i]); if (!ind || ind.id===this.dragState.id) continue;
                if (relativeY > cumulativeHeight + (ind.height/2)) insertIndex = i+1;
                cumulativeHeight += ind.height;
            }
            let placeholderBottom = TIME_AXIS_HEIGHT;
            for (let i=0; i<insertIndex; i++) { const ind = this.indicators.get(this.order[i]); if (ind && ind.id!==this.dragState.id) placeholderBottom += ind.height; }
            this.placeholder.style.bottom = placeholderBottom+'px';
        }
        handleDragEnd = () => {
            if (!this.dragState) return;
            const indicator = this.indicators.get(this.dragState.id); if (indicator) indicator.element.classList.remove('dragging');
            const placeholderBottom = parseInt(this.placeholder.style.bottom);
            let newOrder = [], cumulativeHeight = TIME_AXIS_HEIGHT, inserted = false;
            this.order.forEach(id => {
                if (id === this.dragState.id) return;
                const ind = this.indicators.get(id); if (!ind) return;
                if (!inserted && cumulativeHeight >= placeholderBottom) { newOrder.push(this.dragState.id); inserted = true; }
                newOrder.push(id); cumulativeHeight += ind.height;
            });
            if (!inserted) newOrder.push(this.dragState.id);
            this.order = newOrder;
            if (this.placeholder) { this.placeholder.remove(); this.placeholder = null; }
            document.removeEventListener('mousemove', this.handleDragMove); document.removeEventListener('mouseup', this.handleDragEnd);
            this.dragState = null; this.updateLayout();
        }
        drawAll(cssWidth) { this.indicators.forEach(ind => { if (ind.visible) { ind.draw(cssWidth); ind.render(); } }); }
    }

    let indicatorManager = new IndicatorManager();
    indicatorManager.chart = chart;
    indicatorManager.wrapper = document.getElementById('panel-wrapper-0');
    indicatorManager.addIndicator(new OIIndicator());

    document.getElementById('toggle-oi').addEventListener('click', function() {
        const mgr = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
        if (!mgr) return;
        const ind = mgr.getIndicator('oi');
        if (ind && ind.visible) { mgr.removeIndicator('oi'); this.classList.remove('active'); }
        else { mgr.addIndicator(new OIIndicator()); this.classList.add('active'); }
    });
    document.getElementById('toggle-cvd').addEventListener('click', function() {
        const mgr = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
        if (!mgr) return;
        const ind = mgr.getIndicator('cvd');
        if (ind && ind.visible) { mgr.removeIndicator('cvd'); this.classList.remove('active'); }
        else { mgr.addIndicator(new CVDIndicator()); this.classList.add('active'); }
    });
    document.getElementById('toggle-barstats').addEventListener('click', function() {
        const mgr = selectedPanelId === 0 ? indicatorManager : extraPanels.find(p => p.id === selectedPanelId)?.indicatorManager;
        if (!mgr) return;
        const ind = mgr.getIndicator('barstats');
        if (ind && ind.visible) { mgr.removeIndicator('barstats'); this.classList.remove('active'); }
        else { mgr.addIndicator(new BarStatsIndicator()); this.classList.add('active'); }
        scheduleDraw();
    });

    document.getElementById('toggle-dailylevels').addEventListener('click', function() {
    if (selectedPanelId === 0) {
        config.showDailyLevels = !config.showDailyLevels;
        this.classList.toggle('active', config.showDailyLevels);
        scheduleDraw();
    } else {
        const panel = extraPanels.find(p => p.id === selectedPanelId);
        if (panel) {
            panel.showDailyLevels = !panel.showDailyLevels;
            this.classList.toggle('active', panel.showDailyLevels);
            schedulePanelDraw(panel);
        }
    }
});
    // â”€â”€ TPO Header Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('toggle-tpo').addEventListener('click', function() {
        if (selectedPanelId === 0) {
            config.showTPO = !config.showTPO;
            this.classList.toggle('active', config.showTPO);
            const sw = document.getElementById('toggle-tpo-switch');
            if (sw) sw.classList.toggle('active', config.showTPO);
            tpoCacheKey = '';
            scheduleDraw();
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.showTPO = !panel.showTPO;
                this.classList.toggle('active', panel.showTPO);
                panel.tpoCacheKey = '';
                schedulePanelDraw(panel);
            }
        }
    });
  // â”€â”€ VWAP Header Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('toggle-vwap').addEventListener('click', function() {
        if (selectedPanelId === 0) {
            config.vwapVisible = !config.vwapVisible;
            this.classList.toggle('active', config.vwapVisible);
            scheduleDraw();
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.vwapVisible = !panel.vwapVisible;
                this.classList.toggle('active', panel.vwapVisible);
                schedulePanelDraw(panel);
            }
        }
    });

// â”€â”€ Line-dash helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getLineDash(style) {
    switch (style) {
        case 'solid':  return [];
        case 'dashed': return [8, 4];
        case 'dotted': return [2, 4];
        default:       return [4, 4];
    }
}

// â”€â”€ DOM helpers for building menu rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function _iRow(label, controlEl) {
    const row = document.createElement('div');
    row.style.cssText = 'display:flex;align-items:center;justify-content:space-between;gap:10px;min-height:26px;';
    const lbl = document.createElement('span');
    lbl.style.cssText = 'font-size:10px;color:#8b92a7;text-transform:uppercase;letter-spacing:0.04em;white-space:nowrap;flex-shrink:0;';
    lbl.textContent = label;
    row.appendChild(lbl);
    row.appendChild(controlEl);
    return row;
}

function _iDivider() {
    const d = document.createElement('div');
    d.style.cssText = 'height:1px;background:rgba(26,31,46,0.8);margin:1px 0;';
    return d;
}

function _iSectionLabel(text) {
    const s = document.createElement('div');
    s.style.cssText = 'font-size:9px;color:#5a6178;text-transform:uppercase;letter-spacing:0.06em;margin-top:2px;';
    s.textContent = text;
    return s;
}

function _iColor(value, onChange) {
    const wrap = document.createElement('div');
    wrap.style.cssText = 'width:54px;height:22px;border-radius:4px;overflow:hidden;border:1px solid #1a1f2e;cursor:pointer;flex-shrink:0;transition:border-color 0.2s;';
    wrap.onmouseover = () => wrap.style.borderColor = '#3b82f6';
    wrap.onmouseout  = () => wrap.style.borderColor = '#1a1f2e';
    const inp = document.createElement('input');
    inp.type = 'color';
    inp.value = value;
    inp.style.cssText = 'border:none;width:200%;height:200%;transform:translate(-25%,-25%);cursor:pointer;background:none;';
    inp.addEventListener('input', e => onChange(e.target.value));
    wrap.appendChild(inp);
    return wrap;
}

function _iSlider(value, min, max, step, format, onChange) {
    const wrap = document.createElement('div');
    wrap.style.cssText = 'display:flex;align-items:center;gap:6px;flex:1;min-width:0;';
    const inp = document.createElement('input');
    inp.type = 'range';
    inp.min = min; inp.max = max; inp.step = step; inp.value = value;
    inp.style.cssText = 'flex:1;min-width:0;';
    const val = document.createElement('span');
    val.style.cssText = 'font-size:10px;color:#3b82f6;min-width:36px;text-align:right;flex-shrink:0;';
    val.textContent = format(value);
    inp.addEventListener('input', e => { val.textContent = format(e.target.value); onChange(parseFloat(e.target.value)); });
    wrap.appendChild(inp);
    wrap.appendChild(val);
    return wrap;
}

function _iSelect(options, value, onChange) {
    const sel = document.createElement('select');
    sel.style.cssText = 'background:#0a0e1a;border:1px solid #1a1f2e;color:#e8eaed;font-family:"JetBrains Mono",monospace;font-size:10px;border-radius:4px;padding:3px 6px;cursor:pointer;flex-shrink:0;';
    options.forEach(o => {
        const opt = document.createElement('option');
        opt.value = o.v; opt.textContent = o.l;
        if (o.v === value) opt.selected = true;
        sel.appendChild(opt);
    });
    sel.addEventListener('change', e => onChange(e.target.value));
    return sel;
}

function _iToggle(checked, onChange) {
    const sw = document.createElement('div');
    sw.style.cssText = `width:36px;height:20px;background:${checked ? '#3b82f6' : '#1a1f2e'};
        border-radius:10px;cursor:pointer;position:relative;transition:background 0.2s;flex-shrink:0;`;
    const knob = document.createElement('div');
    knob.style.cssText = `position:absolute;top:2px;left:${checked ? '16' : '2'}px;
        width:16px;height:16px;background:white;border-radius:50%;transition:left 0.2s;
        box-shadow:0 1px 3px rgba(0,0,0,0.3);`;
    sw.appendChild(knob);
    let state = checked;
    sw.addEventListener('click', () => {
        state = !state;
        sw.style.background = state ? '#3b82f6' : '#1a1f2e';
        knob.style.left = state ? '16px' : '2px';
        onChange(state);
    });
    return sw;
}

// Keys that are stored per-panel and synced into config during draw
const IND_SETTING_KEYS = [
    'oiUpColor','oiDownColor','oiOpacity','oiBorderColor',
    'cvdLineColor','cvdLineThickness',
    'barStatsUpColor','barStatsDownColor',
    'tpoTickSize','tpoBlockWidth','tpoOpacityVA','tpoOpacityNonVA',
    'tpoColorSingle','tpoColorVA','tpoColorNonVA','tpoColorPOC',
    'vwapColor','vwapLineStyle','vwapShowLabel','vwapShowPrice',
    'levelsColor','levelsLineStyle',
];

// Snapshot of indicator settings from config (used when creating a new panel)
function makeDefaultIndSettings() {
    const s = {};
    IND_SETTING_KEYS.forEach(k => { s[k] = config[k]; });
    s.levelsEnabled = { ...config.levelsEnabled };
    return s;
}

// Returns the live settings object for the currently-selected panel
function getIC() {
    if (selectedPanelId === 0) return config;
    return extraPanels.find(p => p.id === selectedPanelId) || config;
}

// Invalidates the TPO cache for the currently-selected panel
function invalidateTpoCache() {
    if (selectedPanelId === 0) {
        tpoCacheKey = '';
    } else {
        const p = extraPanels.find(p => p.id === selectedPanelId);
        if (p) p.tpoCacheKey = '';
    }
}


// â”€â”€ Per-indicator menu builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function _menuOI(body) {
    const ic = getIC();
    body.appendChild(_iRow('Up Color',     _iColor(ic.oiUpColor,    v => { getIC().oiUpColor    = v; scheduleDraw(); })));
    body.appendChild(_iRow('Down Color',   _iColor(ic.oiDownColor,  v => { getIC().oiDownColor  = v; scheduleDraw(); })));
    body.appendChild(_iRow('Border Color', _iColor(ic.oiBorderColor,v => { getIC().oiBorderColor= v; scheduleDraw(); })));
    body.appendChild(_iRow('Opacity',
        _iSlider(Math.round(ic.oiOpacity * 100), 10, 100, 5, v => v + '%',
            v => { getIC().oiOpacity = v / 100; scheduleDraw(); })));
}

function _menuCVD(body) {
    const ic = getIC();
    body.appendChild(_iSectionLabel('Line Color'));
    const autoRow = _iRow('Auto (up/down)', _iToggle(ic.cvdLineColor === 'auto', on => {
        getIC().cvdLineColor = on ? 'auto' : '#3b82f6';
        colorWrap.style.opacity       = on ? '0.3' : '1';
        colorWrap.style.pointerEvents = on ? 'none' : 'auto';
        scheduleDraw();
    }));
    body.appendChild(autoRow);
    const colorWrap = document.createElement('div');
    const isAuto    = ic.cvdLineColor === 'auto';
    colorWrap.style.opacity       = isAuto ? '0.3' : '1';
    colorWrap.style.pointerEvents = isAuto ? 'none' : 'auto';
    const colorCtrl = _iColor(isAuto ? '#3b82f6' : ic.cvdLineColor,
        v => { if (getIC().cvdLineColor !== 'auto') { getIC().cvdLineColor = v; scheduleDraw(); } });
    colorWrap.appendChild(colorCtrl);
    body.appendChild(_iRow('Custom Color', colorWrap));
    body.appendChild(_iDivider());
    body.appendChild(_iRow('Thickness',
        _iSlider(ic.cvdLineThickness, 1, 5, 0.5, v => v + 'px',
            v => { getIC().cvdLineThickness = v; scheduleDraw(); })));
}

function _menuBarStats(body) {
    const ic = getIC();
    body.appendChild(_iRow('Positive Color', _iColor(ic.barStatsUpColor,   v => { getIC().barStatsUpColor   = v; scheduleDraw(); })));
    body.appendChild(_iRow('Negative Color', _iColor(ic.barStatsDownColor, v => { getIC().barStatsDownColor = v; scheduleDraw(); })));
}

function _menuTPO(body) {
    const ic = getIC();
    body.appendChild(_iRow('Tick Size ($)',
        _iSlider(ic.tpoTickSize, 10, 500, 10, v => '$' + v,
            v => { getIC().tpoTickSize = v; invalidateTpoCache(); scheduleDraw(); })));
    body.appendChild(_iRow('Block Width',
        _iSlider(ic.tpoBlockWidth, 3, 24, 1, v => v + 'px',
            v => { getIC().tpoBlockWidth = v; scheduleDraw(); })));
    body.appendChild(_iDivider());
    body.appendChild(_iSectionLabel('Opacity'));
    body.appendChild(_iRow('Value Area',
        _iSlider(Math.round(ic.tpoOpacityVA * 100), 10, 100, 5, v => v + '%',
            v => { getIC().tpoOpacityVA = v / 100; scheduleDraw(); })));
    body.appendChild(_iRow('Non-VA',
        _iSlider(Math.round(ic.tpoOpacityNonVA * 100), 5, 80, 5, v => v + '%',
            v => { getIC().tpoOpacityNonVA = v / 100; scheduleDraw(); })));
    body.appendChild(_iDivider());
    body.appendChild(_iSectionLabel('Colors'));
    body.appendChild(_iRow('Value Area',   _iColor(ic.tpoColorVA,     v => { getIC().tpoColorVA     = v; scheduleDraw(); })));
    body.appendChild(_iRow('Non-VA',       _iColor(ic.tpoColorNonVA,  v => { getIC().tpoColorNonVA  = v; scheduleDraw(); })));
    body.appendChild(_iRow('Single Print', _iColor(ic.tpoColorSingle, v => { getIC().tpoColorSingle = v; scheduleDraw(); })));
    body.appendChild(_iRow('POC Border',   _iColor(ic.tpoColorPOC,    v => { getIC().tpoColorPOC    = v; scheduleDraw(); })));
}

function _menuVWAP(body) {
    const ic = getIC();
    body.appendChild(_iRow('Color', _iColor(ic.vwapColor, v => { getIC().vwapColor = v; scheduleDraw(); })));
    body.appendChild(_iRow('Line Style',
        _iSelect(
            [{ v:'solid', l:'â”€â”€â”€â”€ Solid' }, { v:'dashed', l:'- - - Dashed' }, { v:'dotted', l:'Â·Â·Â· Dotted' }],
            ic.vwapLineStyle,
            v => { getIC().vwapLineStyle = v; scheduleDraw(); }
        )));
    body.appendChild(_iDivider());
    body.appendChild(_iSectionLabel('Labels'));
    body.appendChild(_iRow('Show "VWAP"', _iToggle(ic.vwapShowLabel, v => { getIC().vwapShowLabel = v; scheduleDraw(); })));
    body.appendChild(_iRow('Show Price',  _iToggle(ic.vwapShowPrice, v => { getIC().vwapShowPrice = v; scheduleDraw(); })));
}

function _menuLevels(body) {
    const ic = getIC();
    body.appendChild(_iRow('Color', _iColor(ic.levelsColor, v => { getIC().levelsColor = v; scheduleDraw(); })));
    body.appendChild(_iRow('Line Style',
        _iSelect(
            [{ v:'solid', l:'â”€â”€â”€â”€ Solid' }, { v:'dashed', l:'- - - Dashed' }, { v:'dotted', l:'Â·Â·Â· Dotted' }],
            ic.levelsLineStyle,
            v => { getIC().levelsLineStyle = v; scheduleDraw(); }
        )));
    body.appendChild(_iDivider());
    body.appendChild(_iSectionLabel('Visible Levels'));
    const LABELS = {
        dOpen:'Day Open', dHigh:'Day High', dLow:'Day Low', dEQ:'Day EQ',
        pdHigh:'Prev High', pdLow:'Prev Low', pdEQ:'Prev EQ'
    };
    Object.entries(LABELS).forEach(([key, label]) => {
        body.appendChild(_iRow(label, _iToggle(ic.levelsEnabled[key],
            v => { getIC().levelsEnabled[key] = v; scheduleDraw(); })));
    });
}

// â”€â”€ Show / hide â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _indCtxActive = null;

function showIndicatorCtxMenu(id, anchorEl) {
    const menu  = document.getElementById('indicator-ctx-menu');
    const title = document.getElementById('ind-ctx-title');
    const body  = document.getElementById('ind-ctx-body');

    const NAMES = { oi: 'Open Interest', cvd: 'Volume Delta', barstats: 'Bar Statistics',
                    tpo: 'TPO / Market Profile', vwap: 'VWAP', dailylevels: 'Key Levels' };
    title.textContent = NAMES[id] || id;
    body.innerHTML = '';

    switch (id) {
        case 'oi':         _menuOI(body);         break;
        case 'cvd':        _menuCVD(body);        break;
        case 'barstats':   _menuBarStats(body);   break;
        case 'tpo':        _menuTPO(body);        break;
        case 'vwap':       _menuVWAP(body);       break;
        case 'dailylevels': _menuLevels(body);    break;
    }

    _indCtxActive = id;
    menu.style.display = 'block';

    // Position below the button, clamped to viewport
    const rect = anchorEl.getBoundingClientRect();
    const mw   = menu.offsetWidth  || 252;
    const mh   = menu.offsetHeight || 300;
    let left = rect.left;
    let top  = rect.bottom + 6;
    if (left + mw > window.innerWidth  - 8) left = window.innerWidth  - mw - 8;
    if (top  + mh > window.innerHeight - 8) top  = rect.top - mh - 6;
    menu.style.left = left + 'px';
    menu.style.top  = top  + 'px';
}

function hideIndicatorCtxMenu() {
    document.getElementById('indicator-ctx-menu').style.display = 'none';
    _indCtxActive = null;
}

// â”€â”€ Attach right-click listeners to all six toggle buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// (Add these lines after the existing click-listener blocks for each button)
['oi', 'cvd', 'barstats', 'tpo', 'vwap', 'dailylevels'].forEach(id => {
    const btn = document.getElementById(`toggle-${id}`);
    if (!btn) return;
    btn.addEventListener('contextmenu', e => {
        e.preventDefault();
        e.stopPropagation();
        showIndicatorCtxMenu(id, btn);
    });
});

// Close on click outside the menu
document.addEventListener('mousedown', e => {
    const menu = document.getElementById('indicator-ctx-menu');
    if (menu && menu.style.display !== 'none' && !menu.contains(e.target)) {
        hideIndicatorCtxMenu();
    }
});

document.getElementById('ind-ctx-close').addEventListener('click', hideIndicatorCtxMenu);

    // Drawing helpers
    function hexToRgba(hex, alpha) {
        if (!hex || hex.length < 7) return `rgba(100,100,100,${alpha})`;
        const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    function calculateCellOpacity(totalVolume) {
        if (totalVolume < 50000) return 0.10;
        else if (totalVolume < 250000) { const t=(totalVolume-50000)/200000; return 0.40+t*0.20; }
        else if (totalVolume < 1000000) { const t=(totalVolume-250000)/750000; return 0.60+t*0.10; }
        else if (totalVolume < 1200000) { const t=(totalVolume-1000000)/200000; return 0.70+t*0.30; }
        else return 1.0;
    }

    function createSeries(type) {
        if (mainSeries) { try { chart.removeSeries(mainSeries); } catch(e){} mainSeries = null; }
        const options = { upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', borderVisible:false, wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)', priceLineVisible:config.showPriceLine, lastValueVisible:false, priceLineColor: config.upColor, priceLineWidth: 1, priceLineStyle: 2 };
        mainSeries = (type==='candle') ? chart.addCandlestickSeries(options) : chart.addBarSeries(options);
        return mainSeries;
    }

    function updateCandleAppearance() {
    const lastCandle = displayCandles[displayCandles.length - 1];
    const lineColor = (lastCandle && lastCandle.close >= lastCandle.open) ? config.upColor : config.downColor;
    mainSeries.applyOptions({ upColor:'rgba(0,0,0,0)', downColor:'rgba(0,0,0,0)', wickUpColor:'rgba(0,0,0,0)', wickDownColor:'rgba(0,0,0,0)', priceLineVisible:config.showPriceLine, lastValueVisible:false, priceLineColor: lineColor, priceLineWidth: 1, priceLineStyle: 2 });
}
    mainSeries = createSeries(config.seriesType);

    let chartOverlayCanvas = document.getElementById('footprint-overlay');
    let ctxOverlay = chartOverlayCanvas.getContext('2d');
    let offscreenCanvas = document.createElement('canvas');
    let offscreenCtx = offscreenCanvas.getContext('2d');

    function setupBuffersForSize() {
        const dpr = window.devicePixelRatio||1;
        const wrapper = document.getElementById('panel-wrapper-0');
        const chartW = wrapper.clientWidth, chartH = wrapper.clientHeight;
        chartOverlayCanvas.width = Math.floor(chartW*dpr); chartOverlayCanvas.height = Math.floor(chartH*dpr);
        chartOverlayCanvas.style.width = chartW+'px'; chartOverlayCanvas.style.height = chartH+'px';
        offscreenCanvas.width = chartOverlayCanvas.width; offscreenCanvas.height = chartOverlayCanvas.height;
        offscreenCtx.setTransform(dpr,0,0,dpr,0,0); ctxOverlay.setTransform(1,0,0,1,0,0);
    }

    function formatUSD(val) {
        if (val===0) return '0'; const abs=Math.abs(val);
        if (abs>=1000000) return (val/1000000).toFixed(1)+'M';
        if (abs>=1000) return (val/1000).toFixed(0)+'K';
        return Math.round(val).toString();
    }

    function upsertCandle(tsSec,o,h,l,c,v=0) {
        if (!base5mCandles) base5mCandles=[];
        const key=Math.floor(tsSec); let found=false;
        for (let i=base5mCandles.length-1; i>=0; i--) {
            if (Math.floor(base5mCandles[i].time)===key) {
                base5mCandles[i].open=o; base5mCandles[i].high=h; base5mCandles[i].low=l; base5mCandles[i].close=c; base5mCandles[i].volume=v; found=true; break;
            }
        }
        if (!found) {
            const prevOI = base5mCandles.length>0 ? (base5mCandles[base5mCandles.length-1].oiClose||0) : 0;
            base5mCandles.push({ time:key, open:o, high:h, low:l, close:c, volume:v, oiOpen:prevOI, oiHigh:prevOI, oiLow:prevOI, oiClose:prevOI });
            base5mCandles.sort((a,b)=>a.time-b.time);
        }
    }

    function getDynamicTickSize(baseTick, minPx) {
        const y1=mainSeries.priceToCoordinate(currentPrice), y2=mainSeries.priceToCoordinate(currentPrice+baseTick);
        if (y1===null||y2===null) return baseTick*2;
        const pxPerBase=Math.abs(y1-y2);
        const multipliers=[1,2,3,4,5,6,7,8,9,10,12,14,16,18,20,25,30,40,50,60,80,100,200];
        for (let m of multipliers) { if (pxPerBase*m>=minPx) return baseTick*m; }
        return baseTick*500;
    }

    function updateCustomPriceLabel() {
        if (!config.showPriceLabel||!mainSeries||!currentPrice||!activePriceLabelEl) { if(activePriceLabelEl) activePriceLabelEl.style.display='none'; return; }
        const yCoord=mainSeries.priceToCoordinate(currentPrice);
        if (yCoord===null) { document.getElementById('custom-price-label').style.display='none'; return; }
        const wrapper=document.getElementById('panel-wrapper-0');
        const marginB=chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY=wrapper.clientHeight*(1-marginB);
        if (yCoord<0||yCoord>candleBottomY) { document.getElementById('custom-price-label').style.display='none'; return; }
        const lastCandle=displayCandles[displayCandles.length-1];
        const isUp=lastCandle?(lastCandle.close>=lastCandle.open):true;
        const color=isUp?config.upColor:config.downColor;
        const labelContainer=activePriceLabelEl;
        labelContainer.style.display='flex'; labelContainer.style.top=(yCoord-13)+'px';
        labelContainer.style.fontFamily=config.statsFontFamily; labelContainer.style.fontSize=config.priceLabelFontSize+'px';
        const priceText=currentPrice.toLocaleString('en-US',{minimumFractionDigits:2,maximumFractionDigits:2});
        const nowSec = Math.floor(Date.now()/1000);
        const barSeconds = getBarSeconds(config.displayTimeframe);
        const diff = (lastBarTime + barSeconds) - nowSec;
        const timerStr = (diff > 0) ? formatTime(diff) : "0:00";
        const solidBg = hexToRgba(color, 0.85);
        labelContainer.innerHTML = `<div class="price-label-box" style="background:${solidBg};color:#ffffff;font-size:${config.priceLabelFontSize}px;align-items:center;">
            <span style="font-weight:700;letter-spacing:0.01em;line-height:1.2;">${priceText}</span>
            ${config.showCountdown ? `<span style="font-size:${config.timerFontSize}px;opacity:0.88;line-height:1.2;text-align:center;width:100%;">${timerStr}</span>` : ''}
        </div>`;
    }   // â† ADD THIS closing brace for updateCustomPriceLabel

    function drawCumulativeCluster(cssWidth, cssHeight, candleBottomY) {
        if (config.hideFootprints) return;
        const timeScale=chart.timeScale(); const barSpacing=timeScale.options().barSpacing;
        const visibleRange=timeScale.getVisibleLogicalRange(); if (!visibleRange) return;
        const renderTickSize=getDynamicTickSize(config.baseTickSize,config.minCellHeight);
        const clusterWidth=barSpacing*2*0.92;
        let rightmostX=0, rightmostTime=0;
        for (let i=displayCandles.length-1; i>=0; i--) {
            const candle=displayCandles[i]; const x=timeScale.timeToCoordinate(candle.time);
            if (x!==null&&x>=0&&x<=cssWidth&&candle.time>rightmostTime) { rightmostTime=candle.time; rightmostX=x; }
        }
        if (rightmostX===0&&displayCandles.length>0) { const x=timeScale.timeToCoordinate(displayCandles[displayCandles.length-1].time); if (x!==null) rightmostX=x; }
        let clusterX=rightmostX+150;
        if (clusterX+clusterWidth>cssWidth-75) clusterX=cssWidth-75-clusterWidth;
        if (clusterX<0) return;
        let aggregatedData={}, totalBuy=0, totalSell=0;
        Object.keys(displayClusters).forEach(timestamp => {
            const ts=parseInt(timestamp); const x=timeScale.timeToCoordinate(ts);
            if (config.cumulativeMode==='visible' && (x===null||x<-100||x>cssWidth+100)) return;
            const rawClusters=displayClusters[timestamp];
            Object.keys(rawClusters).forEach(priceKey => {
                const price=parseFloat(priceKey); const data=rawClusters[priceKey];
                const aggPrice=Math.floor(price/renderTickSize)*renderTickSize;
                if (!aggregatedData[aggPrice]) aggregatedData[aggPrice]={buy:0,sell:0};
                aggregatedData[aggPrice].buy+=data.buy; aggregatedData[aggPrice].sell+=data.sell;
                totalBuy+=data.buy; totalSell+=data.sell;
            });
        });
        if (Object.keys(aggregatedData).length===0) return;
        let pocBucketKey=null, pocTotal=-Infinity;
        Object.keys(aggregatedData).forEach(pk => { const t=aggregatedData[pk].buy+aggregatedData[pk].sell; if (t>pocTotal){pocTotal=t;pocBucketKey=pk;} });
        let minPrice=Infinity, maxPrice=-Infinity;
        Object.keys(aggregatedData).forEach(pk => { const p=parseFloat(pk); if(p<minPrice)minPrice=p; if(p>maxPrice)maxPrice=p; });
        const yTop=mainSeries.priceToCoordinate(maxPrice+renderTickSize), yBottom=mainSeries.priceToCoordinate(minPrice);
        if (yTop===null||yBottom===null) return;
        let clippedYTop, clippedYBottom, clusterBoxHeight, clusterBoxY;
        if (config.cumulativeMode==='all') {
            clippedYTop=yTop; clippedYBottom=yBottom;
            clusterBoxHeight=Math.abs(clippedYBottom-clippedYTop); clusterBoxY=Math.min(clippedYTop,clippedYBottom);
        } else {
            clippedYTop=Math.max(0,Math.min(yTop,candleBottomY)); clippedYBottom=Math.max(0,Math.min(yBottom,candleBottomY));
            if (clippedYTop>=candleBottomY) return;
            clusterBoxHeight=Math.abs(clippedYBottom-clippedYTop); clusterBoxY=Math.min(clippedYTop,clippedYBottom);
        }
        offscreenCtx.fillStyle=hexToRgba(config.panelColor,config.clusterBgOpacity);
        offscreenCtx.fillRect(clusterX,clusterBoxY,clusterWidth,clusterBoxHeight);
        offscreenCtx.strokeStyle='#1a1f2e'; offscreenCtx.lineWidth=config.cellBorderWidth;
        offscreenCtx.strokeRect(clusterX,clusterBoxY,clusterWidth,clusterBoxHeight);
        offscreenCtx.font=`${config.cellFontWeight} ${config.cellFontSize}px ${config.statsFontFamily}`;
        offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";
        Object.keys(aggregatedData).forEach(priceKey => {
            const priceFloor=parseFloat(priceKey); const data=aggregatedData[priceKey];
            let cellYTop=mainSeries.priceToCoordinate(priceFloor+renderTickSize);
            let cellYBottom=mainSeries.priceToCoordinate(priceFloor);
            if (cellYTop===null||cellYBottom===null) return;
            if (config.cumulativeMode==='visible') {
                cellYTop=Math.max(0,Math.min(cellYTop,candleBottomY)); cellYBottom=Math.max(0,Math.min(cellYBottom,candleBottomY));
                if (cellYTop>=candleBottomY) return;
            }
            const heightCell=Math.abs(cellYBottom-cellYTop); const drawY=Math.min(cellYTop,cellYBottom);
            const delta=data.buy-data.sell; const totalVolume=data.buy+data.sell;
            const isBullish=delta>=0;
            const cellColor=isBullish?config.upColor:config.downColor;
            const cellOpacity=calculateCellOpacity(totalVolume);
            offscreenCtx.fillStyle=hexToRgba(cellColor,cellOpacity);
            offscreenCtx.fillRect(clusterX,drawY,clusterWidth,heightCell);
            if (String(priceKey)===String(pocBucketKey)) {
                offscreenCtx.strokeStyle=config.pocColor; offscreenCtx.lineWidth=config.pocBorderWidth;
                offscreenCtx.strokeRect(clusterX,drawY,clusterWidth,heightCell);
            }
            if (heightCell>14) { offscreenCtx.fillStyle='#ffffff'; offscreenCtx.fillText(formatUSD(delta),clusterX+(clusterWidth/2),drawY+(heightCell/2)); }
        });
        const totalDelta=totalBuy-totalSell, statsY=clusterBoxY-25;
        const shouldShowStats=config.cumulativeMode==='all'||(statsY>0&&statsY<candleBottomY);
        if (shouldShowStats) {
            const deltaColor=totalDelta>=0?config.upColor:config.downColor;
            const centerX=clusterX+(clusterWidth/2);
            offscreenCtx.font=`${config.statsFontWeight} ${config.statsFontSize}px ${config.statsFontFamily}`; offscreenCtx.textAlign='center';
            offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText(`V:${formatUSD(totalBuy+totalSell)}`,centerX,statsY-8);
            const deltaValue=formatUSD(totalDelta);
            const dW=offscreenCtx.measureText('D:').width, dvW=offscreenCtx.measureText(deltaValue).width;
            offscreenCtx.textAlign='left';
            offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText('D:',centerX-(dW+dvW)/2,statsY+8);
            offscreenCtx.fillStyle=deltaColor; offscreenCtx.fillText(deltaValue,centerX-(dW+dvW)/2+dW,statsY+8);
            offscreenCtx.textAlign='center';
        }
    }

function syncHeaderButtons() {
    const isMain = selectedPanelId === 0;
    const panel  = isMain ? null : extraPanels.find(p => p.id === selectedPanelId);
    const mgr    = isMain ? indicatorManager : panel?.indicatorManager;

    // OI
    const oiActive = mgr?.getIndicator('oi')?.visible ?? false;
    document.getElementById('toggle-oi').classList.toggle('active', oiActive);

    // CVD
    const cvdActive = mgr?.getIndicator('cvd')?.visible ?? false;
    document.getElementById('toggle-cvd').classList.toggle('active', cvdActive);

    // Bar Stats
    const bsActive = mgr?.getIndicator('barstats')?.visible ?? false;
    document.getElementById('toggle-barstats').classList.toggle('active', bsActive);

    // TPO
    const tpoActive = isMain ? config.showTPO : (panel?.showTPO ?? false);
    document.getElementById('toggle-tpo').classList.toggle('active', tpoActive);
    const tpoSwitch = document.getElementById('toggle-tpo-switch');
    if (tpoSwitch) tpoSwitch.classList.toggle('active', tpoActive);

    // VWAP
    const vwapActive = isMain ? config.vwapVisible : (panel?.vwapVisible ?? false);
    document.getElementById('toggle-vwap').classList.toggle('active', vwapActive);

    // Key Levels
    const levelsActive = isMain ? config.showDailyLevels : (panel?.showDailyLevels ?? false);
    document.getElementById('toggle-dailylevels').classList.toggle('active', levelsActive);
}

function drawDailyLevels(cssWidth, candleBottomY) {
    if (!config.showDailyLevels || !displayCandles || displayCandles.length === 0) return;

    const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
    const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
    const timeScale = chart.timeScale();

    const now            = new Date();
    const todayStart     = Math.floor(new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate())).getTime() / 1000);
    const yesterdayStart = todayStart - 86400;

    let dOpen = null, dHigh = -Infinity, dLow = Infinity;
    let pdHigh = -Infinity, pdLow = Infinity;

    for (const c of displayCandles) {
        if (c.time >= todayStart) {
            if (dOpen === null) dOpen = c.open;
            if (c.high > dHigh) dHigh = c.high;
            if (c.low  < dLow)  dLow  = c.low;
        } else if (c.time >= yesterdayStart) {
            if (c.high > pdHigh) pdHigh = c.high;
            if (c.low  < pdLow)  pdLow  = c.low;
        }
    }

    const dEQ  = (dHigh  > -Infinity && dLow  < Infinity) ? (dHigh  + dLow)  / 2 : null;
    const pdEQ = (pdHigh > -Infinity && pdLow < Infinity) ? (pdHigh + pdLow) / 2 : null;

    const todayFirstCandle = displayCandles.find(c => c.time >= todayStart);
    const todayX = todayFirstCandle ? (timeScale.timeToCoordinate(todayFirstCandle.time) ?? 0) : 0;
    const pdFirstCandle = displayCandles.find(c => c.time >= yesterdayStart && c.time < todayStart);
    const pdX = pdFirstCandle ? (timeScale.timeToCoordinate(pdFirstCandle.time) ?? 0) : 0;

    const levels = [
        { value: dOpen,                               label: 'dOpen',  startX: todayX },
        { value: dHigh  > -Infinity ? dHigh  : null, label: 'dHigh',  startX: todayX },
        { value: dLow   < Infinity  ? dLow   : null, label: 'dLow',   startX: todayX },
        { value: dEQ,                                 label: 'dEQ',    startX: todayX },
        { value: pdHigh > -Infinity ? pdHigh : null,  label: 'pdHigh', startX: pdX    },
        { value: pdLow  < Infinity  ? pdLow  : null,  label: 'pdLow',  startX: pdX    },
        { value: pdEQ,                                label: 'pdEQ',   startX: pdX    },
    ];

    const lineColor  = hexToRgba(config.levelsColor, 0.75);
    const labelColor = hexToRgba(config.levelsColor, 0.92);
    const GAP        = 6;

    offscreenCtx.save();
    offscreenCtx.font         = "600 9px 'JetBrains Mono', monospace";
    offscreenCtx.textBaseline = 'middle';
    offscreenCtx.lineWidth    = 1;
    offscreenCtx.strokeStyle  = lineColor;
    offscreenCtx.fillStyle    = labelColor;

    const dash = getLineDash(config.levelsLineStyle);

    levels.forEach(({ value, label, startX }) => {
        // Respect per-level visibility toggle
        if (!config.levelsEnabled[label]) return;
        if (value === null || value === undefined) return;

        const y = mainSeries.priceToCoordinate(value);
        if (y === null || y < 0 || y > candleBottomY) return;

        const lineStart = Math.max(0, startX);
        if (lineStart >= drawWidth) return;

        const labelWidth = offscreenCtx.measureText(label).width;
        const labelX     = drawWidth - labelWidth - 12;
        if (labelX <= lineStart + 20) return;

        const labelLeft  = labelX - GAP;
        const labelRight = labelX + labelWidth + GAP;

        offscreenCtx.setLineDash(dash);

        // Left segment  â”€â”€ â”€â”€ â”€â”€ â”€â”€
        offscreenCtx.beginPath();
        offscreenCtx.moveTo(lineStart, y);
        offscreenCtx.lineTo(labelLeft, y);
        offscreenCtx.stroke();

        // Right segment  â”€â”€ â”€â”€ â”€â”€ â”€â”€
        offscreenCtx.beginPath();
        offscreenCtx.moveTo(labelRight, y);
        offscreenCtx.lineTo(drawWidth,  y);
        offscreenCtx.stroke();

        // Label centred on the line  â”€â”€ dEQ â”€â”€
        offscreenCtx.setLineDash([]);
        offscreenCtx.fillText(label, labelX, y);
    });

    offscreenCtx.restore();
}
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Main Draw Loop
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function drawFrames() {
        if (clustersDirty) {
            displayClusters = aggregateClusters(base5mClusters, config.displayTimeframe);
            extraPanels.forEach(p => {
                p.displayClusters = aggregateClusters(base5mClusters, p.displayTimeframe);
            });
            clustersDirty = false;
        }
        if (!offscreenCtx) return;
        const cssWidth = chartOverlayCanvas.clientWidth, cssHeight = chartOverlayCanvas.clientHeight;
        const PRICE_SCALE_WIDTH = measuredPriceScaleWidth;
        const drawWidth = cssWidth - PRICE_SCALE_WIDTH;
        offscreenCtx.clearRect(0,0,cssWidth,cssHeight);
        offscreenCtx.save();
        offscreenCtx.beginPath();
        offscreenCtx.rect(0, 0, drawWidth, cssHeight);
        offscreenCtx.clip();
        const timeScale=chart.timeScale(), barSpacing=timeScale.options().barSpacing;
        const visibleRange=timeScale.getVisibleLogicalRange();
        if (!visibleRange) { ctxOverlay.clearRect(0,0,cssWidth,cssHeight); ctxOverlay.drawImage(offscreenCanvas,0,0); return; }

        const renderTickSize=getDynamicTickSize(config.baseTickSize,config.minCellHeight);
        document.getElementById('tick-display').innerText=`${renderTickSize}`;
        const marginB=chart.priceScale('right').options().scaleMargins.bottom;
        const candleBottomY=cssHeight*(1-marginB);
        const totalWidth=barSpacing*0.92, candleWidth=totalWidth*config.candleWidthPercent, clusterWidth=totalWidth*config.clusterWidthPercent;
        const timestamps=Object.keys(displayClusters);

        // â”€â”€ Grid lines â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        offscreenCtx.lineWidth=config.gridLineWidth; offscreenCtx.strokeStyle=hexToRgba(config.gridColor,config.gridOpacity);
        offscreenCtx.beginPath();
        const approxRange=60000;
        const startPrice=Math.floor(currentPrice/config.gridSpacing)*config.gridSpacing-approxRange;
        const endPrice=Math.floor(currentPrice/config.gridSpacing)*config.gridSpacing+approxRange;
        for (let p=startPrice; p<=endPrice; p+=config.gridSpacing) {
            const y=mainSeries.priceToCoordinate?mainSeries.priceToCoordinate(p):null;
            if (y!==null&&y>=0&&y<=candleBottomY) { offscreenCtx.moveTo(0,y); offscreenCtx.lineTo(cssWidth-60,y); }
        }
        offscreenCtx.stroke();

        // â”€â”€ TPO profiles drawn FIRST (behind candles) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        drawTPO(cssWidth, candleBottomY);

        // â”€â”€ VWAP (before candles so it's behind them) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        drawVWAP(cssWidth, candleBottomY);

        // â”€â”€ key levels (before candles so it's behind them) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        drawDailyLevels(cssWidth, candleBottomY);  // â† add this line

        // â”€â”€ Candles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        displayCandles.forEach(candle => {
            const x=timeScale.timeToCoordinate(candle.time);
            if (x===null||x<-100||x>cssWidth+100) return;
            const openY=mainSeries.priceToCoordinate(candle.open), closeY=mainSeries.priceToCoordinate(candle.close);
            const highY=mainSeries.priceToCoordinate(candle.high), lowY=mainSeries.priceToCoordinate(candle.low);
            if (openY===null||closeY===null||highY===null||lowY===null) return;
            const clippedHighY=Math.max(0,highY), clippedLowY=Math.min(candleBottomY,lowY);
            const clippedOpenY=Math.min(candleBottomY,Math.max(0,openY)), clippedCloseY=Math.min(candleBottomY,Math.max(0,closeY));
            if (clippedHighY>candleBottomY) return;
            const isUp=candle.close>=candle.open, color=isUp?config.upColor:config.downColor;
            const colorWithOpacity=hexToRgba(color,config.candleOpacity);
            const startX=x-(totalWidth/2), candleX=startX;
            offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=config.wickThickness;
            offscreenCtx.beginPath(); offscreenCtx.moveTo(candleX+candleWidth/2,clippedHighY); offscreenCtx.lineTo(candleX+candleWidth/2,clippedLowY); offscreenCtx.stroke();
            const bodyTop=Math.min(clippedOpenY,clippedCloseY), bodyHeight=Math.max(1,Math.abs(clippedCloseY-clippedOpenY));
            if (config.seriesType==='candle') {
                offscreenCtx.fillStyle=colorWithOpacity; offscreenCtx.fillRect(candleX,bodyTop,candleWidth,bodyHeight);
                if (config.borderThickness>0) { offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=config.borderThickness; offscreenCtx.strokeRect(candleX,bodyTop,candleWidth,bodyHeight); }
            } else {
                offscreenCtx.strokeStyle=colorWithOpacity; offscreenCtx.lineWidth=2;
                offscreenCtx.beginPath(); offscreenCtx.moveTo(candleX,clippedOpenY); offscreenCtx.lineTo(candleX+candleWidth/2,clippedOpenY);
                offscreenCtx.moveTo(candleX+candleWidth/2,clippedCloseY); offscreenCtx.lineTo(candleX+candleWidth,clippedCloseY); offscreenCtx.stroke();
            }
        });

// â”€â”€ Per-candle footprint clusters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (!config.hideFootprints) {
            for (let ti=0; ti<timestamps.length; ti++) {
                const timestamp=timestamps[ti], ts=parseInt(timestamp);
                const x=timeScale.timeToCoordinate(ts);
                if (x===null||x<-100||x>cssWidth+100) continue;
                const rawClusters=displayClusters[timestamp];
                if (!rawClusters||Object.keys(rawClusters).length===0) continue;

                let aggregatedData={};
                Object.keys(rawClusters).forEach(priceKey => {
                    const price=parseFloat(priceKey), data=rawClusters[priceKey];
                    const aggPrice=Math.floor(price/renderTickSize)*renderTickSize;
                    if (!aggregatedData[aggPrice]) aggregatedData[aggPrice]={buy:0,sell:0};
                    aggregatedData[aggPrice].buy+=data.buy; aggregatedData[aggPrice].sell+=data.sell;
                });

                let pocBucketKey=null, pocTotal=-Infinity;
                const aggKeys=Object.keys(aggregatedData);
                aggKeys.forEach(pk => { const t=aggregatedData[pk].buy+aggregatedData[pk].sell; if(t>pocTotal){pocTotal=t;pocBucketKey=pk;} });

                let minPrice=Infinity, maxPrice=-Infinity;
                aggKeys.forEach(pk => { const p=parseFloat(pk); if(p<minPrice)minPrice=p; if(p>maxPrice)maxPrice=p; });

                const yTop=mainSeries.priceToCoordinate(maxPrice+renderTickSize), yBottom=mainSeries.priceToCoordinate(minPrice);
                if (yTop===null||yBottom===null) continue;
                const clippedYTop=Math.max(0,Math.min(yTop,candleBottomY)), clippedYBottom=Math.max(0,Math.min(yBottom,candleBottomY));
                if (clippedYTop>=candleBottomY) continue;

                const clusterBoxH=Math.abs(clippedYBottom-clippedYTop), clusterBoxY2=Math.min(clippedYTop,clippedYBottom);
                const startX=x-(totalWidth/2), boxX=startX+candleWidth, boxWidth=clusterWidth;

                offscreenCtx.fillStyle=hexToRgba(config.panelColor,config.clusterBgOpacity);
                offscreenCtx.fillRect(boxX,clusterBoxY2,boxWidth,clusterBoxH);
                offscreenCtx.strokeStyle='#1a1f2e'; offscreenCtx.lineWidth=config.cellBorderWidth;
                offscreenCtx.strokeRect(boxX,clusterBoxY2,boxWidth,clusterBoxH);
                offscreenCtx.font=`${config.cellFontWeight} ${config.cellFontSize}px ${config.statsFontFamily}`;
                offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";

                for (let pkIdx=0; pkIdx<aggKeys.length; pkIdx++) {
                    const priceKey=aggKeys[pkIdx], priceFloor=parseFloat(priceKey), data=aggregatedData[priceKey];
                    let cellYTop=mainSeries.priceToCoordinate(priceFloor+renderTickSize);
                    let cellYBottom=mainSeries.priceToCoordinate(priceFloor);
                    if (cellYTop===null||cellYBottom===null) continue;
                    cellYTop=Math.max(0,Math.min(cellYTop,candleBottomY)); cellYBottom=Math.max(0,Math.min(cellYBottom,candleBottomY));
                    if (cellYTop>=candleBottomY) continue;

                    const heightCell=Math.abs(cellYBottom-cellYTop), drawY=Math.min(cellYTop,cellYBottom);
                    const delta=data.buy-data.sell, totalVolume=data.buy+data.sell;

                    if (config.clusterVolumeThreshold > 0 && Math.abs(delta) < config.clusterVolumeThreshold) {
                        offscreenCtx.fillStyle = '#485060';
                    } else {
                        const isBullish = delta >= 0;
                        const cellColor = isBullish ? config.upColor : config.downColor;
                        const cellOpacity = calculateCellOpacity(totalVolume);
                        offscreenCtx.fillStyle = hexToRgba(cellColor, cellOpacity);
                    }
                    offscreenCtx.fillRect(boxX,drawY,boxWidth,heightCell);

                    if (String(priceKey)===String(pocBucketKey)) {
                        offscreenCtx.strokeStyle=config.pocColor; offscreenCtx.lineWidth=config.pocBorderWidth;
                        offscreenCtx.strokeRect(boxX,drawY,boxWidth,heightCell);
                    }

                    if (heightCell>14) {
                        offscreenCtx.fillStyle='#ffffff';
                        offscreenCtx.fillText(formatUSD(delta),boxX+(boxWidth/2),drawY+(heightCell/2));
                    }
                }
            }
        }

        drawCumulativeCluster(cssWidth,cssHeight,candleBottomY);

        // â”€â”€ Bubble indicators â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   if (!config.hideFootprints && displayCandles&&config.minBubbleVolume>0) {
            const currentTime=Date.now();
            const pulsePhase=(currentTime%config.bubblePulseSpeed)/config.bubblePulseSpeed;
            const pulseOpacity=0.3+(Math.sin(pulsePhase*Math.PI*2)*0.3);
            displayCandles.forEach(candle => {
                const x=timeScale.timeToCoordinate(candle.time);
                if (x===null||x<-20||x>cssWidth+20) return;
                const tsKey=String(Math.floor(candle.time)), buckets=displayClusters[tsKey];
                if (!buckets) return;
                let totalBuy=0, totalSell=0;
                Object.values(buckets).forEach(d=>{totalBuy+=d.buy;totalSell+=d.sell;});
                const delta=totalBuy-totalSell;
                if (Math.abs(delta)>=config.minBubbleVolume) {
                    const isBullishCandle=candle.close>=candle.open, isDeltaPositive=delta>=0;
                    const statsY=isBullishCandle?mainSeries.priceToCoordinate(candle.high)-45:mainSeries.priceToCoordinate(candle.low)+40;
                    if (statsY<0||statsY>candleBottomY) return;
                    const dotY=isBullishCandle?statsY-30:statsY+30;
                    const barCenterX=(x-(totalWidth/2))+(totalWidth/2);
                    const dotColor=isDeltaPositive?config.upColor:config.downColor;
                    offscreenCtx.save(); offscreenCtx.globalAlpha=pulseOpacity;
                    offscreenCtx.beginPath(); offscreenCtx.arc(barCenterX,dotY,config.bubbleOuterSize,0,Math.PI*2);
                    offscreenCtx.fillStyle=dotColor; offscreenCtx.fill(); offscreenCtx.restore();
                    offscreenCtx.save(); offscreenCtx.beginPath(); offscreenCtx.arc(barCenterX,dotY,config.bubbleInnerSize,0,Math.PI*2);
                    offscreenCtx.fillStyle=dotColor; offscreenCtx.fill(); offscreenCtx.restore();
                }
            });
        }

        // â”€â”€ Per-candle stats + absorption dots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if (!config.hideFootprints && displayCandles) {
            offscreenCtx.textAlign="center"; offscreenCtx.textBaseline="middle";
            displayCandles.forEach(candle => {
                const x=timeScale.timeToCoordinate(candle.time);
                if (x===null||x<-50||x>cssWidth+50) return;
                const tsKey=String(Math.floor(candle.time)), buckets=displayClusters[tsKey];
                if (!buckets) return;
                let totalBuy=0, totalSell=0;
                Object.values(buckets).forEach(d=>{totalBuy+=d.buy;totalSell+=d.sell;});
                const totalVol=totalBuy+totalSell, delta=totalBuy-totalSell;
                if (totalVol===0) return;
                const isBullishCandle=candle.close>=candle.open;
                const oiOpen=candle.oiOpen||0, oiClose=candle.oiClose||0, oiIncreasing=oiClose>oiOpen;
                let vwapNum=0, vwapDen=0;
                Object.keys(buckets).forEach(priceKey => {
                    const price=parseFloat(priceKey), vol=buckets[priceKey].buy+buckets[priceKey].sell;
                    vwapNum+=price*vol; vwapDen+=vol;
                });
                const candleVWAP=vwapDen>0?vwapNum/vwapDen:candle.open;
                const isBullishAbsorption=delta<=-config.absorptionThreshold&&candle.close>candleVWAP&&oiIncreasing;
                const isBearishAbsorption=delta>=config.absorptionThreshold&&candle.close<candleVWAP&&oiIncreasing;
                if (isBullishAbsorption||isBearishAbsorption) {
                    const dotY=isBullishAbsorption?mainSeries.priceToCoordinate(candle.low)+25:mainSeries.priceToCoordinate(candle.high)-25;
                    if (dotY>0&&dotY<candleBottomY) {
                        offscreenCtx.save(); offscreenCtx.shadowColor=config.absorptionColor; offscreenCtx.shadowBlur=config.absorptionGlow; offscreenCtx.fillStyle=config.absorptionColor;
                        offscreenCtx.beginPath(); offscreenCtx.arc(x,dotY,config.absorptionDotSize,0,Math.PI*2); offscreenCtx.fill();
                        offscreenCtx.shadowBlur=0; offscreenCtx.strokeStyle="#FFFFFF"; offscreenCtx.lineWidth=1; offscreenCtx.stroke(); offscreenCtx.restore();
                    }
                }

                const _barStatsActive = indicatorManager.getIndicator('barstats')?.visible;
                if (!_barStatsActive && !config.hideFootprints) {
                    const statsY=isBullishCandle?mainSeries.priceToCoordinate(candle.high)-45:mainSeries.priceToCoordinate(candle.low)+40;
                    if (statsY>=0&&statsY<=candleBottomY) {
                        const deltaColor=delta>=0?config.upColor:config.downColor;
                        const barCenterX=(x-(totalWidth/2))+(totalWidth/2);
                        offscreenCtx.font=`${config.statsFontWeight} ${config.statsFontSize}px ${config.statsFontFamily}`;
                        offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.textAlign='center';
                        offscreenCtx.fillText(`V:${formatUSD(totalVol)}`,barCenterX,statsY-8);
                        const deltaValue=formatUSD(delta), dW=offscreenCtx.measureText('D:').width, dvW=offscreenCtx.measureText(deltaValue).width;
                        offscreenCtx.textAlign='left';
                        offscreenCtx.fillStyle='#a6afd3'; offscreenCtx.fillText('D:',barCenterX-(dW+dvW)/2,statsY+8);
                        offscreenCtx.fillStyle=deltaColor; offscreenCtx.fillText(deltaValue,barCenterX-(dW+dvW)/2+dW,statsY+8);
                        offscreenCtx.textAlign='center';
                    }
                }
            });
        }
        offscreenCtx.restore(); // â† add this line
        indicatorManager.drawAll(cssWidth);

// â”€â”€ Countdown timer (now embedded in price label) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const timerBox = activeTimerBox;
        if (timerBox && !timerBox.classList.contains('hidden')) {
            timerBox.classList.add('hidden');
            timerBox.style.display = 'none';
        }

        updateCustomPriceLabel();
        updatePaneRight();

        // Blit offscreen buffer to visible overlay
        ctxOverlay.clearRect(0, 0, chartOverlayCanvas.width, chartOverlayCanvas.height);
        ctxOverlay.drawImage(offscreenCanvas, 0, 0);
    }
    function formatTime(seconds) {
        if (seconds>=3600) { const h=Math.floor(seconds/3600), m=Math.floor((seconds%3600)/60); return `${h}:${m.toString().padStart(2,'0')}`; }
        const m=Math.floor(seconds/60), s=seconds%60; return `${m}:${s.toString().padStart(2,'0')}`;
    }
    function getIntervalString(tf) { return {1:'1',3:'3',5:'5',15:'15',30:'30',60:'60',240:'240','D':'D'}[tf]||'5'; }
    function getOIIntervalString(tf) { return {1:'5min',3:'5min',5:'5min',15:'15min',30:'30min',60:'1h',240:'4h','D':'1d'}[tf]||'5min'; }
    function getBarSeconds(tfMinutes) { if (tfMinutes==='D') return 86400; return tfMinutes*60; }
    function getWSInterval(tf) { return {1:'1',3:'3',5:'5',15:'15',30:'30',60:'60',240:'240','D':'D'}[tf]||'5'; }

    async function changeTimeframe(newTF) {
        if (newTF < BASE_TIMEFRAME) { alert(`Footprint information will not migrate to timeframes lower than ${BASE_TIMEFRAME}m`); return; }
        applyTimeframeChange(newTF);
    }

    document.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.addEventListener('click', () => { const tf=btn.getAttribute('data-tf'); changeTimeframe(tf==='D'?1440:parseInt(tf)); });
    });

    const ctxMenuMain=document.getElementById('ctx-menu-main'), settingsPanel=document.getElementById('settings-panel');

    document.getElementById('panel-wrapper-0').addEventListener('contextmenu', (e) => {
        e.preventDefault();
        ctxMenuMain.style.left=`${Math.min(e.clientX,window.innerWidth-200)}px`;
        ctxMenuMain.style.top=`${Math.min(e.clientY,window.innerHeight-100)}px`;
        ctxMenuMain.classList.remove('hidden');
        // Sync dot to current panel state
        const active = selectedPanelId === 0
            ? config.hideFootprints
            : (extraPanels.find(p => p.id === selectedPanelId)?.hideFootprints ?? false);
        document.getElementById('ctx-hide-footprints-indicator').textContent = active ? 'â—' : 'â—‹';
        document.getElementById('ctx-hide-footprints-indicator').style.color = active ? '#3b82f6' : '';
    });
    document.addEventListener('click', (e) => { if (!e.target.closest('.context-menu')&&!e.target.closest('#settings-panel')&&!e.target.closest('#header-settings-btn')) ctxMenuMain.classList.add('hidden'); });
    document.getElementById('ctx-reset').onclick = () => {
        if (selectedPanelId === 0) {
            chart.timeScale().scrollToRealTime();
            chart.priceScale('right').applyOptions({ autoScale: true });
        } else {
            const panel = extraPanels.find(p => p.id === selectedPanelId);
            if (panel) {
                panel.chart.timeScale().scrollToRealTime();
                panel.chart.priceScale('right').applyOptions({ autoScale: true });
            }
        }
        ctxMenuMain.classList.add('hidden');
    };
    const toggleSettings=()=>{ settingsPanel.classList.toggle('-translate-x-full'); settingsPanel.classList.toggle('translate-x-0'); };
    document.getElementById('header-settings-btn').onclick = toggleSettings;
    document.getElementById('close-settings').onclick = toggleSettings;
    document.getElementById('ctx-settings-trigger').onclick = toggleSettings;

    document.getElementById('ctx-hide-footprints').onclick = () => {
    if (selectedPanelId === 0) {
        config.hideFootprints = !config.hideFootprints;
    } else {
        const panel = extraPanels.find(p => p.id === selectedPanelId);
        if (panel) panel.hideFootprints = !panel.hideFootprints;
    }
    // Update indicator dot
    const active = selectedPanelId === 0
        ? config.hideFootprints
        : (extraPanels.find(p => p.id === selectedPanelId)?.hideFootprints ?? false);
    document.getElementById('ctx-hide-footprints-indicator').textContent = active ? 'â—' : 'â—‹';
    document.getElementById('ctx-hide-footprints-indicator').style.color = active ? '#3b82f6' : '';
    ctxMenuMain.classList.add('hidden');
    scheduleDraw();
};
    document.getElementById('cumulative-mode-select').onchange = (e) => { config.cumulativeMode=e.target.value; scheduleDraw(); };
    document.getElementById('series-type-select').onchange = (e) => { config.seriesType=e.target.value; mainSeries=createSeries(config.seriesType); mainSeries.setData(displayCandles); updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('up-candle-color').onchange = (e) => { config.upColor=e.target.value; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('down-candle-color').onchange = (e) => { config.downColor=e.target.value; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('candle-opacity').oninput = (e) => { config.candleOpacity=e.target.value/100; document.getElementById('opacity-val').innerText=e.target.value+'%'; updateCandleAppearance(); scheduleDraw(); };
    document.getElementById('grid-spacing-input').onchange = (e) => { config.gridSpacing=parseFloat(e.target.value); scheduleDraw(); };
    document.getElementById('grid-color-input').oninput = (e) => { config.gridColor=e.target.value; scheduleDraw(); };
    document.getElementById('bubble-threshold-input').onchange = (e) => { config.minBubbleVolume=parseFloat(e.target.value); scheduleDraw(); };

    function resizeAll() {
        setupBuffersForSize();
        indicatorManager.updateLayout();
        extraPanels.forEach(p => { setupPanelBuffers(p); schedulePanelDraw(p); });
    }
    window.addEventListener('resize', resizeAll);
    chart.timeScale().subscribeVisibleLogicalRangeChange(() => { if (typeof scheduleDraw === 'function') scheduleDraw(); });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    //  Layout Manager
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function captureCurrentLayout() {
    const panels = [];
    const container = document.getElementById('charts-container');
    const totalContainerWidth = container.clientWidth;

    // Main panel (id 0)
    const mainWrapper = document.getElementById('panel-wrapper-0');
    const mainIndicators = [];
    indicatorManager.indicators.forEach((ind, id) => { if (ind.visible) mainIndicators.push(id); });
    panels.push({
        id: 0,
        timeframe: config.displayTimeframe,
        indicators: mainIndicators,
        hideFootprints: config.hideFootprints,
        showTPO: config.showTPO,
        vwapVisible: config.vwapVisible,
        showDailyLevels: config.showDailyLevels,
        visibleRange: chart.timeScale().getVisibleRange(),
        barSpacing: chart.timeScale().options().barSpacing,
        // NEW: save width as a ratio of the total container width
        widthRatio: totalContainerWidth > 0 ? mainWrapper.clientWidth / totalContainerWidth : 1,
    });

    // Extra panels
    extraPanels.forEach(p => {
        const panelIndicators = [];
        p.indicatorManager.indicators.forEach((ind, id) => { if (ind.visible) panelIndicators.push(id); });
        panels.push({
            id: p.id,
            timeframe: p.displayTimeframe,
            indicators: panelIndicators,
            hideFootprints: p.hideFootprints,
            showTPO: p.showTPO,
            vwapVisible: p.vwapVisible,
            showDailyLevels: p.showDailyLevels,
            visibleRange: p.chart.timeScale().getVisibleRange(),
            barSpacing: p.chart.timeScale().options().barSpacing,
            // NEW: save width as a ratio of the total container width
            widthRatio: totalContainerWidth > 0 ? p.wrapperEl.clientWidth / totalContainerWidth : 1,
        });
    });

    return {
        name: `Layout ${Date.now()}`,
        timestamp: Date.now(),
        panels,
    };
}

    function saveLayout() {
        const name = prompt('Name this layout:', `Layout ${new Date().toLocaleTimeString('ro-RO', { hour: '2-digit', minute: '2-digit' })}`);
        if (!name || name.trim() === '') return;

        const layout = captureCurrentLayout();
        layout.name = name.trim();

        let layouts = getSavedLayouts();
        layouts.push(layout);
        // Keep max 10 layouts
        if (layouts.length > 10) layouts = layouts.slice(-10);
        localStorage.setItem('btcChartLayouts', JSON.stringify(layouts));
        renderSavedLayouts();
    }

    function getSavedLayouts() {
        try {
            const raw = localStorage.getItem('btcChartLayouts');
            return raw ? JSON.parse(raw) : [];
        } catch(e) { return []; }
    }

    function deleteLayout(timestamp) {
        let layouts = getSavedLayouts().filter(l => l.timestamp !== timestamp);
        localStorage.setItem('btcChartLayouts', JSON.stringify(layouts));
        renderSavedLayouts();
    }

function applyLayout(layout) {
    // 1. Remove all extra panels
    [...extraPanels].forEach(p => removeExtraPanel(p.id));

    // 2. Apply main panel settings
    const mainLayout = layout.panels.find(p => p.id === 0);
    if (mainLayout) {
        applyTimeframeChange(mainLayout.timeframe);

        ['oi', 'cvd', 'barstats'].forEach(id => {
            const ind = indicatorManager.getIndicator(id);
            if (ind && ind.visible) indicatorManager.removeIndicator(id);
        });
        mainLayout.indicators.forEach(id => {
            if      (id === 'oi')       indicatorManager.addIndicator(new OIIndicator());
            else if (id === 'cvd')      indicatorManager.addIndicator(new CVDIndicator());
            else if (id === 'barstats') indicatorManager.addIndicator(new BarStatsIndicator());
        });

        config.hideFootprints  = mainLayout.hideFootprints;
        config.showTPO         = mainLayout.showTPO;
        config.vwapVisible     = mainLayout.vwapVisible;
        config.showDailyLevels = mainLayout.showDailyLevels;
        tpoCacheKey = '';
    }

    // 3. Recreate extra panels
    const extraLayouts = layout.panels.filter(p => p.id !== 0);
    extraLayouts.forEach(savedPanel => {
        const newPanel = createExtraPanel();

        newPanel.displayTimeframe = savedPanel.timeframe;
        newPanel.displayCandles   = aggregateCandles(base5mCandles, savedPanel.timeframe);
        newPanel.displayClusters  = aggregateClusters(base5mClusters, savedPanel.timeframe);
        newPanel.mainSeries.setData(newPanel.displayCandles);

        savedPanel.indicators.forEach(id => {
            if      (id === 'oi')       newPanel.indicatorManager.addIndicator(new OIIndicator());
            else if (id === 'cvd')      newPanel.indicatorManager.addIndicator(new CVDIndicator());
            else if (id === 'barstats') newPanel.indicatorManager.addIndicator(new BarStatsIndicator());
        });

        newPanel.hideFootprints  = savedPanel.hideFootprints;
        newPanel.showTPO         = savedPanel.showTPO;
        newPanel.vwapVisible     = savedPanel.vwapVisible;
        newPanel.showDailyLevels = savedPanel.showDailyLevels;
        newPanel.tpoCacheKey     = '';

        // Sync the mini TF bar to the saved timeframe
        syncPanelTFBar(newPanel, savedPanel.timeframe);
        schedulePanelDraw(newPanel);
    });

    // 4. Sync header buttons to main panel state
    selectedPanelId = 0;
    syncHeaderButtons();

    // 5. Apply saved widths, then after layout settles restore zoom/scroll
    setTimeout(() => {
        const container = document.getElementById('charts-container');
        const totalW    = container.clientWidth;
        const wrapper0  = document.getElementById('panel-wrapper-0');

        if (extraPanels.length > 0) {
            const mainPanelSaved = layout.panels.find(p => p.id === 0);
            wrapper0.style.flex = mainPanelSaved?.widthRatio
                ? `0 0 ${Math.round(mainPanelSaved.widthRatio * totalW)}px`
                : '1';

            extraLayouts.forEach((savedPanel, i) => {
                const newPanel = extraPanels[i];
                if (!newPanel) return;
                newPanel.wrapperEl.style.flex = savedPanel.widthRatio
                    ? `0 0 ${Math.round(savedPanel.widthRatio * totalW)}px`
                    : '1';
            });
        } else {
            wrapper0.style.flex = '1';
        }

        resizeAll();
        scheduleDraw();

        // Restore zoom + scroll AFTER resize settles
        setTimeout(() => {
            if (mainLayout?.barSpacing) {
                chart.timeScale().applyOptions({ barSpacing: mainLayout.barSpacing });
            }
            if (mainLayout?.visibleRange) {
                try { chart.timeScale().setVisibleRange(mainLayout.visibleRange); } catch (e) {}
            }

            extraLayouts.forEach((savedPanel, i) => {
                const newPanel = extraPanels[i];
                if (!newPanel) return;
                if (savedPanel.barSpacing) {
                    newPanel.chart.timeScale().applyOptions({ barSpacing: savedPanel.barSpacing });
                }
                if (savedPanel.visibleRange) {
                    try { newPanel.chart.timeScale().setVisibleRange(savedPanel.visibleRange); } catch (e) {}
                }
                schedulePanelDraw(newPanel);
            });

            scheduleDraw();
        }, 250);
    }, 150);

    closeLayoutsDropdown();
}

    function renderSavedLayouts() {
        const container = document.getElementById('saved-layouts-list');
        const layouts = getSavedLayouts();
        if (layouts.length === 0) {
            container.innerHTML = '<div class="px-4 py-2 text-[10px] text-gray-600 font-mono italic">No saved layouts yet</div>';
            return;
        }
        container.innerHTML = '';
        // Show newest first
        [...layouts].reverse().forEach(layout => {
            const row = document.createElement('div');
            row.className = 'group flex items-center justify-between px-4 py-2 hover:bg-blue-600/10 cursor-pointer transition-colors';
            const panelCount = layout.panels.length;
            const timeStr = new Date(layout.timestamp).toLocaleString('ro-RO', {
                day:'2-digit', month:'2-digit', hour:'2-digit', minute:'2-digit'
            });
            row.innerHTML = `
                <div class="flex-1 min-w-0" onclick="">
                    <div class="text-[11px] font-mono text-gray-300 group-hover:text-blue-400 transition-colors truncate">${layout.name}</div>
                    <div class="text-[9px] text-gray-600 font-mono mt-0.5">${panelCount} chart${panelCount>1?'s':''} Â· ${timeStr}</div>
                </div>
                <button class="delete-layout-btn ml-2 opacity-0 group-hover:opacity-100 transition-opacity text-gray-600 hover:text-red-400 text-xs p-1 rounded" data-ts="${layout.timestamp}">âœ•</button>
            `;
            row.querySelector('.flex-1').addEventListener('click', () => applyLayout(layout));
            row.querySelector('.delete-layout-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                if (confirm(`Delete "${layout.name}"?`)) deleteLayout(layout.timestamp);
            });
            container.appendChild(row);
        });
    }

function syncPanelTFBar(panel, timeframe) {
    const tfBar = panel.wrapperEl.querySelector('.panel-tf-bar');
    if (!tfBar) return;
    tfBar.querySelectorAll('.timeframe-btn').forEach(btn => {
        btn.classList.remove('active');
        const tfMap = { '5m': 5, '15m': 15, '30m': 30, '1h': 60, '4h': 240, '1D': 1440 };
        if (tfMap[btn.textContent.trim()] === timeframe) btn.classList.add('active');
    });
}

    function closeLayoutsDropdown() {
        const dd = document.getElementById('layouts-dropdown');
        dd.classList.remove('open');
        setTimeout(() => dd.classList.add('hidden'), 200);
    }

    // â”€â”€ Layouts button toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    document.getElementById('layouts-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const dd = document.getElementById('layouts-dropdown');
        const isOpen = dd.classList.contains('open');
        if (isOpen) {
            closeLayoutsDropdown();
        } else {
            dd.classList.remove('hidden');
            requestAnimationFrame(() => dd.classList.add('open'));
            renderSavedLayouts();
        }
    });

    document.getElementById('save-layout-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        saveLayout();
    });

    document.addEventListener('click', (e) => {
        if (!e.target.closest('#layouts-wrapper')) closeLayoutsDropdown();
    });

    async function init() {
        try {
            const interval=getIntervalString(BASE_TIMEFRAME);
            const response=await fetch(`https://api.bybit.com/v5/market/kline?category=inverse&symbol=BTCUSD&interval=${interval}&limit=1000`);
            const data=await response.json();
            if (data.result&&data.result.list) {
                base5mCandles=data.result.list.map(d=>({
                    time:parseInt(d[0])/1000, open:parseFloat(d[1]), high:parseFloat(d[2]),
                    low:parseFloat(d[3]), close:parseFloat(d[4]), volume:parseFloat(d[5]),
                    oiOpen:0, oiHigh:0, oiLow:0, oiClose:0
                })).sort((a,b)=>a.time-b.time);
                displayCandles=base5mCandles.slice();
                displayClusters=aggregateClusters(base5mClusters,config.displayTimeframe);
                mainSeries.setData(displayCandles);
                lastBarTime=base5mCandles[base5mCandles.length-1].time;
                currentPrice=base5mCandles[base5mCandles.length-1].close;
                tpoCacheKey = ''; // ensure fresh build after data load
                await fetchOpenInterest();
                chart.timeScale().fitContent();
                updateCandleAppearance();
            }
            startWebSockets();
            setInterval(()=>{needsRedraw=true;scheduleDraw();},config.drawDelay);
        } catch(e) { console.error(e); }
    }

    async function fetchOpenInterest() {
        try {
            const oiInterval=getOIIntervalString(BASE_TIMEFRAME);
            const resp=await fetch(`https://api.bybit.com/v5/market/open-interest?category=inverse&symbol=BTCUSD&intervalTime=${oiInterval}&limit=200`);
            const oiData=await resp.json();
            if (oiData.result&&oiData.result.list) {
                const oiMap={}, barSec=getBarSeconds(BASE_TIMEFRAME);
                oiData.result.list.forEach(item=>{ const ts=parseInt(item.timestamp)/1000; oiMap[Math.floor(ts/barSec)*barSec]=parseFloat(item.openInterest); });
                let previousOI=0;
                const firstTs=Object.keys(oiMap).sort()[0];
                if (firstTs) previousOI=oiMap[firstTs]/base5mCandles.find(c=>c.time>=firstTs)?.close||0;
                for (let i=0;i<base5mCandles.length;i++) {
                    const c=base5mCandles[i], foundRawOI=oiMap[c.time];
                    if (foundRawOI) {
                        const oiBTC=foundRawOI/c.close;
                        if (previousOI===0) previousOI=oiBTC;
                        c.oiOpen=previousOI; c.oiClose=oiBTC; c.oiHigh=Math.max(previousOI,oiBTC); c.oiLow=Math.min(previousOI,oiBTC); previousOI=oiBTC;
                    } else { c.oiOpen=previousOI; c.oiClose=previousOI; c.oiHigh=previousOI; c.oiLow=previousOI; }
                }
                displayCandles=base5mCandles.slice();
                if (previousOI>0) document.getElementById('oi-display').innerText=previousOI.toFixed(2);
            }
        } catch(e) { console.error("OI Fetch Error",e); }
    }

function startWebSockets() {
        const wsInterval = getWSInterval(BASE_TIMEFRAME);
        ws = new WebSocket("wss://stream.bybit.com/v5/public/inverse");
        ws.onopen = () => ws.send(JSON.stringify({op:"subscribe",args:[`kline.${wsInterval}.BTCUSD`,"publicTrade.BTCUSD","tickers.BTCUSD"]}));
        ws.onclose = () => {
            console.warn('WebSocket disconnected, reconnecting in 3s...');
            setTimeout(startWebSockets, 3000);
        };
        ws.onerror = (e) => { console.error('WebSocket error', e); ws.close(); };
        ws.onmessage = (event) => {
            const msg = JSON.parse(event.data); if (!msg.data) return;
            if (msg.topic&&msg.topic.includes("tickers")&&msg.data.openInterest) {
                const rawOI=parseFloat(msg.data.openInterest), lastCandle=base5mCandles[base5mCandles.length-1];
                if (lastCandle&&currentPrice>0) {
                    const oiBTC=rawOI/currentPrice;
                    document.getElementById('oi-display').innerText=oiBTC.toFixed(2);
                    if (lastCandle.oiOpen===0||!lastCandle.oiOpen) lastCandle.oiOpen=(base5mCandles.length>1)?base5mCandles[base5mCandles.length-2].oiClose:oiBTC;
                    lastCandle.oiClose=oiBTC; lastCandle.oiHigh=Math.max(lastCandle.oiHigh||-Infinity,oiBTC); lastCandle.oiLow=Math.min(lastCandle.oiLow||Infinity,oiBTC);
                    displayCandles=aggregateCandles(base5mCandles,config.displayTimeframe); scheduleDraw();
                }
            }
            if (msg.topic&&msg.topic.includes("kline")) {
                const k=msg.data[0], ts=parseInt(k.start)/1000;
                if (ts>lastBarTime) {
                    const closingOI=base5mCandles[base5mCandles.length-1]?.oiClose||0;
                    base5mClusters[String(ts)]={};lastBarTime=ts;
                    upsertCandle(ts,parseFloat(k.open),parseFloat(k.high),parseFloat(k.low),parseFloat(k.close),parseFloat(k.volume||0));
                    const newCandle=base5mCandles[base5mCandles.length-1];
                    newCandle.oiOpen=closingOI;newCandle.oiClose=closingOI;newCandle.oiHigh=closingOI;newCandle.oiLow=closingOI;
                    tpoCacheKey = '';
                } else { upsertCandle(ts,parseFloat(k.open),parseFloat(k.high),parseFloat(k.low),parseFloat(k.close),parseFloat(k.volume||0)); }
                displayCandles=aggregateCandles(base5mCandles,config.displayTimeframe);
                displayClusters=aggregateClusters(base5mClusters,config.displayTimeframe);
                mainSeries.update(displayCandles[displayCandles.length-1]);
                extraPanels.forEach(p => {
                    p.displayCandles = aggregateCandles(base5mCandles, p.displayTimeframe);
                    p.displayClusters = aggregateClusters(base5mClusters, p.displayTimeframe);
                    const last = p.displayCandles[p.displayCandles.length-1];
                    if (last) p.mainSeries.update(last);
                });
                scheduleDraw();
            }
if (msg.topic&&msg.topic.includes("publicTrade")) {
                msg.data.forEach(trade => {
                    const price = parseFloat(trade.p); currentPrice = price;
                    const valUsd = parseFloat(trade.v);
                    const bucket = Math.floor(price / config.baseTickSize) * config.baseTickSize;
                    const timeKey = String(lastBarTime), bucketKey = String(bucket);
                    if (!base5mClusters[timeKey]) base5mClusters[timeKey] = {};
                    if (!base5mClusters[timeKey][bucketKey]) base5mClusters[timeKey][bucketKey] = { buy: 0, sell: 0 };
                    if (trade.S === "Buy") base5mClusters[timeKey][bucketKey].buy += valUsd;
                    else base5mClusters[timeKey][bucketKey].sell += valUsd;
                    clustersDirty = true;

                    const lastBase = base5mCandles[base5mCandles.length - 1];
                    if (lastBase) {
                        lastBase.close = price;
                        if (price > lastBase.high) lastBase.high = price;
                        if (price < lastBase.low) lastBase.low = price;
                        const lastDisplay = displayCandles[displayCandles.length - 1];
                        if (lastDisplay) {
                            lastDisplay.close = price;
                            if (price > lastDisplay.high) lastDisplay.high = price;
                            if (price < lastDisplay.low) lastDisplay.low = price;
                            mainSeries.update(lastDisplay);
                        }
                    }

                    document.getElementById('price').innerText = price.toLocaleString();
                    scheduleDraw();
                });
            }
        };  
    }       
// â”€â”€ Initialize panel 0 active-context pointers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    activePriceLabelEl = document.getElementById('custom-price-label');
    activeTimerBox     = document.getElementById('timer-box');
    activeWrapperEl    = document.getElementById('panel-wrapper-0');

    updatePaneRight();
    resizeAll();
    init();

    // â”€â”€ Panel 0 selection handler (must be after DOM is ready) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    if (activeWrapperEl) {
        activeWrapperEl.addEventListener('click', () => {
            selectedPanelId = 0;
            document.querySelectorAll('.chart-panel-wrapper').forEach(w => w.classList.remove('selected'));
            activeWrapperEl.classList.add('selected');
            syncHeaderButtons();
        });
        activeWrapperEl.classList.add('selected'); // Start with panel 0 selected
    } else {
        console.error('panel-wrapper-0 not found! Check your HTML structure.');
    }

    // â”€â”€ Add Chart button (must be after DOM elements exist) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const addChartBtn = document.getElementById('add-chart-btn');
    if (addChartBtn) {
        addChartBtn.addEventListener('click', () => {
            createExtraPanel();
            const container = document.getElementById('charts-container');
            const allWrappers = container.querySelectorAll('.chart-panel-wrapper');
            allWrappers.forEach(w => w.style.flex = '1');
            setTimeout(() => resizeAll(), 50);
        });
    }

</script>
</body>
</html>
